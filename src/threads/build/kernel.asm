
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 56 00 00 00       	call   c00201b3 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <run_task>:
}

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020182:	53                   	push   %ebx
c0020183:	83 ec 10             	sub    $0x10,%esp
  const char *task = argv[1];
c0020186:	8b 44 24 18          	mov    0x18(%esp),%eax
c002018a:	8b 58 04             	mov    0x4(%eax),%ebx
  
  printf ("Executing '%s':\n", task);
c002018d:	53                   	push   %ebx
c002018e:	68 d1 d1 02 c0       	push   $0xc002d1d1
c0020193:	e8 bd 5e 00 00       	call   c0026055 <printf>
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020198:	89 1c 24             	mov    %ebx,(%esp)
c002019b:	e8 2a 96 00 00       	call   c00297ca <run_test>
#endif
  printf ("Execution of '%s' complete.\n", task);
c00201a0:	83 c4 08             	add    $0x8,%esp
c00201a3:	53                   	push   %ebx
c00201a4:	68 e2 d1 02 c0       	push   $0xc002d1e2
c00201a9:	e8 a7 5e 00 00       	call   c0026055 <printf>
}
c00201ae:	83 c4 18             	add    $0x18,%esp
c00201b1:	5b                   	pop    %ebx
c00201b2:	c3                   	ret    

c00201b3 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00201b3:	55                   	push   %ebp
c00201b4:	57                   	push   %edi
c00201b5:	56                   	push   %esi
c00201b6:	53                   	push   %ebx
c00201b7:	83 ec 30             	sub    $0x30,%esp
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c00201ba:	b8 d5 96 03 c0       	mov    $0xc00396d5,%eax
c00201bf:	2d fc 79 03 c0       	sub    $0xc00379fc,%eax
c00201c4:	50                   	push   %eax
c00201c5:	6a 00                	push   $0x0
c00201c7:	68 fc 79 03 c0       	push   $0xc00379fc
c00201cc:	e8 d3 70 00 00       	call   c00272a4 <memset>
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00201d1:	8b 3d 3a 7d 00 c0    	mov    0xc0007d3a,%edi
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c00201d7:	83 c4 10             	add    $0x10,%esp
c00201da:	be 00 00 00 00       	mov    $0x0,%esi
c00201df:	bb 3e 7d 00 c0       	mov    $0xc0007d3e,%ebx
    {
      if (p >= end)
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
c00201e4:	bd be 7d 00 c0       	mov    $0xc0007dbe,%ebp
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c00201e9:	85 ff                	test   %edi,%edi
c00201eb:	7f 26                	jg     c0020213 <pintos_init+0x60>
c00201ed:	e9 a3 04 00 00       	jmp    c0020695 <pintos_init+0x4e2>
    {
      if (p >= end)
c00201f2:	81 fb bd 7d 00 c0    	cmp    $0xc0007dbd,%ebx
c00201f8:	76 19                	jbe    c0020213 <pintos_init+0x60>
        PANIC ("command line arguments overflow");
c00201fa:	68 bc d2 02 c0       	push   $0xc002d2bc
c00201ff:	68 08 bb 02 c0       	push   $0xc002bb08
c0020204:	68 d3 00 00 00       	push   $0xd3
c0020209:	68 ff d1 02 c0       	push   $0xc002d1ff
c002020e:	e8 ba 7a 00 00       	call   c0027ccd <debug_panic>

      argv[i] = p;
c0020213:	89 1c b5 00 7a 03 c0 	mov    %ebx,-0x3ffc8600(,%esi,4)
      p += strnlen (p, end - p) + 1;
c002021a:	83 ec 08             	sub    $0x8,%esp
c002021d:	89 e8                	mov    %ebp,%eax
c002021f:	29 d8                	sub    %ebx,%eax
c0020221:	50                   	push   %eax
c0020222:	53                   	push   %ebx
c0020223:	e8 8d 71 00 00       	call   c00273b5 <strnlen>
c0020228:	8d 5c 03 01          	lea    0x1(%ebx,%eax,1),%ebx
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c002022c:	83 c6 01             	add    $0x1,%esi
c002022f:	83 c4 10             	add    $0x10,%esp
c0020232:	39 f7                	cmp    %esi,%edi
c0020234:	75 bc                	jne    c00201f2 <pintos_init+0x3f>
c0020236:	e9 35 04 00 00       	jmp    c0020670 <pintos_init+0x4bd>
  argv[argc] = NULL;

  /* Print kernel command line. */
  printf ("Kernel command line:");
  for (i = 0; i < argc; i++)
    if (strchr (argv[i], ' ') == NULL)
c002023b:	8b 34 9d 00 7a 03 c0 	mov    -0x3ffc8600(,%ebx,4),%esi
c0020242:	83 ec 08             	sub    $0x8,%esp
c0020245:	6a 20                	push   $0x20
c0020247:	56                   	push   %esi
c0020248:	e8 02 6e 00 00       	call   c002704f <strchr>
c002024d:	83 c4 10             	add    $0x10,%esp
c0020250:	85 c0                	test   %eax,%eax
c0020252:	75 13                	jne    c0020267 <pintos_init+0xb4>
      printf (" %s", argv[i]);
c0020254:	83 ec 08             	sub    $0x8,%esp
c0020257:	56                   	push   %esi
c0020258:	68 ff df 02 c0       	push   $0xc002dfff
c002025d:	e8 f3 5d 00 00       	call   c0026055 <printf>
c0020262:	83 c4 10             	add    $0x10,%esp
c0020265:	eb 11                	jmp    c0020278 <pintos_init+0xc5>
    else
      printf (" '%s'", argv[i]);
c0020267:	83 ec 08             	sub    $0x8,%esp
c002026a:	56                   	push   %esi
c002026b:	68 14 d2 02 c0       	push   $0xc002d214
c0020270:	e8 e0 5d 00 00       	call   c0026055 <printf>
c0020275:	83 c4 10             	add    $0x10,%esp
    }
  argv[argc] = NULL;

  /* Print kernel command line. */
  printf ("Kernel command line:");
  for (i = 0; i < argc; i++)
c0020278:	83 c3 01             	add    $0x1,%ebx
c002027b:	39 df                	cmp    %ebx,%edi
c002027d:	75 bc                	jne    c002023b <pintos_init+0x88>
    if (strchr (argv[i], ' ') == NULL)
      printf (" %s", argv[i]);
    else
      printf (" '%s'", argv[i]);
  printf ("\n");
c002027f:	83 ec 0c             	sub    $0xc,%esp
c0020282:	6a 0a                	push   $0xa
c0020284:	e8 ec 94 00 00       	call   c0029775 <putchar>
/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
  for (; *argv != NULL && **argv == '-'; argv++)
c0020289:	a1 00 7a 03 c0       	mov    0xc0037a00,%eax
c002028e:	83 c4 10             	add    $0x10,%esp
c0020291:	85 c0                	test   %eax,%eax
c0020293:	0f 84 36 01 00 00    	je     c00203cf <pintos_init+0x21c>
c0020299:	80 38 2d             	cmpb   $0x2d,(%eax)
c002029c:	0f 85 34 01 00 00    	jne    c00203d6 <pintos_init+0x223>
c00202a2:	bd 00 7a 03 c0       	mov    $0xc0037a00,%ebp
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c00202a7:	83 ec 04             	sub    $0x4,%esp
c00202aa:	8d 7c 24 20          	lea    0x20(%esp),%edi
c00202ae:	57                   	push   %edi
c00202af:	68 91 de 02 c0       	push   $0xc002de91
c00202b4:	50                   	push   %eax
c00202b5:	e8 ec 6e 00 00       	call   c00271a6 <strtok_r>
c00202ba:	89 c3                	mov    %eax,%ebx
      char *value = strtok_r (NULL, "", &save_ptr);
c00202bc:	83 c4 0c             	add    $0xc,%esp
c00202bf:	8d 44 24 20          	lea    0x20(%esp),%eax
c00202c3:	50                   	push   %eax
c00202c4:	68 a3 de 02 c0       	push   $0xc002dea3
c00202c9:	6a 00                	push   $0x0
c00202cb:	e8 d6 6e 00 00       	call   c00271a6 <strtok_r>
      
      if (!strcmp (name, "-h"))
c00202d0:	bf 1a d2 02 c0       	mov    $0xc002d21a,%edi
c00202d5:	b9 03 00 00 00       	mov    $0x3,%ecx
c00202da:	89 de                	mov    %ebx,%esi
c00202dc:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00202de:	0f 97 c1             	seta   %cl
c00202e1:	0f 92 c2             	setb   %dl
c00202e4:	83 c4 10             	add    $0x10,%esp
c00202e7:	38 d1                	cmp    %dl,%cl
c00202e9:	75 12                	jne    c00202fd <pintos_init+0x14a>
/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00202eb:	83 ec 0c             	sub    $0xc,%esp
c00202ee:	68 dc d2 02 c0       	push   $0xc002d2dc
c00202f3:	e8 0c 94 00 00       	call   c0029704 <puts>
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c00202f8:	e8 7f 56 00 00       	call   c002597c <shutdown_power_off>
      char *name = strtok_r (*argv, "=", &save_ptr);
      char *value = strtok_r (NULL, "", &save_ptr);
      
      if (!strcmp (name, "-h"))
        usage ();
      else if (!strcmp (name, "-q"))
c00202fd:	bf 1d d2 02 c0       	mov    $0xc002d21d,%edi
c0020302:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020307:	89 de                	mov    %ebx,%esi
c0020309:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002030b:	0f 97 c1             	seta   %cl
c002030e:	0f 92 c2             	setb   %dl
c0020311:	38 d1                	cmp    %dl,%cl
c0020313:	75 12                	jne    c0020327 <pintos_init+0x174>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020315:	83 ec 0c             	sub    $0xc,%esp
c0020318:	6a 01                	push   $0x1
c002031a:	e8 e3 55 00 00       	call   c0025902 <shutdown_configure>
c002031f:	83 c4 10             	add    $0x10,%esp
c0020322:	e9 93 00 00 00       	jmp    c00203ba <pintos_init+0x207>
      else if (!strcmp (name, "-r"))
c0020327:	bf 20 d2 02 c0       	mov    $0xc002d220,%edi
c002032c:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020331:	89 de                	mov    %ebx,%esi
c0020333:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020335:	0f 97 c1             	seta   %cl
c0020338:	0f 92 c2             	setb   %dl
c002033b:	38 d1                	cmp    %dl,%cl
c002033d:	75 0f                	jne    c002034e <pintos_init+0x19b>
        shutdown_configure (SHUTDOWN_REBOOT);
c002033f:	83 ec 0c             	sub    $0xc,%esp
c0020342:	6a 02                	push   $0x2
c0020344:	e8 b9 55 00 00       	call   c0025902 <shutdown_configure>
c0020349:	83 c4 10             	add    $0x10,%esp
c002034c:	eb 6c                	jmp    c00203ba <pintos_init+0x207>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c002034e:	bf 23 d2 02 c0       	mov    $0xc002d223,%edi
c0020353:	b9 04 00 00 00       	mov    $0x4,%ecx
c0020358:	89 de                	mov    %ebx,%esi
c002035a:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002035c:	0f 97 c1             	seta   %cl
c002035f:	0f 92 c2             	setb   %dl
c0020362:	38 d1                	cmp    %dl,%cl
c0020364:	75 16                	jne    c002037c <pintos_init+0x1c9>
        random_init (atoi (value));
c0020366:	83 ec 0c             	sub    $0xc,%esp
c0020369:	50                   	push   %eax
c002036a:	e8 a3 67 00 00       	call   c0026b12 <atoi>
c002036f:	89 04 24             	mov    %eax,(%esp)
c0020372:	e8 c7 57 00 00       	call   c0025b3e <random_init>
c0020377:	83 c4 10             	add    $0x10,%esp
c002037a:	eb 3e                	jmp    c00203ba <pintos_init+0x207>
      else if (!strcmp (name, "-mlfqs"))
c002037c:	bf 27 d2 02 c0       	mov    $0xc002d227,%edi
c0020381:	b9 07 00 00 00       	mov    $0x7,%ecx
c0020386:	89 de                	mov    %ebx,%esi
c0020388:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002038a:	0f 97 c2             	seta   %dl
c002038d:	0f 92 c0             	setb   %al
c0020390:	38 c2                	cmp    %al,%dl
c0020392:	75 09                	jne    c002039d <pintos_init+0x1ea>
        thread_mlfqs = true;
c0020394:	c6 05 d4 96 03 c0 01 	movb   $0x1,0xc00396d4
c002039b:	eb 1d                	jmp    c00203ba <pintos_init+0x207>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c002039d:	83 ec 0c             	sub    $0xc,%esp
c00203a0:	53                   	push   %ebx
c00203a1:	68 ac d4 02 c0       	push   $0xc002d4ac
c00203a6:	68 f8 ba 02 c0       	push   $0xc002baf8
c00203ab:	68 0c 01 00 00       	push   $0x10c
c00203b0:	68 ff d1 02 c0       	push   $0xc002d1ff
c00203b5:	e8 13 79 00 00       	call   c0027ccd <debug_panic>
/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
  for (; *argv != NULL && **argv == '-'; argv++)
c00203ba:	83 c5 04             	add    $0x4,%ebp
c00203bd:	8b 45 00             	mov    0x0(%ebp),%eax
c00203c0:	85 c0                	test   %eax,%eax
c00203c2:	74 17                	je     c00203db <pintos_init+0x228>
c00203c4:	80 38 2d             	cmpb   $0x2d,(%eax)
c00203c7:	0f 84 da fe ff ff    	je     c00202a7 <pintos_init+0xf4>
c00203cd:	eb 0c                	jmp    c00203db <pintos_init+0x228>
c00203cf:	bd 00 7a 03 c0       	mov    $0xc0037a00,%ebp
c00203d4:	eb 05                	jmp    c00203db <pintos_init+0x228>
c00203d6:	bd 00 7a 03 c0       	mov    $0xc0037a00,%ebp
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c00203db:	e8 c1 53 00 00       	call   c00257a1 <rtc_get_time>
c00203e0:	83 ec 0c             	sub    $0xc,%esp
c00203e3:	50                   	push   %eax
c00203e4:	e8 55 57 00 00       	call   c0025b3e <random_init>
  argv = read_command_line ();
  argv = parse_options (argv);

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00203e9:	e8 74 04 00 00       	call   c0020862 <thread_init>
  console_init ();  
c00203ee:	e8 a0 92 00 00       	call   c0029693 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00203f3:	83 c4 08             	add    $0x8,%esp
c00203f6:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00203fb:	c1 e0 0c             	shl    $0xc,%eax
c00203fe:	c1 e8 0a             	shr    $0xa,%eax
c0020401:	50                   	push   %eax
c0020402:	68 d4 d4 02 c0       	push   $0xc002d4d4
c0020407:	e8 49 5c 00 00       	call   c0026055 <printf>
          init_ram_pages * PGSIZE / 1024);

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c002040c:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0020413:	e8 b6 2b 00 00       	call   c0022fce <palloc_init>
  malloc_init ();
c0020418:	e8 7b 2f 00 00       	call   c0023398 <malloc_init>
{
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002041d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020424:	e8 dd 2c 00 00       	call   c0023106 <palloc_get_page>
c0020429:	89 44 24 18          	mov    %eax,0x18(%esp)
c002042d:	a3 d0 96 03 c0       	mov    %eax,0xc00396d0
  pt = NULL;
  for (page = 0; page < init_ram_pages; page++)
c0020432:	83 c4 10             	add    $0x10,%esp
c0020435:	83 3d 7e 01 02 c0 00 	cmpl   $0x0,0xc002017e
c002043c:	0f 84 0b 01 00 00    	je     c002054d <pintos_init+0x39a>
c0020442:	be 00 00 00 c0       	mov    $0xc0000000,%esi
c0020447:	b8 00 00 00 00       	mov    $0x0,%eax
c002044c:	bf 00 00 00 00       	mov    $0x0,%edi
c0020451:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020455:	89 f3                	mov    %esi,%ebx
c0020457:	81 e3 00 f0 3f 00    	and    $0x3ff000,%ebx
c002045d:	c1 eb 0c             	shr    $0xc,%ebx
c0020460:	89 74 24 04          	mov    %esi,0x4(%esp)
    {
      uintptr_t paddr = page * PGSIZE;
      char *vaddr = ptov (paddr);
      size_t pde_idx = pd_no (vaddr);
      size_t pte_idx = pt_no (vaddr);
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020464:	81 fe 00 10 03 c0    	cmp    $0xc0031000,%esi
c002046a:	0f 92 c1             	setb   %cl
c002046d:	81 fe 00 00 02 c0    	cmp    $0xc0020000,%esi
c0020473:	0f 93 c2             	setae  %dl
c0020476:	21 d1                	and    %edx,%ecx
c0020478:	88 4c 24 03          	mov    %cl,0x3(%esp)

      if (pd[pde_idx] == 0)
c002047c:	89 f2                	mov    %esi,%edx
c002047e:	c1 ea 16             	shr    $0x16,%edx
c0020481:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0020485:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c0020488:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c002048c:	75 65                	jne    c00204f3 <pintos_init+0x340>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002048e:	83 ec 0c             	sub    $0xc,%esp
c0020491:	6a 03                	push   $0x3
c0020493:	e8 6e 2c 00 00       	call   c0023106 <palloc_get_page>
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
  return (uintptr_t) va & PGMASK;
c0020498:	89 c2                	mov    %eax,%edx
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
  ASSERT (pg_ofs (pt) == 0);
c002049a:	83 c4 10             	add    $0x10,%esp
c002049d:	a9 ff 0f 00 00       	test   $0xfff,%eax
c00204a2:	74 1e                	je     c00204c2 <pintos_init+0x30f>
c00204a4:	83 ec 0c             	sub    $0xc,%esp
c00204a7:	68 2e d2 02 c0       	push   $0xc002d22e
c00204ac:	68 3f d2 02 c0       	push   $0xc002d23f
c00204b1:	68 ec ba 02 c0       	push   $0xc002baec
c00204b6:	6a 48                	push   $0x48
c00204b8:	68 56 d2 02 c0       	push   $0xc002d256
c00204bd:	e8 0b 78 00 00       	call   c0027ccd <debug_panic>
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
  ASSERT (is_kernel_vaddr (vaddr));
c00204c2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00204c7:	77 1e                	ja     c00204e7 <pintos_init+0x334>
c00204c9:	83 ec 0c             	sub    $0xc,%esp
c00204cc:	68 6a d2 02 c0       	push   $0xc002d26a
c00204d1:	68 3f d2 02 c0       	push   $0xc002d23f
c00204d6:	68 e4 ba 02 c0       	push   $0xc002bae4
c00204db:	6a 54                	push   $0x54
c00204dd:	68 82 d2 02 c0       	push   $0xc002d282
c00204e2:	e8 e6 77 00 00       	call   c0027ccd <debug_panic>
          pd[pde_idx] = pde_create (pt);
c00204e7:	81 c2 00 00 00 40    	add    $0x40000000,%edx
c00204ed:	83 ca 07             	or     $0x7,%edx
c00204f0:	89 55 00             	mov    %edx,0x0(%ebp)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00204f3:	8d 0c 98             	lea    (%eax,%ebx,4),%ecx
c00204f6:	81 7c 24 04 ff ff ff 	cmpl   $0xbfffffff,0x4(%esp)
c00204fd:	bf 
c00204fe:	77 1e                	ja     c002051e <pintos_init+0x36b>
c0020500:	83 ec 0c             	sub    $0xc,%esp
c0020503:	68 6a d2 02 c0       	push   $0xc002d26a
c0020508:	68 3f d2 02 c0       	push   $0xc002d23f
c002050d:	68 e4 ba 02 c0       	push   $0xc002bae4
c0020512:	6a 54                	push   $0x54
c0020514:	68 82 d2 02 c0       	push   $0xc002d282
c0020519:	e8 af 77 00 00       	call   c0027ccd <debug_panic>
c002051e:	89 fa                	mov    %edi,%edx
c0020520:	c1 e2 0c             	shl    $0xc,%edx
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
  ASSERT (pg_ofs (page) == 0);
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c0020523:	80 7c 24 03 01       	cmpb   $0x1,0x3(%esp)
c0020528:	19 db                	sbb    %ebx,%ebx
c002052a:	83 e3 02             	and    $0x2,%ebx
c002052d:	83 ca 01             	or     $0x1,%edx
c0020530:	09 da                	or     %ebx,%edx
c0020532:	89 11                	mov    %edx,(%ecx)
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
  pt = NULL;
  for (page = 0; page < init_ram_pages; page++)
c0020534:	83 c7 01             	add    $0x1,%edi
c0020537:	81 c6 00 10 00 00    	add    $0x1000,%esi
c002053d:	3b 3d 7e 01 02 c0    	cmp    0xc002017e,%edi
c0020543:	0f 82 0c ff ff ff    	jb     c0020455 <pintos_init+0x2a2>
c0020549:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c002054d:	a1 d0 96 03 c0       	mov    0xc00396d0,%eax
c0020552:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0020557:	77 1e                	ja     c0020577 <pintos_init+0x3c4>
c0020559:	83 ec 0c             	sub    $0xc,%esp
c002055c:	68 6a d2 02 c0       	push   $0xc002d26a
c0020561:	68 3f d2 02 c0       	push   $0xc002d23f
c0020566:	68 e4 ba 02 c0       	push   $0xc002bae4
c002056b:	6a 54                	push   $0x54
c002056d:	68 82 d2 02 c0       	push   $0xc002d282
c0020572:	e8 56 77 00 00       	call   c0027ccd <debug_panic>
c0020577:	05 00 00 00 40       	add    $0x40000000,%eax
c002057c:	0f 22 d8             	mov    %eax,%cr3
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002057f:	e8 2d 11 00 00       	call   c00216b1 <intr_init>
  timer_init ();
c0020584:	e8 c4 33 00 00       	call   c002394d <timer_init>
  kbd_init ();
c0020589:	e8 c8 38 00 00       	call   c0023e56 <kbd_init>
  input_init ();
c002058e:	e8 a9 4d 00 00       	call   c002533c <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c0020593:	e8 25 0d 00 00       	call   c00212bd <thread_start>
  serial_init_queue ();
c0020598:	e8 ce 3c 00 00       	call   c002426b <serial_init_queue>
  timer_calibrate ();
c002059d:	e8 d1 33 00 00       	call   c0023973 <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c00205a2:	83 ec 0c             	sub    $0xc,%esp
c00205a5:	68 98 d2 02 c0       	push   $0xc002d298
c00205aa:	e8 55 91 00 00       	call   c0029704 <puts>
  
  if (*argv != NULL) {
c00205af:	8b 75 00             	mov    0x0(%ebp),%esi
c00205b2:	83 c4 10             	add    $0x10,%esp
c00205b5:	85 f6                	test   %esi,%esi
c00205b7:	0f 85 9a 00 00 00    	jne    c0020657 <pintos_init+0x4a4>
c00205bd:	e9 a4 00 00 00       	jmp    c0020666 <pintos_init+0x4b3>
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
        if (a->name == NULL)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00205c2:	83 ec 0c             	sub    $0xc,%esp
c00205c5:	56                   	push   %esi
c00205c6:	68 f8 d4 02 c0       	push   $0xc002d4f8
c00205cb:	68 c0 ba 02 c0       	push   $0xc002bac0
c00205d0:	68 4e 01 00 00       	push   $0x14e
c00205d5:	68 ff d1 02 c0       	push   $0xc002d1ff
c00205da:	e8 ee 76 00 00       	call   c0027ccd <debug_panic>
        else if (!strcmp (*argv, a->name))
c00205df:	83 ec 08             	sub    $0x8,%esp
c00205e2:	50                   	push   %eax
c00205e3:	56                   	push   %esi
c00205e4:	e8 7b 69 00 00       	call   c0026f64 <strcmp>
c00205e9:	83 c4 10             	add    $0x10,%esp
c00205ec:	85 c0                	test   %eax,%eax
c00205ee:	75 15                	jne    c0020605 <pintos_init+0x452>
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c00205f0:	8b 53 04             	mov    0x4(%ebx),%edx
c00205f3:	83 fa 01             	cmp    $0x1,%edx
c00205f6:	7e 47                	jle    c002063f <pintos_init+0x48c>
        if (argv[i] == NULL)
c00205f8:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c00205fc:	74 19                	je     c0020617 <pintos_init+0x464>
c00205fe:	b8 01 00 00 00       	mov    $0x1,%eax
c0020603:	eb 33                	jmp    c0020638 <pintos_init+0x485>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020605:	83 c3 0c             	add    $0xc,%ebx
        if (a->name == NULL)
c0020608:	8b 03                	mov    (%ebx),%eax
c002060a:	85 c0                	test   %eax,%eax
c002060c:	75 d1                	jne    c00205df <pintos_init+0x42c>
c002060e:	eb b2                	jmp    c00205c2 <pintos_init+0x40f>
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
        if (argv[i] == NULL)
c0020610:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c0020615:	75 21                	jne    c0020638 <pintos_init+0x485>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020617:	83 ec 08             	sub    $0x8,%esp
c002061a:	83 ea 01             	sub    $0x1,%edx
c002061d:	52                   	push   %edx
c002061e:	56                   	push   %esi
c002061f:	68 20 d5 02 c0       	push   $0xc002d520
c0020624:	68 c0 ba 02 c0       	push   $0xc002bac0
c0020629:	68 55 01 00 00       	push   $0x155
c002062e:	68 ff d1 02 c0       	push   $0xc002d1ff
c0020633:	e8 95 76 00 00       	call   c0027ccd <debug_panic>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020638:	83 c0 01             	add    $0x1,%eax
c002063b:	39 d0                	cmp    %edx,%eax
c002063d:	75 d1                	jne    c0020610 <pintos_init+0x45d>
        if (argv[i] == NULL)
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);

      /* Invoke action and advance. */
      a->function (argv);
c002063f:	83 ec 0c             	sub    $0xc,%esp
c0020642:	55                   	push   %ebp
c0020643:	ff 53 08             	call   *0x8(%ebx)
      argv += a->argc;
c0020646:	8b 43 04             	mov    0x4(%ebx),%eax
c0020649:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c002064d:	8b 75 00             	mov    0x0(%ebp),%esi
c0020650:	83 c4 10             	add    $0x10,%esp
c0020653:	85 f6                	test   %esi,%esi
c0020655:	74 0f                	je     c0020666 <pintos_init+0x4b3>
c0020657:	b8 02 d8 02 c0       	mov    $0xc002d802,%eax
c002065c:	bb cc ba 02 c0       	mov    $0xc002bacc,%ebx
c0020661:	e9 79 ff ff ff       	jmp    c00205df <pintos_init+0x42c>
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020666:	e8 9a 53 00 00       	call   c0025a05 <shutdown>
  thread_exit ();
c002066b:	e8 2c 0a 00 00       	call   c002109c <thread_exit>
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
    }
  argv[argc] = NULL;
c0020670:	c7 04 bd 00 7a 03 c0 	movl   $0x0,-0x3ffc8600(,%edi,4)
c0020677:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c002067b:	83 ec 0c             	sub    $0xc,%esp
c002067e:	68 a7 d2 02 c0       	push   $0xc002d2a7
c0020683:	e8 cd 59 00 00       	call   c0026055 <printf>
c0020688:	83 c4 10             	add    $0x10,%esp
c002068b:	bb 00 00 00 00       	mov    $0x0,%ebx
c0020690:	e9 a6 fb ff ff       	jmp    c002023b <pintos_init+0x88>
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
    }
  argv[argc] = NULL;
c0020695:	c7 04 bd 00 7a 03 c0 	movl   $0x0,-0x3ffc8600(,%edi,4)
c002069c:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c00206a0:	83 ec 0c             	sub    $0xc,%esp
c00206a3:	68 a7 d2 02 c0       	push   $0xc002d2a7
c00206a8:	e8 a8 59 00 00       	call   c0026055 <printf>
c00206ad:	83 c4 10             	add    $0x10,%esp
c00206b0:	e9 ca fb ff ff       	jmp    c002027f <pintos_init+0xcc>

c00206b5 <thread_cmp_priority>:
    }
  }
}

list_less_func *thread_cmp_priority(const struct list_elem *a,const struct list_elem *b,void *aux UNUSED){
  return  list_entry(a,struct thread,elem)->priority > list_entry(b,struct thread,elem)->priority;
c00206b5:	8b 44 24 08          	mov    0x8(%esp),%eax
c00206b9:	8b 54 24 04          	mov    0x4(%esp),%edx
c00206bd:	8b 40 cc             	mov    -0x34(%eax),%eax
c00206c0:	39 42 cc             	cmp    %eax,-0x34(%edx)
c00206c3:	0f 9f c0             	setg   %al
c00206c6:	0f b6 c0             	movzbl %al,%eax
}
c00206c9:	c3                   	ret    

c00206ca <thread_cmp_tickstowake>:
list_less_func * thread_cmp_priority_2(const struct list_elem *a,const struct list_elem *b,void *aux UNUSED){
  return  list_entry(a,struct thread,elem)->priority < list_entry(b,struct thread,elem)->priority;
}

list_less_func *thread_cmp_tickstowake(const struct list_elem *a,const struct list_elem *b,void *aux UNUSED){
  return list_entry(a,struct thread,elem)->tickstowake < list_entry(b,struct thread,elem)->tickstowake;
c00206ca:	8b 44 24 08          	mov    0x8(%esp),%eax
c00206ce:	8b 54 24 04          	mov    0x4(%esp),%edx
c00206d2:	8b 40 d8             	mov    -0x28(%eax),%eax
c00206d5:	39 42 d8             	cmp    %eax,-0x28(%edx)
c00206d8:	0f 9c c0             	setl   %al
c00206db:	0f b6 c0             	movzbl %al,%eax
}
c00206de:	c3                   	ret    

c00206df <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c00206df:	83 ec 0c             	sub    $0xc,%esp

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
  return t != NULL && t->magic == THREAD_MAGIC;
c00206e2:	85 c0                	test   %eax,%eax
c00206e4:	74 33                	je     c0020719 <alloc_frame+0x3a>
c00206e6:	81 78 58 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x58(%eax)
c00206ed:	75 2a                	jne    c0020719 <alloc_frame+0x3a>
c00206ef:	eb 21                	jmp    c0020712 <alloc_frame+0x33>
static void *
alloc_frame (struct thread *t, size_t size) 
{
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
  ASSERT (size % sizeof (uint32_t) == 0);
c00206f1:	83 ec 0c             	sub    $0xc,%esp
c00206f4:	68 44 d5 02 c0       	push   $0xc002d544
c00206f9:	68 3f d2 02 c0       	push   $0xc002d23f
c00206fe:	68 9c bb 02 c0       	push   $0xc002bb9c
c0020703:	68 1a 02 00 00       	push   $0x21a
c0020708:	68 62 d5 02 c0       	push   $0xc002d562
c002070d:	e8 bb 75 00 00       	call   c0027ccd <debug_panic>
c0020712:	f6 c2 03             	test   $0x3,%dl
c0020715:	74 23                	je     c002073a <alloc_frame+0x5b>
c0020717:	eb d8                	jmp    c00206f1 <alloc_frame+0x12>
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0020719:	83 ec 0c             	sub    $0xc,%esp
c002071c:	68 79 d5 02 c0       	push   $0xc002d579
c0020721:	68 3f d2 02 c0       	push   $0xc002d23f
c0020726:	68 9c bb 02 c0       	push   $0xc002bb9c
c002072b:	68 19 02 00 00       	push   $0x219
c0020730:	68 62 d5 02 c0       	push   $0xc002d562
c0020735:	e8 93 75 00 00       	call   c0027ccd <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);

  t->stack -= size;
c002073a:	8b 48 18             	mov    0x18(%eax),%ecx
c002073d:	29 d1                	sub    %edx,%ecx
c002073f:	89 48 18             	mov    %ecx,0x18(%eax)
  return t->stack;
}
c0020742:	89 c8                	mov    %ecx,%eax
c0020744:	83 c4 0c             	add    $0xc,%esp
c0020747:	c3                   	ret    

c0020748 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0020748:	57                   	push   %edi
c0020749:	56                   	push   %esi
c002074a:	53                   	push   %ebx
  enum intr_level old_level;

  ASSERT (t != NULL);
c002074b:	85 c0                	test   %eax,%eax
c002074d:	75 21                	jne    c0020770 <init_thread+0x28>
c002074f:	83 ec 0c             	sub    $0xc,%esp
c0020752:	68 ef ea 02 c0       	push   $0xc002eaef
c0020757:	68 3f d2 02 c0       	push   $0xc002d23f
c002075c:	68 c8 bb 02 c0       	push   $0xc002bbc8
c0020761:	68 fd 01 00 00       	push   $0x1fd
c0020766:	68 62 d5 02 c0       	push   $0xc002d562
c002076b:	e8 5d 75 00 00       	call   c0027ccd <debug_panic>
c0020770:	89 c3                	mov    %eax,%ebx
c0020772:	89 ce                	mov    %ecx,%esi
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020774:	83 f9 3f             	cmp    $0x3f,%ecx
c0020777:	76 21                	jbe    c002079a <init_thread+0x52>
c0020779:	83 ec 0c             	sub    $0xc,%esp
c002077c:	68 54 d6 02 c0       	push   $0xc002d654
c0020781:	68 3f d2 02 c0       	push   $0xc002d23f
c0020786:	68 c8 bb 02 c0       	push   $0xc002bbc8
c002078b:	68 fe 01 00 00       	push   $0x1fe
c0020790:	68 62 d5 02 c0       	push   $0xc002d562
c0020795:	e8 33 75 00 00       	call   c0027ccd <debug_panic>
  ASSERT (name != NULL);
c002079a:	85 d2                	test   %edx,%edx
c002079c:	75 21                	jne    c00207bf <init_thread+0x77>
c002079e:	83 ec 0c             	sub    $0xc,%esp
c00207a1:	68 87 d5 02 c0       	push   $0xc002d587
c00207a6:	68 3f d2 02 c0       	push   $0xc002d23f
c00207ab:	68 c8 bb 02 c0       	push   $0xc002bbc8
c00207b0:	68 ff 01 00 00       	push   $0x1ff
c00207b5:	68 62 d5 02 c0       	push   $0xc002d562
c00207ba:	e8 0e 75 00 00       	call   c0027ccd <debug_panic>

  memset (t, 0, sizeof *t);
c00207bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c00207c5:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
c00207cc:	8d 78 04             	lea    0x4(%eax),%edi
c00207cf:	83 e7 fc             	and    $0xfffffffc,%edi
c00207d2:	89 c1                	mov    %eax,%ecx
c00207d4:	29 f9                	sub    %edi,%ecx
c00207d6:	83 c1 5c             	add    $0x5c,%ecx
c00207d9:	c1 e9 02             	shr    $0x2,%ecx
c00207dc:	b8 00 00 00 00       	mov    $0x0,%eax
c00207e1:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c00207e3:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
  strlcpy (t->name, name, sizeof t->name);
c00207ea:	83 ec 04             	sub    $0x4,%esp
c00207ed:	6a 10                	push   $0x10
c00207ef:	52                   	push   %edx
c00207f0:	8d 43 08             	lea    0x8(%ebx),%eax
c00207f3:	50                   	push   %eax
c00207f4:	e8 e8 6b 00 00       	call   c00273e1 <strlcpy>
  t->stack = (uint8_t *) t + PGSIZE;
c00207f9:	8d 83 00 10 00 00    	lea    0x1000(%ebx),%eax
c00207ff:	89 43 18             	mov    %eax,0x18(%ebx)
  t->priority = priority;
c0020802:	89 73 1c             	mov    %esi,0x1c(%ebx)
  t->inital_priority = priority;
c0020805:	89 73 2c             	mov    %esi,0x2c(%ebx)
  list_init(&t->hold_locks);
c0020808:	8d 43 30             	lea    0x30(%ebx),%eax
c002080b:	89 04 24             	mov    %eax,(%esp)
c002080e:	e8 61 75 00 00       	call   c0027d74 <list_init>
  t->donate_thread = NULL;
c0020813:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  t->recent_cpu = 0;
c002081a:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
c0020821:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
  t->nice = 0;
c0020828:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  t->magic = THREAD_MAGIC;
c002082f:	c7 43 58 4b bf 6a cd 	movl   $0xcd6abf4b,0x58(%ebx)

  old_level = intr_disable ();
c0020836:	e8 55 0e 00 00       	call   c0021690 <intr_disable>
c002083b:	89 c6                	mov    %eax,%esi
  //list_push_back (&all_list, &t->allelem);
  list_insert_ordered(&all_list,&t->allelem,(list_less_func *) &thread_cmp_priority,NULL);
c002083d:	6a 00                	push   $0x0
c002083f:	68 b5 06 02 c0       	push   $0xc00206b5
c0020844:	83 c3 20             	add    $0x20,%ebx
c0020847:	53                   	push   %ebx
c0020848:	68 78 7b 03 c0       	push   $0xc0037b78
c002084d:	e8 0f 7e 00 00       	call   c0028661 <list_insert_ordered>
  intr_set_level (old_level);
c0020852:	83 c4 14             	add    $0x14,%esp
c0020855:	56                   	push   %esi
c0020856:	e8 3c 0e 00 00       	call   c0021697 <intr_set_level>
}
c002085b:	83 c4 10             	add    $0x10,%esp
c002085e:	5b                   	pop    %ebx
c002085f:	5e                   	pop    %esi
c0020860:	5f                   	pop    %edi
c0020861:	c3                   	ret    

c0020862 <thread_init>:
   thread_create().
   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c0020862:	56                   	push   %esi
c0020863:	53                   	push   %ebx
c0020864:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0020867:	e8 e7 0d 00 00       	call   c0021653 <intr_get_level>
c002086c:	85 c0                	test   %eax,%eax
c002086e:	74 1e                	je     c002088e <thread_init+0x2c>
c0020870:	83 ec 0c             	sub    $0xc,%esp
c0020873:	68 94 d5 02 c0       	push   $0xc002d594
c0020878:	68 3f d2 02 c0       	push   $0xc002d23f
c002087d:	68 d4 bb 02 c0       	push   $0xc002bbd4
c0020882:	6a 5a                	push   $0x5a
c0020884:	68 62 d5 02 c0       	push   $0xc002d562
c0020889:	e8 3f 74 00 00       	call   c0027ccd <debug_panic>

  lock_init (&tid_lock);
c002088e:	83 ec 0c             	sub    $0xc,%esp
c0020891:	68 40 7b 03 c0       	push   $0xc0037b40
c0020896:	e8 a2 20 00 00       	call   c002293d <lock_init>
  list_init (&ready_list);
c002089b:	c7 04 24 88 7b 03 c0 	movl   $0xc0037b88,(%esp)
c00208a2:	e8 cd 74 00 00       	call   c0027d74 <list_init>
  list_init (&all_list);
c00208a7:	c7 04 24 78 7b 03 c0 	movl   $0xc0037b78,(%esp)
c00208ae:	e8 c1 74 00 00       	call   c0027d74 <list_init>
  list_init(&sleep_list);
c00208b3:	c7 04 24 68 7b 03 c0 	movl   $0xc0037b68,(%esp)
c00208ba:	e8 b5 74 00 00       	call   c0027d74 <list_init>

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c00208bf:	89 e0                	mov    %esp,%eax
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  list_init (&ready_list);
  list_init (&all_list);
  list_init(&sleep_list);

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c00208c6:	a3 60 7b 03 c0       	mov    %eax,0xc0037b60
  init_thread (initial_thread, "main", PRI_DEFAULT);
c00208cb:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c00208d0:	ba b2 d5 02 c0       	mov    $0xc002d5b2,%edx
c00208d5:	e8 6e fe ff ff       	call   c0020748 <init_thread>
  initial_thread->status = THREAD_RUNNING;
c00208da:	8b 1d 60 7b 03 c0    	mov    0xc0037b60,%ebx
c00208e0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
allocate_tid (void) 
{
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00208e7:	c7 04 24 40 7b 03 c0 	movl   $0xc0037b40,(%esp)
c00208ee:	e8 cc 20 00 00       	call   c00229bf <lock_acquire>
  tid = next_tid++;
c00208f3:	8b 35 b8 75 03 c0    	mov    0xc00375b8,%esi
c00208f9:	8d 46 01             	lea    0x1(%esi),%eax
c00208fc:	a3 b8 75 03 c0       	mov    %eax,0xc00375b8
  lock_release (&tid_lock);
c0020901:	c7 04 24 40 7b 03 c0 	movl   $0xc0037b40,(%esp)
c0020908:	e8 42 22 00 00       	call   c0022b4f <lock_release>

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
  init_thread (initial_thread, "main", PRI_DEFAULT);
  initial_thread->status = THREAD_RUNNING;
  initial_thread->tid = allocate_tid ();
c002090d:	89 33                	mov    %esi,(%ebx)
}
c002090f:	83 c4 14             	add    $0x14,%esp
c0020912:	5b                   	pop    %ebx
c0020913:	5e                   	pop    %esi
c0020914:	c3                   	ret    

c0020915 <thread_print_stats>:
}

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020915:	83 ec 10             	sub    $0x10,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020918:	6a 00                	push   $0x0
c002091a:	6a 00                	push   $0x0
c002091c:	ff 35 34 7b 03 c0    	pushl  0xc0037b34
c0020922:	ff 35 30 7b 03 c0    	pushl  0xc0037b30
c0020928:	ff 35 3c 7b 03 c0    	pushl  0xc0037b3c
c002092e:	ff 35 38 7b 03 c0    	pushl  0xc0037b38
c0020934:	68 80 d6 02 c0       	push   $0xc002d680
c0020939:	e8 17 57 00 00       	call   c0026055 <printf>
          idle_ticks, kernel_ticks, user_ticks);
}
c002093e:	83 c4 2c             	add    $0x2c,%esp
c0020941:	c3                   	ret    

c0020942 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020942:	56                   	push   %esi
c0020943:	53                   	push   %ebx
c0020944:	83 ec 04             	sub    $0x4,%esp
c0020947:	8b 5c 24 10          	mov    0x10(%esp),%ebx

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
  return t != NULL && t->magic == THREAD_MAGIC;
c002094b:	85 db                	test   %ebx,%ebx
c002094d:	74 64                	je     c00209b3 <thread_unblock+0x71>
c002094f:	81 7b 58 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x58(%ebx)
c0020956:	75 5b                	jne    c00209b3 <thread_unblock+0x71>
c0020958:	eb 4a                	jmp    c00209a4 <thread_unblock+0x62>
  enum intr_level old_level;

  ASSERT (is_thread (t));

  old_level = intr_disable ();
  ASSERT (t->status == THREAD_BLOCKED);
c002095a:	83 ec 0c             	sub    $0xc,%esp
c002095d:	68 b7 d5 02 c0       	push   $0xc002d5b7
c0020962:	68 3f d2 02 c0       	push   $0xc002d23f
c0020967:	68 70 bb 02 c0       	push   $0xc002bb70
c002096c:	68 10 01 00 00       	push   $0x110
c0020971:	68 62 d5 02 c0       	push   $0xc002d562
c0020976:	e8 52 73 00 00       	call   c0027ccd <debug_panic>
  //list_push_back (&ready_list, &t->elem);
  list_insert_ordered(&ready_list,&t->elem,(list_less_func *) &thread_cmp_priority,NULL);
c002097b:	6a 00                	push   $0x0
c002097d:	68 b5 06 02 c0       	push   $0xc00206b5
c0020982:	8d 43 50             	lea    0x50(%ebx),%eax
c0020985:	50                   	push   %eax
c0020986:	68 88 7b 03 c0       	push   $0xc0037b88
c002098b:	e8 d1 7c 00 00       	call   c0028661 <list_insert_ordered>
  t->status = THREAD_READY;
c0020990:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
  intr_set_level (old_level);
c0020997:	89 34 24             	mov    %esi,(%esp)
c002099a:	e8 f8 0c 00 00       	call   c0021697 <intr_set_level>
}
c002099f:	83 c4 10             	add    $0x10,%esp
c00209a2:	eb 30                	jmp    c00209d4 <thread_unblock+0x92>
{
  enum intr_level old_level;

  ASSERT (is_thread (t));

  old_level = intr_disable ();
c00209a4:	e8 e7 0c 00 00       	call   c0021690 <intr_disable>
c00209a9:	89 c6                	mov    %eax,%esi
  ASSERT (t->status == THREAD_BLOCKED);
c00209ab:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
c00209af:	74 ca                	je     c002097b <thread_unblock+0x39>
c00209b1:	eb a7                	jmp    c002095a <thread_unblock+0x18>
void
thread_unblock (struct thread *t) 
{
  enum intr_level old_level;

  ASSERT (is_thread (t));
c00209b3:	83 ec 0c             	sub    $0xc,%esp
c00209b6:	68 79 d5 02 c0       	push   $0xc002d579
c00209bb:	68 3f d2 02 c0       	push   $0xc002d23f
c00209c0:	68 70 bb 02 c0       	push   $0xc002bb70
c00209c5:	68 0d 01 00 00       	push   $0x10d
c00209ca:	68 62 d5 02 c0       	push   $0xc002d562
c00209cf:	e8 f9 72 00 00       	call   c0027ccd <debug_panic>
  ASSERT (t->status == THREAD_BLOCKED);
  //list_push_back (&ready_list, &t->elem);
  list_insert_ordered(&ready_list,&t->elem,(list_less_func *) &thread_cmp_priority,NULL);
  t->status = THREAD_READY;
  intr_set_level (old_level);
}
c00209d4:	83 c4 04             	add    $0x4,%esp
c00209d7:	5b                   	pop    %ebx
c00209d8:	5e                   	pop    %esi
c00209d9:	c3                   	ret    

c00209da <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c00209da:	83 ec 0c             	sub    $0xc,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c00209dd:	89 e0                	mov    %esp,%eax

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
  return t != NULL && t->magic == THREAD_MAGIC;
c00209df:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00209e4:	74 34                	je     c0020a1a <thread_current+0x40>
c00209e6:	81 78 58 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x58(%eax)
c00209ed:	75 2b                	jne    c0020a1a <thread_current+0x40>
c00209ef:	eb 21                	jmp    c0020a12 <thread_current+0x38>
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
  ASSERT (t->status == THREAD_RUNNING);
c00209f1:	83 ec 0c             	sub    $0xc,%esp
c00209f4:	68 d3 d5 02 c0       	push   $0xc002d5d3
c00209f9:	68 3f d2 02 c0       	push   $0xc002d23f
c00209fe:	68 60 bb 02 c0       	push   $0xc002bb60
c0020a03:	68 2c 01 00 00       	push   $0x12c
c0020a08:	68 62 d5 02 c0       	push   $0xc002d562
c0020a0d:	e8 bb 72 00 00       	call   c0027ccd <debug_panic>
c0020a12:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0020a16:	74 23                	je     c0020a3b <thread_current+0x61>
c0020a18:	eb d7                	jmp    c00209f1 <thread_current+0x17>
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020a1a:	83 ec 0c             	sub    $0xc,%esp
c0020a1d:	68 79 d5 02 c0       	push   $0xc002d579
c0020a22:	68 3f d2 02 c0       	push   $0xc002d23f
c0020a27:	68 60 bb 02 c0       	push   $0xc002bb60
c0020a2c:	68 2b 01 00 00       	push   $0x12b
c0020a31:	68 62 d5 02 c0       	push   $0xc002d562
c0020a36:	e8 92 72 00 00       	call   c0027ccd <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);

  return t;
}
c0020a3b:	83 c4 0c             	add    $0xc,%esp
c0020a3e:	c3                   	ret    

c0020a3f <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c0020a3f:	55                   	push   %ebp
c0020a40:	57                   	push   %edi
c0020a41:	56                   	push   %esi
c0020a42:	53                   	push   %ebx
c0020a43:	83 ec 3c             	sub    $0x3c,%esp
  struct thread *t = thread_current ();
c0020a46:	e8 8f ff ff ff       	call   c00209da <thread_current>
c0020a4b:	89 c3                	mov    %eax,%ebx
  int ticks = timer_ticks();
c0020a4d:	e8 eb 2f 00 00       	call   c0023a3d <timer_ticks>
c0020a52:	89 c5                	mov    %eax,%ebp
  /* Update statistics. */
  if (t == idle_thread)
c0020a54:	3b 1d 64 7b 03 c0    	cmp    0xc0037b64,%ebx
c0020a5a:	75 10                	jne    c0020a6c <thread_tick+0x2d>
    idle_ticks++;
c0020a5c:	83 05 38 7b 03 c0 01 	addl   $0x1,0xc0037b38
c0020a63:	83 15 3c 7b 03 c0 00 	adcl   $0x0,0xc0037b3c
c0020a6a:	eb 0e                	jmp    c0020a7a <thread_tick+0x3b>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c0020a6c:	83 05 30 7b 03 c0 01 	addl   $0x1,0xc0037b30
c0020a73:	83 15 34 7b 03 c0 00 	adcl   $0x0,0xc0037b34

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0020a7a:	a1 28 7b 03 c0       	mov    0xc0037b28,%eax
c0020a7f:	83 c0 01             	add    $0x1,%eax
c0020a82:	a3 28 7b 03 c0       	mov    %eax,0xc0037b28
c0020a87:	83 f8 03             	cmp    $0x3,%eax
c0020a8a:	76 05                	jbe    c0020a91 <thread_tick+0x52>
    intr_yield_on_return ();
c0020a8c:	e8 46 0e 00 00       	call   c00218d7 <intr_yield_on_return>
  if(thread_mlfqs){
c0020a91:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0020a98:	0f 84 55 02 00 00    	je     c0020cf3 <thread_tick+0x2b4>
    struct thread * current_thread = thread_current();
c0020a9e:	e8 37 ff ff ff       	call   c00209da <thread_current>
c0020aa3:	89 44 24 24          	mov    %eax,0x24(%esp)
    if(current_thread != idle_thread){
c0020aa7:	3b 05 64 7b 03 c0    	cmp    0xc0037b64,%eax
c0020aad:	74 0b                	je     c0020aba <thread_tick+0x7b>
      current_thread->recent_cpu = Add_x_and_n(current_thread->recent_cpu,1);
c0020aaf:	81 40 44 00 40 00 00 	addl   $0x4000,0x44(%eax)
c0020ab6:	83 50 48 00          	adcl   $0x0,0x48(%eax)
    }
    if(ticks%4 == 0){
c0020aba:	f7 c5 03 00 00 00    	test   $0x3,%ebp
c0020ac0:	0f 85 0b 01 00 00    	jne    c0020bd1 <thread_tick+0x192>
      struct list_elem * e;
      for(e = list_begin(&all_list);e != list_end(&all_list);e = list_next(e)){
c0020ac6:	83 ec 0c             	sub    $0xc,%esp
c0020ac9:	68 78 7b 03 c0       	push   $0xc0037b78
c0020ace:	e8 e4 72 00 00       	call   c0027db7 <list_begin>
c0020ad3:	89 c3                	mov    %eax,%ebx
c0020ad5:	83 c4 10             	add    $0x10,%esp
c0020ad8:	e9 dc 00 00 00       	jmp    c0020bb9 <thread_tick+0x17a>
        struct thread *temp = list_entry(e,struct thread,allelem);
        //int temp_priority = Substract_n_from_x(Convert_n_to_fixed_point(PRI_MAX),Add_x_and_n(Divide_x_by_n(temp->recent_cpu,4),temp->nice*2));
        int temp_priority = Convert_x_to_integer_nearest(Substract_y_from_x(Convert_n_to_fixed_point(PRI_MAX), Add_x_and_n(Divide_x_by_n(temp->recent_cpu, 4), (temp->nice*2))));
c0020add:	8b 43 28             	mov    0x28(%ebx),%eax
c0020ae0:	c1 f8 1f             	sar    $0x1f,%eax
c0020ae3:	83 e0 03             	and    $0x3,%eax
c0020ae6:	89 44 24 08          	mov    %eax,0x8(%esp)
c0020aea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0020af1:	00 
c0020af2:	8b 74 24 08          	mov    0x8(%esp),%esi
c0020af6:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0020afa:	03 73 24             	add    0x24(%ebx),%esi
c0020afd:	13 7b 28             	adc    0x28(%ebx),%edi
c0020b00:	89 f0                	mov    %esi,%eax
c0020b02:	89 fa                	mov    %edi,%edx
c0020b04:	0f ac f8 02          	shrd   $0x2,%edi,%eax
c0020b08:	c1 fa 02             	sar    $0x2,%edx
c0020b0b:	8b 73 2c             	mov    0x2c(%ebx),%esi
c0020b0e:	c1 e6 0f             	shl    $0xf,%esi
c0020b11:	89 f7                	mov    %esi,%edi
c0020b13:	c1 ff 1f             	sar    $0x1f,%edi
c0020b16:	01 c6                	add    %eax,%esi
c0020b18:	11 d7                	adc    %edx,%edi
c0020b1a:	b8 00 c0 0f 00       	mov    $0xfc000,%eax
c0020b1f:	ba 00 00 00 00       	mov    $0x0,%edx
c0020b24:	29 f0                	sub    %esi,%eax
c0020b26:	19 fa                	sbb    %edi,%edx
c0020b28:	85 d2                	test   %edx,%edx
c0020b2a:	78 33                	js     c0020b5f <thread_tick+0x120>
c0020b2c:	b8 00 e0 0f 00       	mov    $0xfe000,%eax
c0020b31:	ba 00 00 00 00       	mov    $0x0,%edx
c0020b36:	29 f0                	sub    %esi,%eax
c0020b38:	19 fa                	sbb    %edi,%edx
c0020b3a:	89 d1                	mov    %edx,%ecx
c0020b3c:	c1 f9 1f             	sar    $0x1f,%ecx
c0020b3f:	81 e1 ff 3f 00 00    	and    $0x3fff,%ecx
c0020b45:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0020b49:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0020b50:	00 
c0020b51:	03 44 24 10          	add    0x10(%esp),%eax
c0020b55:	13 54 24 14          	adc    0x14(%esp),%edx
c0020b59:	0f ac d0 0e          	shrd   $0xe,%edx,%eax
c0020b5d:	eb 31                	jmp    c0020b90 <thread_tick+0x151>
c0020b5f:	b8 00 a0 0f 00       	mov    $0xfa000,%eax
c0020b64:	ba 00 00 00 00       	mov    $0x0,%edx
c0020b69:	29 f0                	sub    %esi,%eax
c0020b6b:	19 fa                	sbb    %edi,%edx
c0020b6d:	89 d1                	mov    %edx,%ecx
c0020b6f:	c1 f9 1f             	sar    $0x1f,%ecx
c0020b72:	81 e1 ff 3f 00 00    	and    $0x3fff,%ecx
c0020b78:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c0020b7c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0020b83:	00 
c0020b84:	03 44 24 18          	add    0x18(%esp),%eax
c0020b88:	13 54 24 1c          	adc    0x1c(%esp),%edx
c0020b8c:	0f ac d0 0e          	shrd   $0xe,%edx,%eax
        if(temp_priority < PRI_MIN){
c0020b90:	85 c0                	test   %eax,%eax
c0020b92:	79 09                	jns    c0020b9d <thread_tick+0x15e>
          temp->priority = PRI_MIN;
c0020b94:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
c0020b9b:	eb 0e                	jmp    c0020bab <thread_tick+0x16c>
        }else if(temp_priority > PRI_MAX){
          temp->priority = PRI_MAX;
c0020b9d:	83 f8 40             	cmp    $0x40,%eax
c0020ba0:	ba 3f 00 00 00       	mov    $0x3f,%edx
c0020ba5:	0f 4d c2             	cmovge %edx,%eax
c0020ba8:	89 43 fc             	mov    %eax,-0x4(%ebx)
    if(current_thread != idle_thread){
      current_thread->recent_cpu = Add_x_and_n(current_thread->recent_cpu,1);
    }
    if(ticks%4 == 0){
      struct list_elem * e;
      for(e = list_begin(&all_list);e != list_end(&all_list);e = list_next(e)){
c0020bab:	83 ec 0c             	sub    $0xc,%esp
c0020bae:	53                   	push   %ebx
c0020baf:	e8 33 72 00 00       	call   c0027de7 <list_next>
c0020bb4:	89 c3                	mov    %eax,%ebx
c0020bb6:	83 c4 10             	add    $0x10,%esp
c0020bb9:	83 ec 0c             	sub    $0xc,%esp
c0020bbc:	68 78 7b 03 c0       	push   $0xc0037b78
c0020bc1:	e8 67 72 00 00       	call   c0027e2d <list_end>
c0020bc6:	83 c4 10             	add    $0x10,%esp
c0020bc9:	39 c3                	cmp    %eax,%ebx
c0020bcb:	0f 85 0c ff ff ff    	jne    c0020add <thread_tick+0x9e>
        }else{
          temp->priority = temp_priority;
        }
      }
    }
    if(ticks%100 == 0){
c0020bd1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0020bd6:	89 e8                	mov    %ebp,%eax
c0020bd8:	f7 ea                	imul   %edx
c0020bda:	c1 fa 05             	sar    $0x5,%edx
c0020bdd:	89 e8                	mov    %ebp,%eax
c0020bdf:	c1 f8 1f             	sar    $0x1f,%eax
c0020be2:	29 c2                	sub    %eax,%edx
c0020be4:	6b d2 64             	imul   $0x64,%edx,%edx
c0020be7:	39 d5                	cmp    %edx,%ebp
c0020be9:	0f 85 04 01 00 00    	jne    c0020cf3 <thread_tick+0x2b4>
      int ready_threads =0;
      ready_threads += list_size(&ready_list);
c0020bef:	83 ec 0c             	sub    $0xc,%esp
c0020bf2:	68 88 7b 03 c0       	push   $0xc0037b88
c0020bf7:	e8 83 76 00 00       	call   c002827f <list_size>
c0020bfc:	89 c1                	mov    %eax,%ecx
      if(current_thread != idle_thread)
c0020bfe:	83 c4 10             	add    $0x10,%esp
        ready_threads++;
c0020c01:	8b 44 24 24          	mov    0x24(%esp),%eax
c0020c05:	3b 05 64 7b 03 c0    	cmp    0xc0037b64,%eax
c0020c0b:	0f 95 c0             	setne  %al
c0020c0e:	0f b6 c0             	movzbl %al,%eax
c0020c11:	01 c1                	add    %eax,%ecx
      load_avg = Divide_x_by_n(Add_x_and_n(Multiply_x_by_n(load_avg, 59),ready_threads), 60);
c0020c13:	6b 1d 24 7b 03 c0 3b 	imul   $0x3b,0xc0037b24,%ebx
c0020c1a:	bf 3b 00 00 00       	mov    $0x3b,%edi
c0020c1f:	89 f8                	mov    %edi,%eax
c0020c21:	f7 25 20 7b 03 c0    	mull   0xc0037b20
c0020c27:	89 c6                	mov    %eax,%esi
c0020c29:	89 d7                	mov    %edx,%edi
c0020c2b:	01 df                	add    %ebx,%edi
c0020c2d:	89 c8                	mov    %ecx,%eax
c0020c2f:	c1 e0 0e             	shl    $0xe,%eax
c0020c32:	99                   	cltd   
c0020c33:	01 f0                	add    %esi,%eax
c0020c35:	11 fa                	adc    %edi,%edx
c0020c37:	6a 00                	push   $0x0
c0020c39:	6a 3c                	push   $0x3c
c0020c3b:	52                   	push   %edx
c0020c3c:	50                   	push   %eax
c0020c3d:	e8 bf 6a 00 00       	call   c0027701 <__divdi3>
c0020c42:	a3 20 7b 03 c0       	mov    %eax,0xc0037b20
c0020c47:	89 15 24 7b 03 c0    	mov    %edx,0xc0037b24
      struct list_elem * e;
      for(e = list_begin(&all_list);e != list_end(&all_list);e = list_next(e)){
c0020c4d:	c7 04 24 78 7b 03 c0 	movl   $0xc0037b78,(%esp)
c0020c54:	e8 5e 71 00 00       	call   c0027db7 <list_begin>
c0020c59:	89 c6                	mov    %eax,%esi
c0020c5b:	83 c4 10             	add    $0x10,%esp
c0020c5e:	eb 7b                	jmp    c0020cdb <thread_tick+0x29c>
        struct thread *temp = list_entry(e,struct thread,allelem);
        //temp->recent_cpu = Add_x_and_y(Multiply_x_by_y(Divide_x_by_y(Multiply_x_by_n(load_avg,2),Add_x_and_y(Multiply_x_by_n(load_avg,2),1)),temp->recent_cpu),temp->nice);
        temp->recent_cpu = Add_x_and_n(Multiply_x_by_y(Divide_x_by_y(Multiply_x_by_n(load_avg, 2), Add_x_and_n(Multiply_x_by_n(load_avg, 2), 1)), temp->recent_cpu), temp->nice);
c0020c60:	a1 20 7b 03 c0       	mov    0xc0037b20,%eax
c0020c65:	8b 15 24 7b 03 c0    	mov    0xc0037b24,%edx
c0020c6b:	89 c1                	mov    %eax,%ecx
c0020c6d:	89 d3                	mov    %edx,%ebx
c0020c6f:	0f a4 c3 0f          	shld   $0xf,%eax,%ebx
c0020c73:	c1 e1 0f             	shl    $0xf,%ecx
c0020c76:	05 00 20 00 00       	add    $0x2000,%eax
c0020c7b:	83 d2 00             	adc    $0x0,%edx
c0020c7e:	0f a4 c2 01          	shld   $0x1,%eax,%edx
c0020c82:	01 c0                	add    %eax,%eax
c0020c84:	52                   	push   %edx
c0020c85:	50                   	push   %eax
c0020c86:	53                   	push   %ebx
c0020c87:	51                   	push   %ecx
c0020c88:	e8 74 6a 00 00       	call   c0027701 <__divdi3>
c0020c8d:	0f af 56 24          	imul   0x24(%esi),%edx
c0020c91:	89 c1                	mov    %eax,%ecx
c0020c93:	0f af 4e 28          	imul   0x28(%esi),%ecx
c0020c97:	01 d1                	add    %edx,%ecx
c0020c99:	f7 66 24             	mull   0x24(%esi)
c0020c9c:	01 ca                	add    %ecx,%edx
c0020c9e:	89 d1                	mov    %edx,%ecx
c0020ca0:	c1 f9 1f             	sar    $0x1f,%ecx
c0020ca3:	81 e1 ff 3f 00 00    	and    $0x3fff,%ecx
c0020ca9:	bd 00 00 00 00       	mov    $0x0,%ebp
c0020cae:	01 c8                	add    %ecx,%eax
c0020cb0:	11 ea                	adc    %ebp,%edx
c0020cb2:	0f ac d0 0e          	shrd   $0xe,%edx,%eax
c0020cb6:	c1 fa 0e             	sar    $0xe,%edx
c0020cb9:	8b 4e 2c             	mov    0x2c(%esi),%ecx
c0020cbc:	c1 e1 0e             	shl    $0xe,%ecx
c0020cbf:	89 cb                	mov    %ecx,%ebx
c0020cc1:	c1 fb 1f             	sar    $0x1f,%ebx
c0020cc4:	01 c8                	add    %ecx,%eax
c0020cc6:	11 da                	adc    %ebx,%edx
c0020cc8:	89 46 24             	mov    %eax,0x24(%esi)
c0020ccb:	89 56 28             	mov    %edx,0x28(%esi)
      ready_threads += list_size(&ready_list);
      if(current_thread != idle_thread)
        ready_threads++;
      load_avg = Divide_x_by_n(Add_x_and_n(Multiply_x_by_n(load_avg, 59),ready_threads), 60);
      struct list_elem * e;
      for(e = list_begin(&all_list);e != list_end(&all_list);e = list_next(e)){
c0020cce:	89 34 24             	mov    %esi,(%esp)
c0020cd1:	e8 11 71 00 00       	call   c0027de7 <list_next>
c0020cd6:	89 c6                	mov    %eax,%esi
c0020cd8:	83 c4 10             	add    $0x10,%esp
c0020cdb:	83 ec 0c             	sub    $0xc,%esp
c0020cde:	68 78 7b 03 c0       	push   $0xc0037b78
c0020ce3:	e8 45 71 00 00       	call   c0027e2d <list_end>
c0020ce8:	83 c4 10             	add    $0x10,%esp
c0020ceb:	39 c6                	cmp    %eax,%esi
c0020ced:	0f 85 6d ff ff ff    	jne    c0020c60 <thread_tick+0x221>
        //temp->recent_cpu = Add_x_and_y(Multiply_x_by_y(Divide_x_by_y(Multiply_x_by_n(load_avg,2),Add_x_and_y(Multiply_x_by_n(load_avg,2),1)),temp->recent_cpu),temp->nice);
        temp->recent_cpu = Add_x_and_n(Multiply_x_by_y(Divide_x_by_y(Multiply_x_by_n(load_avg, 2), Add_x_and_n(Multiply_x_by_n(load_avg, 2), 1)), temp->recent_cpu), temp->nice);
      }
    }
  }
}
c0020cf3:	83 c4 3c             	add    $0x3c,%esp
c0020cf6:	5b                   	pop    %ebx
c0020cf7:	5e                   	pop    %esi
c0020cf8:	5f                   	pop    %edi
c0020cf9:	5d                   	pop    %ebp
c0020cfa:	c3                   	ret    

c0020cfb <thread_name>:
}

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020cfb:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->name;
c0020cfe:	e8 d7 fc ff ff       	call   c00209da <thread_current>
c0020d03:	83 c0 08             	add    $0x8,%eax
}
c0020d06:	83 c4 0c             	add    $0xc,%esp
c0020d09:	c3                   	ret    

c0020d0a <thread_tid>:
}

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020d0a:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->tid;
c0020d0d:	e8 c8 fc ff ff       	call   c00209da <thread_current>
c0020d12:	8b 00                	mov    (%eax),%eax
}
c0020d14:	83 c4 0c             	add    $0xc,%esp
c0020d17:	c3                   	ret    

c0020d18 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020d18:	57                   	push   %edi
c0020d19:	56                   	push   %esi
c0020d1a:	53                   	push   %ebx
c0020d1b:	8b 74 24 10          	mov    0x10(%esp),%esi
c0020d1f:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020d23:	e8 2b 09 00 00       	call   c0021653 <intr_get_level>
c0020d28:	85 c0                	test   %eax,%eax
c0020d2a:	74 21                	je     c0020d4d <thread_foreach+0x35>
c0020d2c:	83 ec 0c             	sub    $0xc,%esp
c0020d2f:	68 94 d5 02 c0       	push   $0xc002d594
c0020d34:	68 3f d2 02 c0       	push   $0xc002d23f
c0020d39:	68 34 bb 02 c0       	push   $0xc002bb34
c0020d3e:	68 67 01 00 00       	push   $0x167
c0020d43:	68 62 d5 02 c0       	push   $0xc002d562
c0020d48:	e8 80 6f 00 00       	call   c0027ccd <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020d4d:	83 ec 0c             	sub    $0xc,%esp
c0020d50:	68 78 7b 03 c0       	push   $0xc0037b78
c0020d55:	e8 5d 70 00 00       	call   c0027db7 <list_begin>
c0020d5a:	89 c3                	mov    %eax,%ebx
c0020d5c:	83 c4 10             	add    $0x10,%esp
c0020d5f:	eb 17                	jmp    c0020d78 <thread_foreach+0x60>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
      func (t, aux);
c0020d61:	83 ec 08             	sub    $0x8,%esp
c0020d64:	57                   	push   %edi
  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020d65:	8d 43 e0             	lea    -0x20(%ebx),%eax
      func (t, aux);
c0020d68:	50                   	push   %eax
c0020d69:	ff d6                	call   *%esi
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
       e = list_next (e))
c0020d6b:	89 1c 24             	mov    %ebx,(%esp)
c0020d6e:	e8 74 70 00 00       	call   c0027de7 <list_next>
c0020d73:	89 c3                	mov    %eax,%ebx
c0020d75:	83 c4 10             	add    $0x10,%esp
{
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020d78:	83 ec 0c             	sub    $0xc,%esp
c0020d7b:	68 78 7b 03 c0       	push   $0xc0037b78
c0020d80:	e8 a8 70 00 00       	call   c0027e2d <list_end>
c0020d85:	83 c4 10             	add    $0x10,%esp
c0020d88:	39 c3                	cmp    %eax,%ebx
c0020d8a:	75 d5                	jne    c0020d61 <thread_foreach+0x49>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
      func (t, aux);
    }
}
c0020d8c:	5b                   	pop    %ebx
c0020d8d:	5e                   	pop    %esi
c0020d8e:	5f                   	pop    %edi
c0020d8f:	c3                   	ret    

c0020d90 <thread_get_priority>:
}

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020d90:	83 ec 0c             	sub    $0xc,%esp
  return thread_current ()->priority;
c0020d93:	e8 42 fc ff ff       	call   c00209da <thread_current>
c0020d98:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020d9b:	83 c4 0c             	add    $0xc,%esp
c0020d9e:	c3                   	ret    

c0020d9f <thread_get_nice>:
}

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020d9f:	83 ec 0c             	sub    $0xc,%esp
  /* Not yet implemented. */
  return thread_current()->nice;
c0020da2:	e8 33 fc ff ff       	call   c00209da <thread_current>
c0020da7:	8b 40 4c             	mov    0x4c(%eax),%eax
}
c0020daa:	83 c4 0c             	add    $0xc,%esp
c0020dad:	c3                   	ret    

c0020dae <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020dae:	56                   	push   %esi
c0020daf:	53                   	push   %ebx
  /* Not yet implemented. */
  return Convert_x_to_integer_nearest(Multiply_x_by_n(load_avg,100));
c0020db0:	6b 35 24 7b 03 c0 64 	imul   $0x64,0xc0037b24,%esi
c0020db7:	b8 64 00 00 00       	mov    $0x64,%eax
c0020dbc:	f7 25 20 7b 03 c0    	mull   0xc0037b20
c0020dc2:	01 f2                	add    %esi,%edx
c0020dc4:	85 d2                	test   %edx,%edx
c0020dc6:	78 28                	js     c0020df0 <thread_get_load_avg+0x42>
c0020dc8:	05 00 20 00 00       	add    $0x2000,%eax
c0020dcd:	83 d2 00             	adc    $0x0,%edx
c0020dd0:	89 c1                	mov    %eax,%ecx
c0020dd2:	89 d3                	mov    %edx,%ebx
c0020dd4:	89 d6                	mov    %edx,%esi
c0020dd6:	c1 fe 1f             	sar    $0x1f,%esi
c0020dd9:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c0020ddf:	ba 00 00 00 00       	mov    $0x0,%edx
c0020de4:	01 f1                	add    %esi,%ecx
c0020de6:	11 d3                	adc    %edx,%ebx
c0020de8:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
c0020dec:	89 c8                	mov    %ecx,%eax
c0020dee:	eb 26                	jmp    c0020e16 <thread_get_load_avg+0x68>
c0020df0:	05 00 e0 ff ff       	add    $0xffffe000,%eax
c0020df5:	83 d2 ff             	adc    $0xffffffff,%edx
c0020df8:	89 c1                	mov    %eax,%ecx
c0020dfa:	89 d3                	mov    %edx,%ebx
c0020dfc:	89 d6                	mov    %edx,%esi
c0020dfe:	c1 fe 1f             	sar    $0x1f,%esi
c0020e01:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c0020e07:	ba 00 00 00 00       	mov    $0x0,%edx
c0020e0c:	01 f1                	add    %esi,%ecx
c0020e0e:	11 d3                	adc    %edx,%ebx
c0020e10:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
c0020e14:	89 c8                	mov    %ecx,%eax
}
c0020e16:	5b                   	pop    %ebx
c0020e17:	5e                   	pop    %esi
c0020e18:	c3                   	ret    

c0020e19 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020e19:	56                   	push   %esi
c0020e1a:	53                   	push   %ebx
c0020e1b:	83 ec 04             	sub    $0x4,%esp
  /* Not yet implemented. */
  return Convert_x_to_integer_nearest(Multiply_x_by_n(thread_current()->recent_cpu,100));
c0020e1e:	e8 b7 fb ff ff       	call   c00209da <thread_current>
c0020e23:	89 c3                	mov    %eax,%ebx
c0020e25:	6b 70 48 64          	imul   $0x64,0x48(%eax),%esi
c0020e29:	b9 64 00 00 00       	mov    $0x64,%ecx
c0020e2e:	89 c8                	mov    %ecx,%eax
c0020e30:	f7 63 44             	mull   0x44(%ebx)
c0020e33:	01 f2                	add    %esi,%edx
c0020e35:	85 d2                	test   %edx,%edx
c0020e37:	78 28                	js     c0020e61 <thread_get_recent_cpu+0x48>
c0020e39:	05 00 20 00 00       	add    $0x2000,%eax
c0020e3e:	83 d2 00             	adc    $0x0,%edx
c0020e41:	89 c1                	mov    %eax,%ecx
c0020e43:	89 d3                	mov    %edx,%ebx
c0020e45:	89 d6                	mov    %edx,%esi
c0020e47:	c1 fe 1f             	sar    $0x1f,%esi
c0020e4a:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c0020e50:	ba 00 00 00 00       	mov    $0x0,%edx
c0020e55:	01 f1                	add    %esi,%ecx
c0020e57:	11 d3                	adc    %edx,%ebx
c0020e59:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
c0020e5d:	89 c8                	mov    %ecx,%eax
c0020e5f:	eb 26                	jmp    c0020e87 <thread_get_recent_cpu+0x6e>
c0020e61:	05 00 e0 ff ff       	add    $0xffffe000,%eax
c0020e66:	83 d2 ff             	adc    $0xffffffff,%edx
c0020e69:	89 c1                	mov    %eax,%ecx
c0020e6b:	89 d3                	mov    %edx,%ebx
c0020e6d:	89 d6                	mov    %edx,%esi
c0020e6f:	c1 fe 1f             	sar    $0x1f,%esi
c0020e72:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c0020e78:	ba 00 00 00 00       	mov    $0x0,%edx
c0020e7d:	01 f1                	add    %esi,%ecx
c0020e7f:	11 d3                	adc    %edx,%ebx
c0020e81:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
c0020e85:	89 c8                	mov    %ecx,%eax
}
c0020e87:	83 c4 04             	add    $0x4,%esp
c0020e8a:	5b                   	pop    %ebx
c0020e8b:	5e                   	pop    %esi
c0020e8c:	c3                   	ret    

c0020e8d <thread_schedule_tail>:
   added at the end of the function.
   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0020e8d:	56                   	push   %esi
c0020e8e:	53                   	push   %ebx
c0020e8f:	83 ec 04             	sub    $0x4,%esp
c0020e92:	8b 74 24 10          	mov    0x10(%esp),%esi

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0020e96:	89 e3                	mov    %esp,%ebx
c0020e98:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
void
thread_schedule_tail (struct thread *prev)
{
  struct thread *cur = running_thread ();
  
  ASSERT (intr_get_level () == INTR_OFF);
c0020e9e:	e8 b0 07 00 00       	call   c0021653 <intr_get_level>
c0020ea3:	85 c0                	test   %eax,%eax
c0020ea5:	74 21                	je     c0020ec8 <thread_schedule_tail+0x3b>
c0020ea7:	83 ec 0c             	sub    $0xc,%esp
c0020eaa:	68 94 d5 02 c0       	push   $0xc002d594
c0020eaf:	68 3f d2 02 c0       	push   $0xc002d23f
c0020eb4:	68 1c bb 02 c0       	push   $0xc002bb1c
c0020eb9:	68 40 02 00 00       	push   $0x240
c0020ebe:	68 62 d5 02 c0       	push   $0xc002d562
c0020ec3:	e8 05 6e 00 00       	call   c0027ccd <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0020ec8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)

  /* Start new time slice. */
  thread_ticks = 0;
c0020ecf:	c7 05 28 7b 03 c0 00 	movl   $0x0,0xc0037b28
c0020ed6:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0020ed9:	85 f6                	test   %esi,%esi
c0020edb:	74 3f                	je     c0020f1c <thread_schedule_tail+0x8f>
c0020edd:	83 7e 04 03          	cmpl   $0x3,0x4(%esi)
c0020ee1:	75 39                	jne    c0020f1c <thread_schedule_tail+0x8f>
c0020ee3:	3b 35 60 7b 03 c0    	cmp    0xc0037b60,%esi
c0020ee9:	74 31                	je     c0020f1c <thread_schedule_tail+0x8f>
    {
      ASSERT (prev != cur);
c0020eeb:	39 de                	cmp    %ebx,%esi
c0020eed:	75 21                	jne    c0020f10 <thread_schedule_tail+0x83>
c0020eef:	83 ec 0c             	sub    $0xc,%esp
c0020ef2:	68 ef d5 02 c0       	push   $0xc002d5ef
c0020ef7:	68 3f d2 02 c0       	push   $0xc002d23f
c0020efc:	68 1c bb 02 c0       	push   $0xc002bb1c
c0020f01:	68 54 02 00 00       	push   $0x254
c0020f06:	68 62 d5 02 c0       	push   $0xc002d562
c0020f0b:	e8 bd 6d 00 00       	call   c0027ccd <debug_panic>
      palloc_free_page (prev);
c0020f10:	83 ec 0c             	sub    $0xc,%esp
c0020f13:	56                   	push   %esi
c0020f14:	e8 23 23 00 00       	call   c002323c <palloc_free_page>
c0020f19:	83 c4 10             	add    $0x10,%esp
    }
}
c0020f1c:	83 c4 04             	add    $0x4,%esp
c0020f1f:	5b                   	pop    %ebx
c0020f20:	5e                   	pop    %esi
c0020f21:	c3                   	ret    

c0020f22 <schedule>:
   thread to run and switches to it.
   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c0020f22:	56                   	push   %esi
c0020f23:	53                   	push   %ebx
c0020f24:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0020f27:	89 e3                	mov    %esp,%ebx
c0020f29:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
  if (list_empty (&ready_list))
c0020f2f:	68 88 7b 03 c0       	push   $0xc0037b88
c0020f34:	e8 89 73 00 00       	call   c00282c2 <list_empty>
c0020f39:	83 c4 10             	add    $0x10,%esp
    return idle_thread;
c0020f3c:	8b 35 64 7b 03 c0    	mov    0xc0037b64,%esi
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
  if (list_empty (&ready_list))
c0020f42:	84 c0                	test   %al,%al
c0020f44:	75 13                	jne    c0020f59 <schedule+0x37>
    return idle_thread;
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0020f46:	83 ec 0c             	sub    $0xc,%esp
c0020f49:	68 88 7b 03 c0       	push   $0xc0037b88
c0020f4e:	e8 d1 73 00 00       	call   c0028324 <list_pop_front>
c0020f53:	8d 70 b0             	lea    -0x50(%eax),%esi
c0020f56:	83 c4 10             	add    $0x10,%esp
{
  struct thread *cur = running_thread ();
  struct thread *next = next_thread_to_run ();
  struct thread *prev = NULL;

  ASSERT (intr_get_level () == INTR_OFF);
c0020f59:	e8 f5 06 00 00       	call   c0021653 <intr_get_level>
c0020f5e:	85 c0                	test   %eax,%eax
c0020f60:	74 21                	je     c0020f83 <schedule+0x61>
c0020f62:	83 ec 0c             	sub    $0xc,%esp
c0020f65:	68 94 d5 02 c0       	push   $0xc002d594
c0020f6a:	68 3f d2 02 c0       	push   $0xc002d23f
c0020f6f:	68 80 bb 02 c0       	push   $0xc002bb80
c0020f74:	68 66 02 00 00       	push   $0x266
c0020f79:	68 62 d5 02 c0       	push   $0xc002d562
c0020f7e:	e8 4a 6d 00 00       	call   c0027ccd <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0020f83:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0020f87:	75 21                	jne    c0020faa <schedule+0x88>
c0020f89:	83 ec 0c             	sub    $0xc,%esp
c0020f8c:	68 fb d5 02 c0       	push   $0xc002d5fb
c0020f91:	68 3f d2 02 c0       	push   $0xc002d23f
c0020f96:	68 80 bb 02 c0       	push   $0xc002bb80
c0020f9b:	68 67 02 00 00       	push   $0x267
c0020fa0:	68 62 d5 02 c0       	push   $0xc002d562
c0020fa5:	e8 23 6d 00 00       	call   c0027ccd <debug_panic>

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
  return t != NULL && t->magic == THREAD_MAGIC;
c0020faa:	85 f6                	test   %esi,%esi
c0020fac:	74 31                	je     c0020fdf <schedule+0xbd>
c0020fae:	81 7e 58 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x58(%esi)
c0020fb5:	75 28                	jne    c0020fdf <schedule+0xbd>
c0020fb7:	eb 1b                	jmp    c0020fd4 <schedule+0xb2>
  ASSERT (intr_get_level () == INTR_OFF);
  ASSERT (cur->status != THREAD_RUNNING);
  ASSERT (is_thread (next));

  if (cur != next)
    prev = switch_threads (cur, next);
c0020fb9:	83 ec 08             	sub    $0x8,%esp
c0020fbc:	56                   	push   %esi
c0020fbd:	53                   	push   %ebx
c0020fbe:	e8 41 05 00 00       	call   c0021504 <switch_threads>
c0020fc3:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail (prev);
c0020fc6:	83 ec 0c             	sub    $0xc,%esp
c0020fc9:	50                   	push   %eax
c0020fca:	e8 be fe ff ff       	call   c0020e8d <thread_schedule_tail>
}
c0020fcf:	83 c4 10             	add    $0x10,%esp
c0020fd2:	eb 2c                	jmp    c0021000 <schedule+0xde>
static void
schedule (void) 
{
  struct thread *cur = running_thread ();
  struct thread *next = next_thread_to_run ();
  struct thread *prev = NULL;
c0020fd4:	b8 00 00 00 00       	mov    $0x0,%eax

  ASSERT (intr_get_level () == INTR_OFF);
  ASSERT (cur->status != THREAD_RUNNING);
  ASSERT (is_thread (next));

  if (cur != next)
c0020fd9:	39 de                	cmp    %ebx,%esi
c0020fdb:	74 e9                	je     c0020fc6 <schedule+0xa4>
c0020fdd:	eb da                	jmp    c0020fb9 <schedule+0x97>
  struct thread *next = next_thread_to_run ();
  struct thread *prev = NULL;

  ASSERT (intr_get_level () == INTR_OFF);
  ASSERT (cur->status != THREAD_RUNNING);
  ASSERT (is_thread (next));
c0020fdf:	83 ec 0c             	sub    $0xc,%esp
c0020fe2:	68 19 d6 02 c0       	push   $0xc002d619
c0020fe7:	68 3f d2 02 c0       	push   $0xc002d23f
c0020fec:	68 80 bb 02 c0       	push   $0xc002bb80
c0020ff1:	68 68 02 00 00       	push   $0x268
c0020ff6:	68 62 d5 02 c0       	push   $0xc002d562
c0020ffb:	e8 cd 6c 00 00       	call   c0027ccd <debug_panic>

  if (cur != next)
    prev = switch_threads (cur, next);
  thread_schedule_tail (prev);
}
c0021000:	83 c4 04             	add    $0x4,%esp
c0021003:	5b                   	pop    %ebx
c0021004:	5e                   	pop    %esi
c0021005:	c3                   	ret    

c0021006 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0021006:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c0021009:	e8 c1 08 00 00       	call   c00218cf <intr_context>
c002100e:	84 c0                	test   %al,%al
c0021010:	74 21                	je     c0021033 <thread_block+0x2d>
c0021012:	83 ec 0c             	sub    $0xc,%esp
c0021015:	68 2a d6 02 c0       	push   $0xc002d62a
c002101a:	68 3f d2 02 c0       	push   $0xc002d23f
c002101f:	68 8c bb 02 c0       	push   $0xc002bb8c
c0021024:	68 fa 00 00 00       	push   $0xfa
c0021029:	68 62 d5 02 c0       	push   $0xc002d562
c002102e:	e8 9a 6c 00 00       	call   c0027ccd <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0021033:	e8 1b 06 00 00       	call   c0021653 <intr_get_level>
c0021038:	85 c0                	test   %eax,%eax
c002103a:	74 21                	je     c002105d <thread_block+0x57>
c002103c:	83 ec 0c             	sub    $0xc,%esp
c002103f:	68 94 d5 02 c0       	push   $0xc002d594
c0021044:	68 3f d2 02 c0       	push   $0xc002d23f
c0021049:	68 8c bb 02 c0       	push   $0xc002bb8c
c002104e:	68 fb 00 00 00       	push   $0xfb
c0021053:	68 62 d5 02 c0       	push   $0xc002d562
c0021058:	e8 70 6c 00 00       	call   c0027ccd <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c002105d:	e8 78 f9 ff ff       	call   c00209da <thread_current>
c0021062:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0021069:	e8 b4 fe ff ff       	call   c0020f22 <schedule>
}
c002106e:	83 c4 0c             	add    $0xc,%esp
c0021071:	c3                   	ret    

c0021072 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0021072:	83 ec 0c             	sub    $0xc,%esp
  struct semaphore *idle_started = idle_started_;
  idle_thread = thread_current ();
c0021075:	e8 60 f9 ff ff       	call   c00209da <thread_current>
c002107a:	a3 64 7b 03 c0       	mov    %eax,0xc0037b64
  sema_up (idle_started);
c002107f:	83 ec 0c             	sub    $0xc,%esp
c0021082:	ff 74 24 1c          	pushl  0x1c(%esp)
c0021086:	e8 86 17 00 00       	call   c0022811 <sema_up>
c002108b:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c002108e:	e8 fd 05 00 00       	call   c0021690 <intr_disable>
      thread_block ();
c0021093:	e8 6e ff ff ff       	call   c0021006 <thread_block>
         between re-enabling interrupts and waiting for the next
         one to occur, wasting as much as one clock tick worth of
         time.
         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0021098:	fb                   	sti    
c0021099:	f4                   	hlt    
c002109a:	eb f2                	jmp    c002108e <idle+0x1c>

c002109c <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c002109c:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (!intr_context ());
c002109f:	e8 2b 08 00 00       	call   c00218cf <intr_context>
c00210a4:	84 c0                	test   %al,%al
c00210a6:	74 21                	je     c00210c9 <thread_exit+0x2d>
c00210a8:	83 ec 0c             	sub    $0xc,%esp
c00210ab:	68 2a d6 02 c0       	push   $0xc002d62a
c00210b0:	68 3f d2 02 c0       	push   $0xc002d23f
c00210b5:	68 54 bb 02 c0       	push   $0xc002bb54
c00210ba:	68 3d 01 00 00       	push   $0x13d
c00210bf:	68 62 d5 02 c0       	push   $0xc002d562
c00210c4:	e8 04 6c 00 00       	call   c0027ccd <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c00210c9:	e8 c2 05 00 00       	call   c0021690 <intr_disable>
  list_remove (&thread_current()->allelem);
c00210ce:	e8 07 f9 ff ff       	call   c00209da <thread_current>
c00210d3:	83 ec 0c             	sub    $0xc,%esp
c00210d6:	83 c0 20             	add    $0x20,%eax
c00210d9:	50                   	push   %eax
c00210da:	e8 56 71 00 00       	call   c0028235 <list_remove>
  thread_current ()->status = THREAD_DYING;
c00210df:	e8 f6 f8 ff ff       	call   c00209da <thread_current>
c00210e4:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c00210eb:	e8 32 fe ff ff       	call   c0020f22 <schedule>
  NOT_REACHED ();
c00210f0:	68 c0 d6 02 c0       	push   $0xc002d6c0
c00210f5:	68 54 bb 02 c0       	push   $0xc002bb54
c00210fa:	68 4a 01 00 00       	push   $0x14a
c00210ff:	68 62 d5 02 c0       	push   $0xc002d562
c0021104:	e8 c4 6b 00 00       	call   c0027ccd <debug_panic>

c0021109 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0021109:	53                   	push   %ebx
c002110a:	83 ec 08             	sub    $0x8,%esp
c002110d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (function != NULL);
c0021111:	85 db                	test   %ebx,%ebx
c0021113:	75 21                	jne    c0021136 <kernel_thread+0x2d>
c0021115:	83 ec 0c             	sub    $0xc,%esp
c0021118:	68 3b d6 02 c0       	push   $0xc002d63b
c002111d:	68 3f d2 02 c0       	push   $0xc002d23f
c0021122:	68 a8 bb 02 c0       	push   $0xc002bba8
c0021127:	68 da 01 00 00       	push   $0x1da
c002112c:	68 62 d5 02 c0       	push   $0xc002d562
c0021131:	e8 97 6b 00 00       	call   c0027ccd <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021136:	e8 21 05 00 00       	call   c002165c <intr_enable>
  function (aux);       /* Execute the thread function. */
c002113b:	83 ec 0c             	sub    $0xc,%esp
c002113e:	ff 74 24 20          	pushl  0x20(%esp)
c0021142:	ff d3                	call   *%ebx
  thread_exit ();       /* If function() returns, kill the thread. */
c0021144:	e8 53 ff ff ff       	call   c002109c <thread_exit>

c0021149 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0021149:	56                   	push   %esi
c002114a:	53                   	push   %ebx
c002114b:	83 ec 04             	sub    $0x4,%esp
  struct thread *cur = thread_current ();
c002114e:	e8 87 f8 ff ff       	call   c00209da <thread_current>
c0021153:	89 c3                	mov    %eax,%ebx
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0021155:	e8 75 07 00 00       	call   c00218cf <intr_context>
c002115a:	84 c0                	test   %al,%al
c002115c:	74 21                	je     c002117f <thread_yield+0x36>
c002115e:	83 ec 0c             	sub    $0xc,%esp
c0021161:	68 2a d6 02 c0       	push   $0xc002d62a
c0021166:	68 3f d2 02 c0       	push   $0xc002d23f
c002116b:	68 44 bb 02 c0       	push   $0xc002bb44
c0021170:	68 55 01 00 00       	push   $0x155
c0021175:	68 62 d5 02 c0       	push   $0xc002d562
c002117a:	e8 4e 6b 00 00       	call   c0027ccd <debug_panic>

  old_level = intr_disable ();
c002117f:	e8 0c 05 00 00       	call   c0021690 <intr_disable>
c0021184:	89 c6                	mov    %eax,%esi
  if (cur != idle_thread) 
c0021186:	3b 1d 64 7b 03 c0    	cmp    0xc0037b64,%ebx
c002118c:	74 18                	je     c00211a6 <thread_yield+0x5d>
    //list_push_back (&ready_list, &cur->elem);
    list_insert_ordered(&ready_list,&cur->elem,(list_less_func *) &thread_cmp_priority,NULL);
c002118e:	6a 00                	push   $0x0
c0021190:	68 b5 06 02 c0       	push   $0xc00206b5
c0021195:	8d 43 50             	lea    0x50(%ebx),%eax
c0021198:	50                   	push   %eax
c0021199:	68 88 7b 03 c0       	push   $0xc0037b88
c002119e:	e8 be 74 00 00       	call   c0028661 <list_insert_ordered>
c00211a3:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c00211a6:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
  schedule ();
c00211ad:	e8 70 fd ff ff       	call   c0020f22 <schedule>
  intr_set_level (old_level);
c00211b2:	83 ec 0c             	sub    $0xc,%esp
c00211b5:	56                   	push   %esi
c00211b6:	e8 dc 04 00 00       	call   c0021697 <intr_set_level>
}
c00211bb:	83 c4 14             	add    $0x14,%esp
c00211be:	5b                   	pop    %ebx
c00211bf:	5e                   	pop    %esi
c00211c0:	c3                   	ret    

c00211c1 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c00211c1:	55                   	push   %ebp
c00211c2:	57                   	push   %edi
c00211c3:	56                   	push   %esi
c00211c4:	53                   	push   %ebx
c00211c5:	83 ec 0c             	sub    $0xc,%esp
c00211c8:	8b 7c 24 28          	mov    0x28(%esp),%edi
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;
  enum intr_level old_level;
  ASSERT (function != NULL);
c00211cc:	85 ff                	test   %edi,%edi
c00211ce:	75 21                	jne    c00211f1 <thread_create+0x30>
c00211d0:	83 ec 0c             	sub    $0xc,%esp
c00211d3:	68 3b d6 02 c0       	push   $0xc002d63b
c00211d8:	68 3f d2 02 c0       	push   $0xc002d23f
c00211dd:	68 b8 bb 02 c0       	push   $0xc002bbb8
c00211e2:	68 d0 00 00 00       	push   $0xd0
c00211e7:	68 62 d5 02 c0       	push   $0xc002d562
c00211ec:	e8 dc 6a 00 00       	call   c0027ccd <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c00211f1:	83 ec 0c             	sub    $0xc,%esp
c00211f4:	6a 02                	push   $0x2
c00211f6:	e8 0b 1f 00 00       	call   c0023106 <palloc_get_page>
c00211fb:	89 c3                	mov    %eax,%ebx
  if (t == NULL)
c00211fd:	83 c4 10             	add    $0x10,%esp
c0021200:	85 c0                	test   %eax,%eax
c0021202:	0f 84 a6 00 00 00    	je     c00212ae <thread_create+0xed>
    return TID_ERROR;

  /* Initialize thread. */
  init_thread (t, name, priority);
c0021208:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002120c:	8b 54 24 20          	mov    0x20(%esp),%edx
c0021210:	e8 33 f5 ff ff       	call   c0020748 <init_thread>
allocate_tid (void) 
{
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0021215:	83 ec 0c             	sub    $0xc,%esp
c0021218:	68 40 7b 03 c0       	push   $0xc0037b40
c002121d:	e8 9d 17 00 00       	call   c00229bf <lock_acquire>
  tid = next_tid++;
c0021222:	8b 35 b8 75 03 c0    	mov    0xc00375b8,%esi
c0021228:	8d 46 01             	lea    0x1(%esi),%eax
c002122b:	a3 b8 75 03 c0       	mov    %eax,0xc00375b8
  lock_release (&tid_lock);
c0021230:	c7 04 24 40 7b 03 c0 	movl   $0xc0037b40,(%esp)
c0021237:	e8 13 19 00 00       	call   c0022b4f <lock_release>
  if (t == NULL)
    return TID_ERROR;

  /* Initialize thread. */
  init_thread (t, name, priority);
  tid = t->tid = allocate_tid ();
c002123c:	89 33                	mov    %esi,(%ebx)
  t->tickstowake = 0;
c002123e:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  old_level = intr_disable();
c0021245:	e8 46 04 00 00       	call   c0021690 <intr_disable>
c002124a:	89 c5                	mov    %eax,%ebp
  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c002124c:	ba 0c 00 00 00       	mov    $0xc,%edx
c0021251:	89 d8                	mov    %ebx,%eax
c0021253:	e8 87 f4 ff ff       	call   c00206df <alloc_frame>
  kf->eip = NULL;
c0021258:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c002125e:	89 78 04             	mov    %edi,0x4(%eax)
  kf->aux = aux;
c0021261:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0021265:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0021268:	ba 04 00 00 00       	mov    $0x4,%edx
c002126d:	89 d8                	mov    %ebx,%eax
c002126f:	e8 6b f4 ff ff       	call   c00206df <alloc_frame>
  ef->eip = (void (*) (void)) kernel_thread;
c0021274:	c7 00 09 11 02 c0    	movl   $0xc0021109,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c002127a:	ba 1c 00 00 00       	mov    $0x1c,%edx
c002127f:	89 d8                	mov    %ebx,%eax
c0021281:	e8 59 f4 ff ff       	call   c00206df <alloc_frame>
  sf->eip = switch_entry;
c0021286:	c7 40 10 21 15 02 c0 	movl   $0xc0021521,0x10(%eax)
  sf->ebp = 0;
c002128d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  intr_set_level(old_level);
c0021294:	89 2c 24             	mov    %ebp,(%esp)
c0021297:	e8 fb 03 00 00       	call   c0021697 <intr_set_level>
  /* Add to run queue. */
  thread_unblock (t);
c002129c:	89 1c 24             	mov    %ebx,(%esp)
c002129f:	e8 9e f6 ff ff       	call   c0020942 <thread_unblock>
  thread_yield();
c00212a4:	e8 a0 fe ff ff       	call   c0021149 <thread_yield>
  
  return tid;
c00212a9:	83 c4 10             	add    $0x10,%esp
c00212ac:	eb 05                	jmp    c00212b3 <thread_create+0xf2>
  ASSERT (function != NULL);

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
  if (t == NULL)
    return TID_ERROR;
c00212ae:	be ff ff ff ff       	mov    $0xffffffff,%esi
  /* Add to run queue. */
  thread_unblock (t);
  thread_yield();
  
  return tid;
}
c00212b3:	89 f0                	mov    %esi,%eax
c00212b5:	83 c4 0c             	add    $0xc,%esp
c00212b8:	5b                   	pop    %ebx
c00212b9:	5e                   	pop    %esi
c00212ba:	5f                   	pop    %edi
c00212bb:	5d                   	pop    %ebp
c00212bc:	c3                   	ret    

c00212bd <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c00212bd:	53                   	push   %ebx
c00212be:	83 ec 30             	sub    $0x30,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c00212c1:	6a 00                	push   $0x0
c00212c3:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c00212c7:	53                   	push   %ebx
c00212c8:	e8 1a 14 00 00       	call   c00226e7 <sema_init>
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00212cd:	53                   	push   %ebx
c00212ce:	68 72 10 02 c0       	push   $0xc0021072
c00212d3:	6a 00                	push   $0x0
c00212d5:	68 4c d6 02 c0       	push   $0xc002d64c
c00212da:	e8 e2 fe ff ff       	call   c00211c1 <thread_create>

  /* Start preemptive thread scheduling. */
  intr_enable ();
c00212df:	83 c4 20             	add    $0x20,%esp
c00212e2:	e8 75 03 00 00       	call   c002165c <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c00212e7:	83 ec 0c             	sub    $0xc,%esp
c00212ea:	53                   	push   %ebx
c00212eb:	e8 36 14 00 00       	call   c0022726 <sema_down>
}
c00212f0:	83 c4 38             	add    $0x38,%esp
c00212f3:	5b                   	pop    %ebx
c00212f4:	c3                   	ret    

c00212f5 <thread_set_priority>:
}

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c00212f5:	56                   	push   %esi
c00212f6:	53                   	push   %ebx
c00212f7:	83 ec 04             	sub    $0x4,%esp
c00212fa:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  old_level = intr_disable();
c00212fe:	e8 8d 03 00 00       	call   c0021690 <intr_disable>
c0021303:	89 c6                	mov    %eax,%esi
  struct thread *current_thread = thread_current();
c0021305:	e8 d0 f6 ff ff       	call   c00209da <thread_current>
  if(new_priority > current_thread->priority|| current_thread->priority == current_thread->inital_priority){
c002130a:	8b 50 1c             	mov    0x1c(%eax),%edx
c002130d:	39 da                	cmp    %ebx,%edx
c002130f:	7c 05                	jl     c0021316 <thread_set_priority+0x21>
c0021311:	3b 50 2c             	cmp    0x2c(%eax),%edx
c0021314:	75 03                	jne    c0021319 <thread_set_priority+0x24>
    current_thread->priority = new_priority;
c0021316:	89 58 1c             	mov    %ebx,0x1c(%eax)
  }
  current_thread->inital_priority = new_priority;
c0021319:	89 58 2c             	mov    %ebx,0x2c(%eax)
  //thread_current ()->priority = new_priority;
  thread_yield();
c002131c:	e8 28 fe ff ff       	call   c0021149 <thread_yield>
  intr_set_level(old_level);
c0021321:	83 ec 0c             	sub    $0xc,%esp
c0021324:	56                   	push   %esi
c0021325:	e8 6d 03 00 00       	call   c0021697 <intr_set_level>
}
c002132a:	83 c4 14             	add    $0x14,%esp
c002132d:	5b                   	pop    %ebx
c002132e:	5e                   	pop    %esi
c002132f:	c3                   	ret    

c0021330 <thread_set_nice>:
}

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0021330:	55                   	push   %ebp
c0021331:	57                   	push   %edi
c0021332:	56                   	push   %esi
c0021333:	53                   	push   %ebx
c0021334:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_disable ();
c0021337:	e8 54 03 00 00       	call   c0021690 <intr_disable>
c002133c:	89 c5                	mov    %eax,%ebp
  struct thread * current_thread = thread_current();
c002133e:	e8 97 f6 ff ff       	call   c00209da <thread_current>
  current_thread->nice = nice;
c0021343:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0021347:	89 58 4c             	mov    %ebx,0x4c(%eax)
  int temp_priority = Convert_x_to_integer_nearest(Substract_y_from_x(Convert_n_to_fixed_point(PRI_MAX), Add_x_and_n(Divide_x_by_n(current_thread->recent_cpu, 4), (current_thread->nice*2))));
c002134a:	8b 50 48             	mov    0x48(%eax),%edx
c002134d:	c1 fa 1f             	sar    $0x1f,%edx
c0021350:	83 e2 03             	and    $0x3,%edx
c0021353:	89 d1                	mov    %edx,%ecx
c0021355:	bb 00 00 00 00       	mov    $0x0,%ebx
c002135a:	03 48 44             	add    0x44(%eax),%ecx
c002135d:	13 58 48             	adc    0x48(%eax),%ebx
c0021360:	89 ce                	mov    %ecx,%esi
c0021362:	89 df                	mov    %ebx,%edi
c0021364:	0f ac de 02          	shrd   $0x2,%ebx,%esi
c0021368:	c1 ff 02             	sar    $0x2,%edi
c002136b:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c002136f:	c1 e1 0f             	shl    $0xf,%ecx
c0021372:	89 cb                	mov    %ecx,%ebx
c0021374:	c1 fb 1f             	sar    $0x1f,%ebx
c0021377:	01 f1                	add    %esi,%ecx
c0021379:	11 fb                	adc    %edi,%ebx
c002137b:	be 00 c0 0f 00       	mov    $0xfc000,%esi
c0021380:	bf 00 00 00 00       	mov    $0x0,%edi
c0021385:	29 ce                	sub    %ecx,%esi
c0021387:	19 df                	sbb    %ebx,%edi
c0021389:	85 ff                	test   %edi,%edi
c002138b:	78 2a                	js     c00213b7 <thread_set_nice+0x87>
c002138d:	be 00 e0 0f 00       	mov    $0xfe000,%esi
c0021392:	bf 00 00 00 00       	mov    $0x0,%edi
c0021397:	29 ce                	sub    %ecx,%esi
c0021399:	19 df                	sbb    %ebx,%edi
c002139b:	89 fa                	mov    %edi,%edx
c002139d:	c1 fa 1f             	sar    $0x1f,%edx
c00213a0:	81 e2 ff 3f 00 00    	and    $0x3fff,%edx
c00213a6:	89 d1                	mov    %edx,%ecx
c00213a8:	bb 00 00 00 00       	mov    $0x0,%ebx
c00213ad:	01 f1                	add    %esi,%ecx
c00213af:	11 fb                	adc    %edi,%ebx
c00213b1:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
c00213b5:	eb 28                	jmp    c00213df <thread_set_nice+0xaf>
c00213b7:	be 00 a0 0f 00       	mov    $0xfa000,%esi
c00213bc:	bf 00 00 00 00       	mov    $0x0,%edi
c00213c1:	29 ce                	sub    %ecx,%esi
c00213c3:	19 df                	sbb    %ebx,%edi
c00213c5:	89 fa                	mov    %edi,%edx
c00213c7:	c1 fa 1f             	sar    $0x1f,%edx
c00213ca:	81 e2 ff 3f 00 00    	and    $0x3fff,%edx
c00213d0:	89 d1                	mov    %edx,%ecx
c00213d2:	bb 00 00 00 00       	mov    $0x0,%ebx
c00213d7:	01 f1                	add    %esi,%ecx
c00213d9:	11 fb                	adc    %edi,%ebx
c00213db:	0f ac d9 0e          	shrd   $0xe,%ebx,%ecx
  if(temp_priority < PRI_MIN){
c00213df:	85 c9                	test   %ecx,%ecx
c00213e1:	79 09                	jns    c00213ec <thread_set_nice+0xbc>
    current_thread->priority = PRI_MIN;
c00213e3:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c00213ea:	eb 0e                	jmp    c00213fa <thread_set_nice+0xca>
  }else if(temp_priority > PRI_MAX){
    current_thread->priority = PRI_MAX;
c00213ec:	83 f9 40             	cmp    $0x40,%ecx
c00213ef:	be 3f 00 00 00       	mov    $0x3f,%esi
c00213f4:	0f 4d ce             	cmovge %esi,%ecx
c00213f7:	89 48 1c             	mov    %ecx,0x1c(%eax)
  }else{
    current_thread->priority = temp_priority;
  }
  thread_yield();
c00213fa:	e8 4a fd ff ff       	call   c0021149 <thread_yield>
  intr_set_level (old_level);
c00213ff:	83 ec 0c             	sub    $0xc,%esp
c0021402:	55                   	push   %ebp
c0021403:	e8 8f 02 00 00       	call   c0021697 <intr_set_level>
}
c0021408:	83 c4 1c             	add    $0x1c,%esp
c002140b:	5b                   	pop    %ebx
c002140c:	5e                   	pop    %esi
c002140d:	5f                   	pop    %edi
c002140e:	5d                   	pop    %ebp
c002140f:	c3                   	ret    

c0021410 <check_wake>:

/* Offset of `stack' member within `struct thread'.
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof (struct thread, stack);

thread_action_func *check_wake(struct thread *t,void *aux UNUSED){
c0021410:	83 ec 0c             	sub    $0xc,%esp
c0021413:	8b 44 24 10          	mov    0x10(%esp),%eax
  if(t->status == THREAD_BLOCKED && t->tickstowake >0){
c0021417:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
c002141b:	75 1d                	jne    c002143a <check_wake+0x2a>
c002141d:	8b 50 28             	mov    0x28(%eax),%edx
c0021420:	85 d2                	test   %edx,%edx
c0021422:	7e 16                	jle    c002143a <check_wake+0x2a>
    t->tickstowake--;
c0021424:	83 ea 01             	sub    $0x1,%edx
c0021427:	89 50 28             	mov    %edx,0x28(%eax)
    if(t->tickstowake == 0){
c002142a:	85 d2                	test   %edx,%edx
c002142c:	75 0c                	jne    c002143a <check_wake+0x2a>
      thread_unblock(t);
c002142e:	83 ec 0c             	sub    $0xc,%esp
c0021431:	50                   	push   %eax
c0021432:	e8 0b f5 ff ff       	call   c0020942 <thread_unblock>
c0021437:	83 c4 10             	add    $0x10,%esp
    }
  }
}
c002143a:	83 c4 0c             	add    $0xc,%esp
c002143d:	c3                   	ret    

c002143e <thread_cmp_priority_2>:
list_less_func *thread_cmp_priority(const struct list_elem *a,const struct list_elem *b,void *aux UNUSED){
  return  list_entry(a,struct thread,elem)->priority > list_entry(b,struct thread,elem)->priority;
}

list_less_func * thread_cmp_priority_2(const struct list_elem *a,const struct list_elem *b,void *aux UNUSED){
  return  list_entry(a,struct thread,elem)->priority < list_entry(b,struct thread,elem)->priority;
c002143e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0021442:	8b 54 24 04          	mov    0x4(%esp),%edx
c0021446:	8b 40 cc             	mov    -0x34(%eax),%eax
c0021449:	39 42 cc             	cmp    %eax,-0x34(%edx)
c002144c:	0f 9c c0             	setl   %al
c002144f:	0f b6 c0             	movzbl %al,%eax
}
c0021452:	c3                   	ret    

c0021453 <thread_foreachsleep>:
  return list_entry(a,struct thread,elem)->tickstowake < list_entry(b,struct thread,elem)->tickstowake;
}

void
thread_foreachsleep ()
{
c0021453:	55                   	push   %ebp
c0021454:	57                   	push   %edi
c0021455:	56                   	push   %esi
c0021456:	53                   	push   %ebx
c0021457:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  struct list_elem *e;
  struct list_elem *next_e;
  if(list_empty(&sleep_list))
c002145a:	68 68 7b 03 c0       	push   $0xc0037b68
c002145f:	e8 5e 6e 00 00       	call   c00282c2 <list_empty>
c0021464:	83 c4 10             	add    $0x10,%esp
c0021467:	84 c0                	test   %al,%al
c0021469:	75 71                	jne    c00214dc <thread_foreachsleep+0x89>
    return ;
  
  for(e = list_begin(&sleep_list);e!=list_end(&sleep_list);)
c002146b:	83 ec 0c             	sub    $0xc,%esp
c002146e:	68 68 7b 03 c0       	push   $0xc0037b68
c0021473:	e8 3f 69 00 00       	call   c0027db7 <list_begin>
c0021478:	89 c3                	mov    %eax,%ebx
c002147a:	83 c4 10             	add    $0x10,%esp
c002147d:	eb 49                	jmp    c00214c8 <thread_foreachsleep+0x75>
    {
      struct thread *t = list_entry (e, struct thread, elem);
c002147f:	8d 6b b0             	lea    -0x50(%ebx),%ebp
      next_e = list_next(e);
c0021482:	83 ec 0c             	sub    $0xc,%esp
c0021485:	53                   	push   %ebx
c0021486:	e8 5c 69 00 00       	call   c0027de7 <list_next>
c002148b:	89 c7                	mov    %eax,%edi
      if(t->tickstowake > timer_ticks()){
c002148d:	8b 73 d8             	mov    -0x28(%ebx),%esi
c0021490:	e8 a8 25 00 00       	call   c0023a3d <timer_ticks>
c0021495:	83 c4 10             	add    $0x10,%esp
c0021498:	39 c6                	cmp    %eax,%esi
c002149a:	7f 40                	jg     c00214dc <thread_foreachsleep+0x89>
        break;
      }
      old_level = intr_disable();
c002149c:	e8 ef 01 00 00       	call   c0021690 <intr_disable>
c00214a1:	89 c6                	mov    %eax,%esi
        list_remove(e);
c00214a3:	83 ec 0c             	sub    $0xc,%esp
c00214a6:	53                   	push   %ebx
c00214a7:	e8 89 6d 00 00       	call   c0028235 <list_remove>
        t->tickstowake = 0;
c00214ac:	c7 43 d8 00 00 00 00 	movl   $0x0,-0x28(%ebx)
        thread_unblock(t);
c00214b3:	89 2c 24             	mov    %ebp,(%esp)
c00214b6:	e8 87 f4 ff ff       	call   c0020942 <thread_unblock>
      intr_set_level(old_level);
c00214bb:	89 34 24             	mov    %esi,(%esp)
c00214be:	e8 d4 01 00 00       	call   c0021697 <intr_set_level>
c00214c3:	83 c4 10             	add    $0x10,%esp
      e = next_e;
c00214c6:	89 fb                	mov    %edi,%ebx
  struct list_elem *e;
  struct list_elem *next_e;
  if(list_empty(&sleep_list))
    return ;
  
  for(e = list_begin(&sleep_list);e!=list_end(&sleep_list);)
c00214c8:	83 ec 0c             	sub    $0xc,%esp
c00214cb:	68 68 7b 03 c0       	push   $0xc0037b68
c00214d0:	e8 58 69 00 00       	call   c0027e2d <list_end>
c00214d5:	83 c4 10             	add    $0x10,%esp
c00214d8:	39 c3                	cmp    %eax,%ebx
c00214da:	75 a3                	jne    c002147f <thread_foreachsleep+0x2c>
        t->tickstowake = 0;
        thread_unblock(t);
      intr_set_level(old_level);
      e = next_e;
    }
}
c00214dc:	83 c4 0c             	add    $0xc,%esp
c00214df:	5b                   	pop    %ebx
c00214e0:	5e                   	pop    %esi
c00214e1:	5f                   	pop    %edi
c00214e2:	5d                   	pop    %ebp
c00214e3:	c3                   	ret    

c00214e4 <push_into_sleep_list>:

void push_into_sleep_list(struct thread *current_thread ){
c00214e4:	83 ec 0c             	sub    $0xc,%esp
  list_insert_ordered(&sleep_list,&current_thread->elem,thread_cmp_tickstowake,NULL);
c00214e7:	6a 00                	push   $0x0
c00214e9:	68 ca 06 02 c0       	push   $0xc00206ca
c00214ee:	8b 44 24 18          	mov    0x18(%esp),%eax
c00214f2:	83 c0 50             	add    $0x50,%eax
c00214f5:	50                   	push   %eax
c00214f6:	68 68 7b 03 c0       	push   $0xc0037b68
c00214fb:	e8 61 71 00 00       	call   c0028661 <list_insert_ordered>
c0021500:	83 c4 1c             	add    $0x1c,%esp
c0021503:	c3                   	ret    

c0021504 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021504:	53                   	push   %ebx
	pushl %ebp
c0021505:	55                   	push   %ebp
	pushl %esi
c0021506:	56                   	push   %esi
	pushl %edi
c0021507:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021508:	8b 15 bc 75 03 c0    	mov    0xc00375bc,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c002150e:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021512:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021515:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021519:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c002151c:	5f                   	pop    %edi
	popl %esi
c002151d:	5e                   	pop    %esi
	popl %ebp
c002151e:	5d                   	pop    %ebp
	popl %ebx
c002151f:	5b                   	pop    %ebx
        ret
c0021520:	c3                   	ret    

c0021521 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021521:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021524:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021525:	e8 63 f9 ff ff       	call   c0020e8d <thread_schedule_tail>
	addl $4, %esp
c002152a:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c002152d:	c3                   	ret    

c002152e <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c002152e:	83 ec 0c             	sub    $0xc,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021531:	85 c0                	test   %eax,%eax
c0021533:	75 21                	jne    c0021556 <make_gate+0x28>
c0021535:	83 ec 0c             	sub    $0xc,%esp
c0021538:	68 3b d6 02 c0       	push   $0xc002d63b
c002153d:	68 3f d2 02 c0       	push   $0xc002d23f
c0021542:	68 5c bc 02 c0       	push   $0xc002bc5c
c0021547:	68 2a 01 00 00       	push   $0x12a
c002154c:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021551:	e8 77 67 00 00       	call   c0027ccd <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021556:	83 fa 03             	cmp    $0x3,%edx
c0021559:	76 21                	jbe    c002157c <make_gate+0x4e>
c002155b:	83 ec 0c             	sub    $0xc,%esp
c002155e:	68 fc d6 02 c0       	push   $0xc002d6fc
c0021563:	68 3f d2 02 c0       	push   $0xc002d23f
c0021568:	68 5c bc 02 c0       	push   $0xc002bc5c
c002156d:	68 2b 01 00 00       	push   $0x12b
c0021572:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021577:	e8 51 67 00 00       	call   c0027ccd <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c002157c:	83 f9 0f             	cmp    $0xf,%ecx
c002157f:	76 21                	jbe    c00215a2 <make_gate+0x74>
c0021581:	83 ec 0c             	sub    $0xc,%esp
c0021584:	68 11 d7 02 c0       	push   $0xc002d711
c0021589:	68 3f d2 02 c0       	push   $0xc002d23f
c002158e:	68 5c bc 02 c0       	push   $0xc002bc5c
c0021593:	68 2c 01 00 00       	push   $0x12c
c0021598:	68 e2 d6 02 c0       	push   $0xc002d6e2
c002159d:	e8 2b 67 00 00       	call   c0027ccd <debug_panic>
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */

  return e0 | ((uint64_t) e1 << 32);
c00215a2:	c1 e1 08             	shl    $0x8,%ecx
c00215a5:	80 cd 80             	or     $0x80,%ch
c00215a8:	c1 e2 0d             	shl    $0xd,%edx
c00215ab:	09 ca                	or     %ecx,%edx
c00215ad:	89 c1                	mov    %eax,%ecx
c00215af:	66 b9 00 00          	mov    $0x0,%cx
c00215b3:	09 ca                	or     %ecx,%edx
c00215b5:	0f b7 c0             	movzwl %ax,%eax
c00215b8:	0d 00 00 08 00       	or     $0x80000,%eax
}
c00215bd:	83 c4 0c             	add    $0xc,%esp
c00215c0:	c3                   	ret    

c00215c1 <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c00215c1:	53                   	push   %ebx
c00215c2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_handlers[vec_no] == NULL);
c00215c5:	0f b6 d8             	movzbl %al,%ebx
c00215c8:	83 3c 9d c0 83 03 c0 	cmpl   $0x0,-0x3ffc7c40(,%ebx,4)
c00215cf:	00 
c00215d0:	74 21                	je     c00215f3 <register_handler+0x32>
c00215d2:	83 ec 0c             	sub    $0xc,%esp
c00215d5:	68 29 d7 02 c0       	push   $0xc002d729
c00215da:	68 3f d2 02 c0       	push   $0xc002d23f
c00215df:	68 34 bc 02 c0       	push   $0xc002bc34
c00215e4:	68 a8 00 00 00       	push   $0xa8
c00215e9:	68 e2 d6 02 c0       	push   $0xc002d6e2
c00215ee:	e8 da 66 00 00       	call   c0027ccd <debug_panic>
  if (level == INTR_ON)
c00215f3:	83 f9 01             	cmp    $0x1,%ecx
c00215f6:	75 21                	jne    c0021619 <register_handler+0x58>
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 15);
c00215f8:	8b 04 9d c0 75 03 c0 	mov    -0x3ffc8a40(,%ebx,4),%eax
c00215ff:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021604:	e8 25 ff ff ff       	call   c002152e <make_gate>
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
  ASSERT (intr_handlers[vec_no] == NULL);
  if (level == INTR_ON)
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021609:	89 04 dd c0 87 03 c0 	mov    %eax,-0x3ffc7840(,%ebx,8)
c0021610:	89 14 dd c4 87 03 c0 	mov    %edx,-0x3ffc783c(,%ebx,8)
c0021617:	eb 1f                	jmp    c0021638 <register_handler+0x77>
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c0021619:	8b 04 9d c0 75 03 c0 	mov    -0x3ffc8a40(,%ebx,4),%eax
c0021620:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021625:	e8 04 ff ff ff       	call   c002152e <make_gate>
{
  ASSERT (intr_handlers[vec_no] == NULL);
  if (level == INTR_ON)
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c002162a:	89 04 dd c0 87 03 c0 	mov    %eax,-0x3ffc7840(,%ebx,8)
c0021631:	89 14 dd c4 87 03 c0 	mov    %edx,-0x3ffc783c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021638:	8b 44 24 10          	mov    0x10(%esp),%eax
c002163c:	89 04 9d c0 83 03 c0 	mov    %eax,-0x3ffc7c40(,%ebx,4)
  intr_names[vec_no] = name;
c0021643:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021647:	89 04 9d c0 7f 03 c0 	mov    %eax,-0x3ffc8040(,%ebx,4)
}
c002164e:	83 c4 08             	add    $0x8,%esp
c0021651:	5b                   	pop    %ebx
c0021652:	c3                   	ret    

c0021653 <intr_get_level>:

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021653:	9c                   	pushf  
c0021654:	58                   	pop    %eax

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021655:	c1 e8 09             	shr    $0x9,%eax
c0021658:	83 e0 01             	and    $0x1,%eax
}
c002165b:	c3                   	ret    

c002165c <intr_enable>:
}

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c002165c:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_get_level ();
c002165f:	e8 ef ff ff ff       	call   c0021653 <intr_get_level>
  ASSERT (!intr_context ());
c0021664:	80 3d a1 7b 03 c0 00 	cmpb   $0x0,0xc0037ba1
c002166b:	74 1e                	je     c002168b <intr_enable+0x2f>
c002166d:	83 ec 0c             	sub    $0xc,%esp
c0021670:	68 2a d6 02 c0       	push   $0xc002d62a
c0021675:	68 3f d2 02 c0       	push   $0xc002d23f
c002167a:	68 68 bc 02 c0       	push   $0xc002bc68
c002167f:	6a 5b                	push   $0x5b
c0021681:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021686:	e8 42 66 00 00       	call   c0027ccd <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c002168b:	fb                   	sti    

  return old_level;
}
c002168c:	83 c4 0c             	add    $0xc,%esp
c002168f:	c3                   	ret    

c0021690 <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
  enum intr_level old_level = intr_get_level ();
c0021690:	e8 be ff ff ff       	call   c0021653 <intr_get_level>

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c0021695:	fa                   	cli    

  return old_level;
}
c0021696:	c3                   	ret    

c0021697 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021697:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002169a:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c002169f:	75 07                	jne    c00216a8 <intr_set_level+0x11>
c00216a1:	e8 b6 ff ff ff       	call   c002165c <intr_enable>
c00216a6:	eb 05                	jmp    c00216ad <intr_set_level+0x16>
c00216a8:	e8 e3 ff ff ff       	call   c0021690 <intr_disable>
}
c00216ad:	83 c4 0c             	add    $0xc,%esp
c00216b0:	c3                   	ret    

c00216b1 <intr_init>:
}

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00216b1:	53                   	push   %ebx
c00216b2:	83 ec 18             	sub    $0x18,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00216b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00216ba:	e6 21                	out    %al,$0x21
c00216bc:	e6 a1                	out    %al,$0xa1
c00216be:	b8 11 00 00 00       	mov    $0x11,%eax
c00216c3:	e6 20                	out    %al,$0x20
c00216c5:	b8 20 00 00 00       	mov    $0x20,%eax
c00216ca:	e6 21                	out    %al,$0x21
c00216cc:	b8 04 00 00 00       	mov    $0x4,%eax
c00216d1:	e6 21                	out    %al,$0x21
c00216d3:	b8 01 00 00 00       	mov    $0x1,%eax
c00216d8:	e6 21                	out    %al,$0x21
c00216da:	b8 11 00 00 00       	mov    $0x11,%eax
c00216df:	e6 a0                	out    %al,$0xa0
c00216e1:	b8 28 00 00 00       	mov    $0x28,%eax
c00216e6:	e6 a1                	out    %al,$0xa1
c00216e8:	b8 02 00 00 00       	mov    $0x2,%eax
c00216ed:	e6 a1                	out    %al,$0xa1
c00216ef:	b8 01 00 00 00       	mov    $0x1,%eax
c00216f4:	e6 a1                	out    %al,$0xa1
c00216f6:	b8 00 00 00 00       	mov    $0x0,%eax
c00216fb:	e6 21                	out    %al,$0x21
c00216fd:	e6 a1                	out    %al,$0xa1
c00216ff:	bb 00 00 00 00       	mov    $0x0,%ebx
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
  return make_gate (function, dpl, 14);
c0021704:	8b 83 c0 75 03 c0    	mov    -0x3ffc8a40(%ebx),%eax
c002170a:	b9 0e 00 00 00       	mov    $0xe,%ecx
c002170f:	ba 00 00 00 00       	mov    $0x0,%edx
c0021714:	e8 15 fe ff ff       	call   c002152e <make_gate>
  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c0021719:	89 84 1b c0 87 03 c0 	mov    %eax,-0x3ffc7840(%ebx,%ebx,1)
c0021720:	89 94 1b c4 87 03 c0 	mov    %edx,-0x3ffc783c(%ebx,%ebx,1)
c0021727:	83 c3 04             	add    $0x4,%ebx

  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c002172a:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
c0021730:	75 d2                	jne    c0021704 <intr_init+0x53>
    idt[i] = make_intr_gate (intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c0021732:	b8 c0 87 03 c0       	mov    $0xc00387c0,%eax
c0021737:	ba 00 00 00 00       	mov    $0x0,%edx
c002173c:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021740:	c1 e0 10             	shl    $0x10,%eax
c0021743:	0d ff 07 00 00       	or     $0x7ff,%eax
c0021748:	89 44 24 08          	mov    %eax,0x8(%esp)
c002174c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021750:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c0021755:	b8 c0 7f 03 c0       	mov    $0xc0037fc0,%eax
c002175a:	ba c0 83 03 c0       	mov    $0xc00383c0,%edx

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
    intr_names[i] = "unknown";
c002175f:	c7 00 47 d7 02 c0    	movl   $0xc002d747,(%eax)
c0021765:	83 c0 04             	add    $0x4,%eax
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" : : "m" (idtr_operand));

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021768:	39 d0                	cmp    %edx,%eax
c002176a:	75 f3                	jne    c002175f <intr_init+0xae>
    intr_names[i] = "unknown";
  intr_names[0] = "#DE Divide Error";
c002176c:	c7 05 c0 7f 03 c0 4f 	movl   $0xc002d74f,0xc0037fc0
c0021773:	d7 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021776:	c7 05 c4 7f 03 c0 60 	movl   $0xc002d760,0xc0037fc4
c002177d:	d7 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021780:	c7 05 c8 7f 03 c0 74 	movl   $0xc002d774,0xc0037fc8
c0021787:	d7 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c002178a:	c7 05 cc 7f 03 c0 82 	movl   $0xc002d782,0xc0037fcc
c0021791:	d7 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021794:	c7 05 d0 7f 03 c0 9b 	movl   $0xc002d79b,0xc0037fd0
c002179b:	d7 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c002179e:	c7 05 d4 7f 03 c0 d8 	movl   $0xc002d8d8,0xc0037fd4
c00217a5:	d8 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c00217a8:	c7 05 d8 7f 03 c0 b2 	movl   $0xc002d7b2,0xc0037fd8
c00217af:	d7 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c00217b2:	c7 05 dc 7f 03 c0 fc 	movl   $0xc002d8fc,0xc0037fdc
c00217b9:	d8 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c00217bc:	c7 05 e0 7f 03 c0 cf 	movl   $0xc002d7cf,0xc0037fe0
c00217c3:	d7 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c00217c6:	c7 05 e4 7f 03 c0 ea 	movl   $0xc002d7ea,0xc0037fe4
c00217cd:	d7 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c00217d0:	c7 05 e8 7f 03 c0 06 	movl   $0xc002d806,0xc0037fe8
c00217d7:	d8 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c00217da:	c7 05 ec 7f 03 c0 20 	movl   $0xc002d820,0xc0037fec
c00217e1:	d8 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00217e4:	c7 05 f0 7f 03 c0 38 	movl   $0xc002d838,0xc0037ff0
c00217eb:	d8 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00217ee:	c7 05 f4 7f 03 c0 20 	movl   $0xc002d920,0xc0037ff4
c00217f5:	d9 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00217f8:	c7 05 f8 7f 03 c0 52 	movl   $0xc002d852,0xc0037ff8
c00217ff:	d8 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021802:	c7 05 00 80 03 c0 44 	movl   $0xc002d944,0xc0038000
c0021809:	d9 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c002180c:	c7 05 04 80 03 c0 6b 	movl   $0xc002d86b,0xc0038004
c0021813:	d8 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021816:	c7 05 08 80 03 c0 89 	movl   $0xc002d889,0xc0038008
c002181d:	d8 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021820:	c7 05 0c 80 03 c0 68 	movl   $0xc002d968,0xc003800c
c0021827:	d9 02 c0 
}
c002182a:	83 c4 18             	add    $0x18,%esp
c002182d:	5b                   	pop    %ebx
c002182e:	c3                   	ret    

c002182f <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c002182f:	83 ec 0c             	sub    $0xc,%esp
c0021832:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021836:	8d 50 e0             	lea    -0x20(%eax),%edx
c0021839:	80 fa 0f             	cmp    $0xf,%dl
c002183c:	76 21                	jbe    c002185f <intr_register_ext+0x30>
c002183e:	83 ec 0c             	sub    $0xc,%esp
c0021841:	68 8c d9 02 c0       	push   $0xc002d98c
c0021846:	68 3f d2 02 c0       	push   $0xc002d23f
c002184b:	68 48 bc 02 c0       	push   $0xc002bc48
c0021850:	68 b8 00 00 00       	push   $0xb8
c0021855:	68 e2 d6 02 c0       	push   $0xc002d6e2
c002185a:	e8 6e 64 00 00       	call   c0027ccd <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c002185f:	0f b6 c0             	movzbl %al,%eax
c0021862:	83 ec 08             	sub    $0x8,%esp
c0021865:	ff 74 24 20          	pushl  0x20(%esp)
c0021869:	ff 74 24 20          	pushl  0x20(%esp)
c002186d:	b9 00 00 00 00       	mov    $0x0,%ecx
c0021872:	ba 00 00 00 00       	mov    $0x0,%edx
c0021877:	e8 45 fd ff ff       	call   c00215c1 <register_handler>
}
c002187c:	83 c4 1c             	add    $0x1c,%esp
c002187f:	c3                   	ret    

c0021880 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021880:	83 ec 0c             	sub    $0xc,%esp
c0021883:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021887:	8d 50 e0             	lea    -0x20(%eax),%edx
c002188a:	80 fa 0f             	cmp    $0xf,%dl
c002188d:	77 21                	ja     c00218b0 <intr_register_int+0x30>
c002188f:	83 ec 0c             	sub    $0xc,%esp
c0021892:	68 b0 d9 02 c0       	push   $0xc002d9b0
c0021897:	68 3f d2 02 c0       	push   $0xc002d23f
c002189c:	68 20 bc 02 c0       	push   $0xc002bc20
c00218a1:	68 cd 00 00 00       	push   $0xcd
c00218a6:	68 e2 d6 02 c0       	push   $0xc002d6e2
c00218ab:	e8 1d 64 00 00       	call   c0027ccd <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c00218b0:	0f b6 c0             	movzbl %al,%eax
c00218b3:	83 ec 08             	sub    $0x8,%esp
c00218b6:	ff 74 24 28          	pushl  0x28(%esp)
c00218ba:	ff 74 24 28          	pushl  0x28(%esp)
c00218be:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c00218c2:	8b 54 24 24          	mov    0x24(%esp),%edx
c00218c6:	e8 f6 fc ff ff       	call   c00215c1 <register_handler>
}
c00218cb:	83 c4 1c             	add    $0x1c,%esp
c00218ce:	c3                   	ret    

c00218cf <intr_context>:
   and false at all other times. */
bool
intr_context (void) 
{
  return in_external_intr;
}
c00218cf:	0f b6 05 a1 7b 03 c0 	movzbl 0xc0037ba1,%eax
c00218d6:	c3                   	ret    

c00218d7 <intr_yield_on_return>:
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
  ASSERT (intr_context ());
c00218d7:	80 3d a1 7b 03 c0 00 	cmpb   $0x0,0xc0037ba1
c00218de:	75 21                	jne    c0021901 <intr_yield_on_return+0x2a>
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c00218e0:	83 ec 18             	sub    $0x18,%esp
  ASSERT (intr_context ());
c00218e3:	68 2b d6 02 c0       	push   $0xc002d62b
c00218e8:	68 3f d2 02 c0       	push   $0xc002d23f
c00218ed:	68 08 bc 02 c0       	push   $0xc002bc08
c00218f2:	68 e0 00 00 00       	push   $0xe0
c00218f7:	68 e2 d6 02 c0       	push   $0xc002d6e2
c00218fc:	e8 cc 63 00 00       	call   c0027ccd <debug_panic>
  yield_on_return = true;
c0021901:	c6 05 a0 7b 03 c0 01 	movb   $0x1,0xc0037ba0
c0021908:	c3                   	ret    

c0021909 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021909:	56                   	push   %esi
c002190a:	53                   	push   %ebx
c002190b:	83 ec 04             	sub    $0x4,%esp
c002190e:	8b 74 24 10          	mov    0x10(%esp),%esi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021912:	8b 46 30             	mov    0x30(%esi),%eax
c0021915:	8d 58 e0             	lea    -0x20(%eax),%ebx
  if (external) 
c0021918:	83 fb 0f             	cmp    $0xf,%ebx
c002191b:	77 62                	ja     c002197f <intr_handler+0x76>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c002191d:	e8 31 fd ff ff       	call   c0021653 <intr_get_level>
c0021922:	85 c0                	test   %eax,%eax
c0021924:	74 21                	je     c0021947 <intr_handler+0x3e>
c0021926:	83 ec 0c             	sub    $0xc,%esp
c0021929:	68 94 d5 02 c0       	push   $0xc002d594
c002192e:	68 3f d2 02 c0       	push   $0xc002d23f
c0021933:	68 f8 bb 02 c0       	push   $0xc002bbf8
c0021938:	68 65 01 00 00       	push   $0x165
c002193d:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021942:	e8 86 63 00 00       	call   c0027ccd <debug_panic>
      ASSERT (!intr_context ());
c0021947:	80 3d a1 7b 03 c0 00 	cmpb   $0x0,0xc0037ba1
c002194e:	74 21                	je     c0021971 <intr_handler+0x68>
c0021950:	83 ec 0c             	sub    $0xc,%esp
c0021953:	68 2a d6 02 c0       	push   $0xc002d62a
c0021958:	68 3f d2 02 c0       	push   $0xc002d23f
c002195d:	68 f8 bb 02 c0       	push   $0xc002bbf8
c0021962:	68 66 01 00 00       	push   $0x166
c0021967:	68 e2 d6 02 c0       	push   $0xc002d6e2
c002196c:	e8 5c 63 00 00       	call   c0027ccd <debug_panic>

      in_external_intr = true;
c0021971:	c6 05 a1 7b 03 c0 01 	movb   $0x1,0xc0037ba1
      yield_on_return = false;
c0021978:	c6 05 a0 7b 03 c0 00 	movb   $0x0,0xc0037ba0
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c002197f:	8b 56 30             	mov    0x30(%esi),%edx
c0021982:	8b 04 95 c0 83 03 c0 	mov    -0x3ffc7c40(,%edx,4),%eax
  if (handler != NULL)
c0021989:	85 c0                	test   %eax,%eax
c002198b:	74 0b                	je     c0021998 <intr_handler+0x8f>
    handler (frame);
c002198d:	83 ec 0c             	sub    $0xc,%esp
c0021990:	56                   	push   %esi
c0021991:	ff d0                	call   *%eax
c0021993:	83 c4 10             	add    $0x10,%esp
c0021996:	eb 37                	jmp    c00219cf <intr_handler+0xc6>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021998:	89 d0                	mov    %edx,%eax
c002199a:	83 e0 f7             	and    $0xfffffff7,%eax
c002199d:	83 f8 27             	cmp    $0x27,%eax
c00219a0:	74 2d                	je     c00219cf <intr_handler+0xc6>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c00219a2:	8b 0c 95 c0 7b 03 c0 	mov    -0x3ffc8440(,%edx,4),%ecx
c00219a9:	8d 41 01             	lea    0x1(%ecx),%eax
c00219ac:	89 04 95 c0 7b 03 c0 	mov    %eax,-0x3ffc8440(,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c00219b3:	85 c1                	test   %eax,%ecx
c00219b5:	75 18                	jne    c00219cf <intr_handler+0xc6>
    printf ("Unexpected interrupt %#04x (%s)\n",
c00219b7:	83 ec 04             	sub    $0x4,%esp
c00219ba:	ff 34 95 c0 7f 03 c0 	pushl  -0x3ffc8040(,%edx,4)
c00219c1:	52                   	push   %edx
c00219c2:	68 d0 d9 02 c0       	push   $0xc002d9d0
c00219c7:	e8 89 46 00 00       	call   c0026055 <printf>
c00219cc:	83 c4 10             	add    $0x10,%esp
    }
  else
    unexpected_interrupt (frame);

  /* Complete the processing of an external interrupt. */
  if (external) 
c00219cf:	83 fb 0f             	cmp    $0xf,%ebx
c00219d2:	0f 87 a3 00 00 00    	ja     c0021a7b <intr_handler+0x172>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c00219d8:	e8 76 fc ff ff       	call   c0021653 <intr_get_level>
c00219dd:	85 c0                	test   %eax,%eax
c00219df:	74 21                	je     c0021a02 <intr_handler+0xf9>
c00219e1:	83 ec 0c             	sub    $0xc,%esp
c00219e4:	68 94 d5 02 c0       	push   $0xc002d594
c00219e9:	68 3f d2 02 c0       	push   $0xc002d23f
c00219ee:	68 f8 bb 02 c0       	push   $0xc002bbf8
c00219f3:	68 7c 01 00 00       	push   $0x17c
c00219f8:	68 e2 d6 02 c0       	push   $0xc002d6e2
c00219fd:	e8 cb 62 00 00       	call   c0027ccd <debug_panic>
      ASSERT (intr_context ());
c0021a02:	80 3d a1 7b 03 c0 00 	cmpb   $0x0,0xc0037ba1
c0021a09:	75 21                	jne    c0021a2c <intr_handler+0x123>
c0021a0b:	83 ec 0c             	sub    $0xc,%esp
c0021a0e:	68 2b d6 02 c0       	push   $0xc002d62b
c0021a13:	68 3f d2 02 c0       	push   $0xc002d23f
c0021a18:	68 f8 bb 02 c0       	push   $0xc002bbf8
c0021a1d:	68 7d 01 00 00       	push   $0x17d
c0021a22:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021a27:	e8 a1 62 00 00       	call   c0027ccd <debug_panic>

      in_external_intr = false;
c0021a2c:	c6 05 a1 7b 03 c0 00 	movb   $0x0,0xc0037ba1
      pic_end_of_interrupt (frame->vec_no); 
c0021a33:	8b 56 30             	mov    0x30(%esi),%edx
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021a36:	8d 42 e0             	lea    -0x20(%edx),%eax
c0021a39:	83 f8 0f             	cmp    $0xf,%eax
c0021a3c:	76 21                	jbe    c0021a5f <intr_handler+0x156>
c0021a3e:	83 ec 0c             	sub    $0xc,%esp
c0021a41:	68 a5 d8 02 c0       	push   $0xc002d8a5
c0021a46:	68 3f d2 02 c0       	push   $0xc002d23f
c0021a4b:	68 e0 bb 02 c0       	push   $0xc002bbe0
c0021a50:	68 0b 01 00 00       	push   $0x10b
c0021a55:	68 e2 d6 02 c0       	push   $0xc002d6e2
c0021a5a:	e8 6e 62 00 00       	call   c0027ccd <debug_panic>
c0021a5f:	b8 20 00 00 00       	mov    $0x20,%eax
c0021a64:	e6 20                	out    %al,$0x20

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c0021a66:	83 fa 27             	cmp    $0x27,%edx
c0021a69:	7e 02                	jle    c0021a6d <intr_handler+0x164>
c0021a6b:	e6 a0                	out    %al,$0xa0
      ASSERT (intr_context ());

      in_external_intr = false;
      pic_end_of_interrupt (frame->vec_no); 

      if (yield_on_return) 
c0021a6d:	80 3d a0 7b 03 c0 00 	cmpb   $0x0,0xc0037ba0
c0021a74:	74 05                	je     c0021a7b <intr_handler+0x172>
        thread_yield (); 
c0021a76:	e8 ce f6 ff ff       	call   c0021149 <thread_yield>
    }
}
c0021a7b:	83 c4 04             	add    $0x4,%esp
c0021a7e:	5b                   	pop    %ebx
c0021a7f:	5e                   	pop    %esi
c0021a80:	c3                   	ret    

c0021a81 <intr_dump_frame>:
}

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021a81:	56                   	push   %esi
c0021a82:	53                   	push   %ebx
c0021a83:	83 ec 04             	sub    $0x4,%esp
c0021a86:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021a8a:	0f 20 d6             	mov    %cr2,%esi

  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021a8d:	8b 43 30             	mov    0x30(%ebx),%eax
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021a90:	ff 73 3c             	pushl  0x3c(%ebx)
c0021a93:	ff 34 85 c0 7f 03 c0 	pushl  -0x3ffc8040(,%eax,4)
c0021a9a:	50                   	push   %eax
c0021a9b:	68 f4 d9 02 c0       	push   $0xc002d9f4
c0021aa0:	e8 b0 45 00 00       	call   c0026055 <printf>
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021aa5:	83 c4 0c             	add    $0xc,%esp
c0021aa8:	ff 73 34             	pushl  0x34(%ebx)
c0021aab:	56                   	push   %esi
c0021aac:	68 bf d8 02 c0       	push   $0xc002d8bf
c0021ab1:	e8 9f 45 00 00       	call   c0026055 <printf>
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021ab6:	83 c4 04             	add    $0x4,%esp
c0021ab9:	ff 73 14             	pushl  0x14(%ebx)
c0021abc:	ff 73 18             	pushl  0x18(%ebx)
c0021abf:	ff 73 10             	pushl  0x10(%ebx)
c0021ac2:	ff 73 1c             	pushl  0x1c(%ebx)
c0021ac5:	68 14 da 02 c0       	push   $0xc002da14
c0021aca:	e8 86 45 00 00       	call   c0026055 <printf>
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021acf:	83 c4 14             	add    $0x14,%esp
c0021ad2:	ff 73 08             	pushl  0x8(%ebx)
c0021ad5:	ff 73 48             	pushl  0x48(%ebx)
c0021ad8:	ff 33                	pushl  (%ebx)
c0021ada:	ff 73 04             	pushl  0x4(%ebx)
c0021add:	68 3c da 02 c0       	push   $0xc002da3c
c0021ae2:	e8 6e 45 00 00       	call   c0026055 <printf>
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021ae7:	83 c4 14             	add    $0x14,%esp
c0021aea:	0f b7 43 4c          	movzwl 0x4c(%ebx),%eax
c0021aee:	50                   	push   %eax
c0021aef:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
c0021af3:	50                   	push   %eax
c0021af4:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
c0021af8:	50                   	push   %eax
c0021af9:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
c0021afd:	50                   	push   %eax
c0021afe:	68 64 da 02 c0       	push   $0xc002da64
c0021b03:	e8 4d 45 00 00       	call   c0026055 <printf>
          f->cs, f->ds, f->es, f->ss);
}
c0021b08:	83 c4 24             	add    $0x24,%esp
c0021b0b:	5b                   	pop    %ebx
c0021b0c:	5e                   	pop    %esi
c0021b0d:	c3                   	ret    

c0021b0e <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
  return intr_names[vec];
c0021b0e:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0021b13:	8b 04 85 c0 7f 03 c0 	mov    -0x3ffc8040(,%eax,4),%eax
}
c0021b1a:	c3                   	ret    

c0021b1b <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021b1b:	1e                   	push   %ds
	pushl %es
c0021b1c:	06                   	push   %es
	pushl %fs
c0021b1d:	0f a0                	push   %fs
	pushl %gs
c0021b1f:	0f a8                	push   %gs
	pushal
c0021b21:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021b22:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021b23:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021b28:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021b2a:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021b2c:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021b30:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021b31:	e8 d3 fd ff ff       	call   c0021909 <intr_handler>
	addl $4, %esp
c0021b36:	83 c4 04             	add    $0x4,%esp

c0021b39 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021b39:	61                   	popa   
	popl %gs
c0021b3a:	0f a9                	pop    %gs
	popl %fs
c0021b3c:	0f a1                	pop    %fs
	popl %es
c0021b3e:	07                   	pop    %es
	popl %ds
c0021b3f:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021b40:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021b43:	cf                   	iret   

c0021b44 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021b44:	55                   	push   %ebp
c0021b45:	6a 00                	push   $0x0
c0021b47:	6a 00                	push   $0x0
c0021b49:	eb d0                	jmp    c0021b1b <intr_entry>

c0021b4b <intr01_stub>:
c0021b4b:	55                   	push   %ebp
c0021b4c:	6a 00                	push   $0x0
c0021b4e:	6a 01                	push   $0x1
c0021b50:	eb c9                	jmp    c0021b1b <intr_entry>

c0021b52 <intr02_stub>:
c0021b52:	55                   	push   %ebp
c0021b53:	6a 00                	push   $0x0
c0021b55:	6a 02                	push   $0x2
c0021b57:	eb c2                	jmp    c0021b1b <intr_entry>

c0021b59 <intr03_stub>:
c0021b59:	55                   	push   %ebp
c0021b5a:	6a 00                	push   $0x0
c0021b5c:	6a 03                	push   $0x3
c0021b5e:	eb bb                	jmp    c0021b1b <intr_entry>

c0021b60 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021b60:	55                   	push   %ebp
c0021b61:	6a 00                	push   $0x0
c0021b63:	6a 04                	push   $0x4
c0021b65:	eb b4                	jmp    c0021b1b <intr_entry>

c0021b67 <intr05_stub>:
c0021b67:	55                   	push   %ebp
c0021b68:	6a 00                	push   $0x0
c0021b6a:	6a 05                	push   $0x5
c0021b6c:	eb ad                	jmp    c0021b1b <intr_entry>

c0021b6e <intr06_stub>:
c0021b6e:	55                   	push   %ebp
c0021b6f:	6a 00                	push   $0x0
c0021b71:	6a 06                	push   $0x6
c0021b73:	eb a6                	jmp    c0021b1b <intr_entry>

c0021b75 <intr07_stub>:
c0021b75:	55                   	push   %ebp
c0021b76:	6a 00                	push   $0x0
c0021b78:	6a 07                	push   $0x7
c0021b7a:	eb 9f                	jmp    c0021b1b <intr_entry>

c0021b7c <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021b7c:	ff 34 24             	pushl  (%esp)
c0021b7f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021b83:	6a 08                	push   $0x8
c0021b85:	eb 94                	jmp    c0021b1b <intr_entry>

c0021b87 <intr09_stub>:
c0021b87:	55                   	push   %ebp
c0021b88:	6a 00                	push   $0x0
c0021b8a:	6a 09                	push   $0x9
c0021b8c:	eb 8d                	jmp    c0021b1b <intr_entry>

c0021b8e <intr0a_stub>:
c0021b8e:	ff 34 24             	pushl  (%esp)
c0021b91:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021b95:	6a 0a                	push   $0xa
c0021b97:	eb 82                	jmp    c0021b1b <intr_entry>

c0021b99 <intr0b_stub>:
c0021b99:	ff 34 24             	pushl  (%esp)
c0021b9c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ba0:	6a 0b                	push   $0xb
c0021ba2:	e9 74 ff ff ff       	jmp    c0021b1b <intr_entry>

c0021ba7 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021ba7:	55                   	push   %ebp
c0021ba8:	6a 00                	push   $0x0
c0021baa:	6a 0c                	push   $0xc
c0021bac:	e9 6a ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bb1 <intr0d_stub>:
c0021bb1:	ff 34 24             	pushl  (%esp)
c0021bb4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021bb8:	6a 0d                	push   $0xd
c0021bba:	e9 5c ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bbf <intr0e_stub>:
c0021bbf:	ff 34 24             	pushl  (%esp)
c0021bc2:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021bc6:	6a 0e                	push   $0xe
c0021bc8:	e9 4e ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bcd <intr0f_stub>:
c0021bcd:	55                   	push   %ebp
c0021bce:	6a 00                	push   $0x0
c0021bd0:	6a 0f                	push   $0xf
c0021bd2:	e9 44 ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bd7 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021bd7:	55                   	push   %ebp
c0021bd8:	6a 00                	push   $0x0
c0021bda:	6a 10                	push   $0x10
c0021bdc:	e9 3a ff ff ff       	jmp    c0021b1b <intr_entry>

c0021be1 <intr11_stub>:
c0021be1:	ff 34 24             	pushl  (%esp)
c0021be4:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021be8:	6a 11                	push   $0x11
c0021bea:	e9 2c ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bef <intr12_stub>:
c0021bef:	55                   	push   %ebp
c0021bf0:	6a 00                	push   $0x0
c0021bf2:	6a 12                	push   $0x12
c0021bf4:	e9 22 ff ff ff       	jmp    c0021b1b <intr_entry>

c0021bf9 <intr13_stub>:
c0021bf9:	55                   	push   %ebp
c0021bfa:	6a 00                	push   $0x0
c0021bfc:	6a 13                	push   $0x13
c0021bfe:	e9 18 ff ff ff       	jmp    c0021b1b <intr_entry>

c0021c03 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021c03:	55                   	push   %ebp
c0021c04:	6a 00                	push   $0x0
c0021c06:	6a 14                	push   $0x14
c0021c08:	e9 0e ff ff ff       	jmp    c0021b1b <intr_entry>

c0021c0d <intr15_stub>:
c0021c0d:	55                   	push   %ebp
c0021c0e:	6a 00                	push   $0x0
c0021c10:	6a 15                	push   $0x15
c0021c12:	e9 04 ff ff ff       	jmp    c0021b1b <intr_entry>

c0021c17 <intr16_stub>:
c0021c17:	55                   	push   %ebp
c0021c18:	6a 00                	push   $0x0
c0021c1a:	6a 16                	push   $0x16
c0021c1c:	e9 fa fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c21 <intr17_stub>:
c0021c21:	55                   	push   %ebp
c0021c22:	6a 00                	push   $0x0
c0021c24:	6a 17                	push   $0x17
c0021c26:	e9 f0 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c2b <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021c2b:	ff 34 24             	pushl  (%esp)
c0021c2e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c32:	6a 18                	push   $0x18
c0021c34:	e9 e2 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c39 <intr19_stub>:
c0021c39:	55                   	push   %ebp
c0021c3a:	6a 00                	push   $0x0
c0021c3c:	6a 19                	push   $0x19
c0021c3e:	e9 d8 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c43 <intr1a_stub>:
c0021c43:	ff 34 24             	pushl  (%esp)
c0021c46:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c4a:	6a 1a                	push   $0x1a
c0021c4c:	e9 ca fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c51 <intr1b_stub>:
c0021c51:	ff 34 24             	pushl  (%esp)
c0021c54:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c58:	6a 1b                	push   $0x1b
c0021c5a:	e9 bc fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c5f <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021c5f:	55                   	push   %ebp
c0021c60:	6a 00                	push   $0x0
c0021c62:	6a 1c                	push   $0x1c
c0021c64:	e9 b2 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c69 <intr1d_stub>:
c0021c69:	ff 34 24             	pushl  (%esp)
c0021c6c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c70:	6a 1d                	push   $0x1d
c0021c72:	e9 a4 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c77 <intr1e_stub>:
c0021c77:	ff 34 24             	pushl  (%esp)
c0021c7a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c7e:	6a 1e                	push   $0x1e
c0021c80:	e9 96 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c85 <intr1f_stub>:
c0021c85:	55                   	push   %ebp
c0021c86:	6a 00                	push   $0x0
c0021c88:	6a 1f                	push   $0x1f
c0021c8a:	e9 8c fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c8f <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021c8f:	55                   	push   %ebp
c0021c90:	6a 00                	push   $0x0
c0021c92:	6a 20                	push   $0x20
c0021c94:	e9 82 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021c99 <intr21_stub>:
c0021c99:	55                   	push   %ebp
c0021c9a:	6a 00                	push   $0x0
c0021c9c:	6a 21                	push   $0x21
c0021c9e:	e9 78 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021ca3 <intr22_stub>:
c0021ca3:	55                   	push   %ebp
c0021ca4:	6a 00                	push   $0x0
c0021ca6:	6a 22                	push   $0x22
c0021ca8:	e9 6e fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cad <intr23_stub>:
c0021cad:	55                   	push   %ebp
c0021cae:	6a 00                	push   $0x0
c0021cb0:	6a 23                	push   $0x23
c0021cb2:	e9 64 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cb7 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021cb7:	55                   	push   %ebp
c0021cb8:	6a 00                	push   $0x0
c0021cba:	6a 24                	push   $0x24
c0021cbc:	e9 5a fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cc1 <intr25_stub>:
c0021cc1:	55                   	push   %ebp
c0021cc2:	6a 00                	push   $0x0
c0021cc4:	6a 25                	push   $0x25
c0021cc6:	e9 50 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021ccb <intr26_stub>:
c0021ccb:	55                   	push   %ebp
c0021ccc:	6a 00                	push   $0x0
c0021cce:	6a 26                	push   $0x26
c0021cd0:	e9 46 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cd5 <intr27_stub>:
c0021cd5:	55                   	push   %ebp
c0021cd6:	6a 00                	push   $0x0
c0021cd8:	6a 27                	push   $0x27
c0021cda:	e9 3c fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cdf <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021cdf:	55                   	push   %ebp
c0021ce0:	6a 00                	push   $0x0
c0021ce2:	6a 28                	push   $0x28
c0021ce4:	e9 32 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021ce9 <intr29_stub>:
c0021ce9:	55                   	push   %ebp
c0021cea:	6a 00                	push   $0x0
c0021cec:	6a 29                	push   $0x29
c0021cee:	e9 28 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cf3 <intr2a_stub>:
c0021cf3:	55                   	push   %ebp
c0021cf4:	6a 00                	push   $0x0
c0021cf6:	6a 2a                	push   $0x2a
c0021cf8:	e9 1e fe ff ff       	jmp    c0021b1b <intr_entry>

c0021cfd <intr2b_stub>:
c0021cfd:	55                   	push   %ebp
c0021cfe:	6a 00                	push   $0x0
c0021d00:	6a 2b                	push   $0x2b
c0021d02:	e9 14 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021d07 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021d07:	55                   	push   %ebp
c0021d08:	6a 00                	push   $0x0
c0021d0a:	6a 2c                	push   $0x2c
c0021d0c:	e9 0a fe ff ff       	jmp    c0021b1b <intr_entry>

c0021d11 <intr2d_stub>:
c0021d11:	55                   	push   %ebp
c0021d12:	6a 00                	push   $0x0
c0021d14:	6a 2d                	push   $0x2d
c0021d16:	e9 00 fe ff ff       	jmp    c0021b1b <intr_entry>

c0021d1b <intr2e_stub>:
c0021d1b:	55                   	push   %ebp
c0021d1c:	6a 00                	push   $0x0
c0021d1e:	6a 2e                	push   $0x2e
c0021d20:	e9 f6 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d25 <intr2f_stub>:
c0021d25:	55                   	push   %ebp
c0021d26:	6a 00                	push   $0x0
c0021d28:	6a 2f                	push   $0x2f
c0021d2a:	e9 ec fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d2f <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021d2f:	55                   	push   %ebp
c0021d30:	6a 00                	push   $0x0
c0021d32:	6a 30                	push   $0x30
c0021d34:	e9 e2 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d39 <intr31_stub>:
c0021d39:	55                   	push   %ebp
c0021d3a:	6a 00                	push   $0x0
c0021d3c:	6a 31                	push   $0x31
c0021d3e:	e9 d8 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d43 <intr32_stub>:
c0021d43:	55                   	push   %ebp
c0021d44:	6a 00                	push   $0x0
c0021d46:	6a 32                	push   $0x32
c0021d48:	e9 ce fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d4d <intr33_stub>:
c0021d4d:	55                   	push   %ebp
c0021d4e:	6a 00                	push   $0x0
c0021d50:	6a 33                	push   $0x33
c0021d52:	e9 c4 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d57 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021d57:	55                   	push   %ebp
c0021d58:	6a 00                	push   $0x0
c0021d5a:	6a 34                	push   $0x34
c0021d5c:	e9 ba fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d61 <intr35_stub>:
c0021d61:	55                   	push   %ebp
c0021d62:	6a 00                	push   $0x0
c0021d64:	6a 35                	push   $0x35
c0021d66:	e9 b0 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d6b <intr36_stub>:
c0021d6b:	55                   	push   %ebp
c0021d6c:	6a 00                	push   $0x0
c0021d6e:	6a 36                	push   $0x36
c0021d70:	e9 a6 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d75 <intr37_stub>:
c0021d75:	55                   	push   %ebp
c0021d76:	6a 00                	push   $0x0
c0021d78:	6a 37                	push   $0x37
c0021d7a:	e9 9c fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d7f <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021d7f:	55                   	push   %ebp
c0021d80:	6a 00                	push   $0x0
c0021d82:	6a 38                	push   $0x38
c0021d84:	e9 92 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d89 <intr39_stub>:
c0021d89:	55                   	push   %ebp
c0021d8a:	6a 00                	push   $0x0
c0021d8c:	6a 39                	push   $0x39
c0021d8e:	e9 88 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d93 <intr3a_stub>:
c0021d93:	55                   	push   %ebp
c0021d94:	6a 00                	push   $0x0
c0021d96:	6a 3a                	push   $0x3a
c0021d98:	e9 7e fd ff ff       	jmp    c0021b1b <intr_entry>

c0021d9d <intr3b_stub>:
c0021d9d:	55                   	push   %ebp
c0021d9e:	6a 00                	push   $0x0
c0021da0:	6a 3b                	push   $0x3b
c0021da2:	e9 74 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021da7 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021da7:	55                   	push   %ebp
c0021da8:	6a 00                	push   $0x0
c0021daa:	6a 3c                	push   $0x3c
c0021dac:	e9 6a fd ff ff       	jmp    c0021b1b <intr_entry>

c0021db1 <intr3d_stub>:
c0021db1:	55                   	push   %ebp
c0021db2:	6a 00                	push   $0x0
c0021db4:	6a 3d                	push   $0x3d
c0021db6:	e9 60 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021dbb <intr3e_stub>:
c0021dbb:	55                   	push   %ebp
c0021dbc:	6a 00                	push   $0x0
c0021dbe:	6a 3e                	push   $0x3e
c0021dc0:	e9 56 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021dc5 <intr3f_stub>:
c0021dc5:	55                   	push   %ebp
c0021dc6:	6a 00                	push   $0x0
c0021dc8:	6a 3f                	push   $0x3f
c0021dca:	e9 4c fd ff ff       	jmp    c0021b1b <intr_entry>

c0021dcf <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0021dcf:	55                   	push   %ebp
c0021dd0:	6a 00                	push   $0x0
c0021dd2:	6a 40                	push   $0x40
c0021dd4:	e9 42 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021dd9 <intr41_stub>:
c0021dd9:	55                   	push   %ebp
c0021dda:	6a 00                	push   $0x0
c0021ddc:	6a 41                	push   $0x41
c0021dde:	e9 38 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021de3 <intr42_stub>:
c0021de3:	55                   	push   %ebp
c0021de4:	6a 00                	push   $0x0
c0021de6:	6a 42                	push   $0x42
c0021de8:	e9 2e fd ff ff       	jmp    c0021b1b <intr_entry>

c0021ded <intr43_stub>:
c0021ded:	55                   	push   %ebp
c0021dee:	6a 00                	push   $0x0
c0021df0:	6a 43                	push   $0x43
c0021df2:	e9 24 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021df7 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0021df7:	55                   	push   %ebp
c0021df8:	6a 00                	push   $0x0
c0021dfa:	6a 44                	push   $0x44
c0021dfc:	e9 1a fd ff ff       	jmp    c0021b1b <intr_entry>

c0021e01 <intr45_stub>:
c0021e01:	55                   	push   %ebp
c0021e02:	6a 00                	push   $0x0
c0021e04:	6a 45                	push   $0x45
c0021e06:	e9 10 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021e0b <intr46_stub>:
c0021e0b:	55                   	push   %ebp
c0021e0c:	6a 00                	push   $0x0
c0021e0e:	6a 46                	push   $0x46
c0021e10:	e9 06 fd ff ff       	jmp    c0021b1b <intr_entry>

c0021e15 <intr47_stub>:
c0021e15:	55                   	push   %ebp
c0021e16:	6a 00                	push   $0x0
c0021e18:	6a 47                	push   $0x47
c0021e1a:	e9 fc fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e1f <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0021e1f:	55                   	push   %ebp
c0021e20:	6a 00                	push   $0x0
c0021e22:	6a 48                	push   $0x48
c0021e24:	e9 f2 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e29 <intr49_stub>:
c0021e29:	55                   	push   %ebp
c0021e2a:	6a 00                	push   $0x0
c0021e2c:	6a 49                	push   $0x49
c0021e2e:	e9 e8 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e33 <intr4a_stub>:
c0021e33:	55                   	push   %ebp
c0021e34:	6a 00                	push   $0x0
c0021e36:	6a 4a                	push   $0x4a
c0021e38:	e9 de fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e3d <intr4b_stub>:
c0021e3d:	55                   	push   %ebp
c0021e3e:	6a 00                	push   $0x0
c0021e40:	6a 4b                	push   $0x4b
c0021e42:	e9 d4 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e47 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0021e47:	55                   	push   %ebp
c0021e48:	6a 00                	push   $0x0
c0021e4a:	6a 4c                	push   $0x4c
c0021e4c:	e9 ca fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e51 <intr4d_stub>:
c0021e51:	55                   	push   %ebp
c0021e52:	6a 00                	push   $0x0
c0021e54:	6a 4d                	push   $0x4d
c0021e56:	e9 c0 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e5b <intr4e_stub>:
c0021e5b:	55                   	push   %ebp
c0021e5c:	6a 00                	push   $0x0
c0021e5e:	6a 4e                	push   $0x4e
c0021e60:	e9 b6 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e65 <intr4f_stub>:
c0021e65:	55                   	push   %ebp
c0021e66:	6a 00                	push   $0x0
c0021e68:	6a 4f                	push   $0x4f
c0021e6a:	e9 ac fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e6f <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0021e6f:	55                   	push   %ebp
c0021e70:	6a 00                	push   $0x0
c0021e72:	6a 50                	push   $0x50
c0021e74:	e9 a2 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e79 <intr51_stub>:
c0021e79:	55                   	push   %ebp
c0021e7a:	6a 00                	push   $0x0
c0021e7c:	6a 51                	push   $0x51
c0021e7e:	e9 98 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e83 <intr52_stub>:
c0021e83:	55                   	push   %ebp
c0021e84:	6a 00                	push   $0x0
c0021e86:	6a 52                	push   $0x52
c0021e88:	e9 8e fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e8d <intr53_stub>:
c0021e8d:	55                   	push   %ebp
c0021e8e:	6a 00                	push   $0x0
c0021e90:	6a 53                	push   $0x53
c0021e92:	e9 84 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021e97 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0021e97:	55                   	push   %ebp
c0021e98:	6a 00                	push   $0x0
c0021e9a:	6a 54                	push   $0x54
c0021e9c:	e9 7a fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ea1 <intr55_stub>:
c0021ea1:	55                   	push   %ebp
c0021ea2:	6a 00                	push   $0x0
c0021ea4:	6a 55                	push   $0x55
c0021ea6:	e9 70 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021eab <intr56_stub>:
c0021eab:	55                   	push   %ebp
c0021eac:	6a 00                	push   $0x0
c0021eae:	6a 56                	push   $0x56
c0021eb0:	e9 66 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021eb5 <intr57_stub>:
c0021eb5:	55                   	push   %ebp
c0021eb6:	6a 00                	push   $0x0
c0021eb8:	6a 57                	push   $0x57
c0021eba:	e9 5c fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ebf <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0021ebf:	55                   	push   %ebp
c0021ec0:	6a 00                	push   $0x0
c0021ec2:	6a 58                	push   $0x58
c0021ec4:	e9 52 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ec9 <intr59_stub>:
c0021ec9:	55                   	push   %ebp
c0021eca:	6a 00                	push   $0x0
c0021ecc:	6a 59                	push   $0x59
c0021ece:	e9 48 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ed3 <intr5a_stub>:
c0021ed3:	55                   	push   %ebp
c0021ed4:	6a 00                	push   $0x0
c0021ed6:	6a 5a                	push   $0x5a
c0021ed8:	e9 3e fc ff ff       	jmp    c0021b1b <intr_entry>

c0021edd <intr5b_stub>:
c0021edd:	55                   	push   %ebp
c0021ede:	6a 00                	push   $0x0
c0021ee0:	6a 5b                	push   $0x5b
c0021ee2:	e9 34 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ee7 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0021ee7:	55                   	push   %ebp
c0021ee8:	6a 00                	push   $0x0
c0021eea:	6a 5c                	push   $0x5c
c0021eec:	e9 2a fc ff ff       	jmp    c0021b1b <intr_entry>

c0021ef1 <intr5d_stub>:
c0021ef1:	55                   	push   %ebp
c0021ef2:	6a 00                	push   $0x0
c0021ef4:	6a 5d                	push   $0x5d
c0021ef6:	e9 20 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021efb <intr5e_stub>:
c0021efb:	55                   	push   %ebp
c0021efc:	6a 00                	push   $0x0
c0021efe:	6a 5e                	push   $0x5e
c0021f00:	e9 16 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021f05 <intr5f_stub>:
c0021f05:	55                   	push   %ebp
c0021f06:	6a 00                	push   $0x0
c0021f08:	6a 5f                	push   $0x5f
c0021f0a:	e9 0c fc ff ff       	jmp    c0021b1b <intr_entry>

c0021f0f <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0021f0f:	55                   	push   %ebp
c0021f10:	6a 00                	push   $0x0
c0021f12:	6a 60                	push   $0x60
c0021f14:	e9 02 fc ff ff       	jmp    c0021b1b <intr_entry>

c0021f19 <intr61_stub>:
c0021f19:	55                   	push   %ebp
c0021f1a:	6a 00                	push   $0x0
c0021f1c:	6a 61                	push   $0x61
c0021f1e:	e9 f8 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f23 <intr62_stub>:
c0021f23:	55                   	push   %ebp
c0021f24:	6a 00                	push   $0x0
c0021f26:	6a 62                	push   $0x62
c0021f28:	e9 ee fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f2d <intr63_stub>:
c0021f2d:	55                   	push   %ebp
c0021f2e:	6a 00                	push   $0x0
c0021f30:	6a 63                	push   $0x63
c0021f32:	e9 e4 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f37 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0021f37:	55                   	push   %ebp
c0021f38:	6a 00                	push   $0x0
c0021f3a:	6a 64                	push   $0x64
c0021f3c:	e9 da fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f41 <intr65_stub>:
c0021f41:	55                   	push   %ebp
c0021f42:	6a 00                	push   $0x0
c0021f44:	6a 65                	push   $0x65
c0021f46:	e9 d0 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f4b <intr66_stub>:
c0021f4b:	55                   	push   %ebp
c0021f4c:	6a 00                	push   $0x0
c0021f4e:	6a 66                	push   $0x66
c0021f50:	e9 c6 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f55 <intr67_stub>:
c0021f55:	55                   	push   %ebp
c0021f56:	6a 00                	push   $0x0
c0021f58:	6a 67                	push   $0x67
c0021f5a:	e9 bc fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f5f <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0021f5f:	55                   	push   %ebp
c0021f60:	6a 00                	push   $0x0
c0021f62:	6a 68                	push   $0x68
c0021f64:	e9 b2 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f69 <intr69_stub>:
c0021f69:	55                   	push   %ebp
c0021f6a:	6a 00                	push   $0x0
c0021f6c:	6a 69                	push   $0x69
c0021f6e:	e9 a8 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f73 <intr6a_stub>:
c0021f73:	55                   	push   %ebp
c0021f74:	6a 00                	push   $0x0
c0021f76:	6a 6a                	push   $0x6a
c0021f78:	e9 9e fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f7d <intr6b_stub>:
c0021f7d:	55                   	push   %ebp
c0021f7e:	6a 00                	push   $0x0
c0021f80:	6a 6b                	push   $0x6b
c0021f82:	e9 94 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f87 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0021f87:	55                   	push   %ebp
c0021f88:	6a 00                	push   $0x0
c0021f8a:	6a 6c                	push   $0x6c
c0021f8c:	e9 8a fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f91 <intr6d_stub>:
c0021f91:	55                   	push   %ebp
c0021f92:	6a 00                	push   $0x0
c0021f94:	6a 6d                	push   $0x6d
c0021f96:	e9 80 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021f9b <intr6e_stub>:
c0021f9b:	55                   	push   %ebp
c0021f9c:	6a 00                	push   $0x0
c0021f9e:	6a 6e                	push   $0x6e
c0021fa0:	e9 76 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fa5 <intr6f_stub>:
c0021fa5:	55                   	push   %ebp
c0021fa6:	6a 00                	push   $0x0
c0021fa8:	6a 6f                	push   $0x6f
c0021faa:	e9 6c fb ff ff       	jmp    c0021b1b <intr_entry>

c0021faf <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0021faf:	55                   	push   %ebp
c0021fb0:	6a 00                	push   $0x0
c0021fb2:	6a 70                	push   $0x70
c0021fb4:	e9 62 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fb9 <intr71_stub>:
c0021fb9:	55                   	push   %ebp
c0021fba:	6a 00                	push   $0x0
c0021fbc:	6a 71                	push   $0x71
c0021fbe:	e9 58 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fc3 <intr72_stub>:
c0021fc3:	55                   	push   %ebp
c0021fc4:	6a 00                	push   $0x0
c0021fc6:	6a 72                	push   $0x72
c0021fc8:	e9 4e fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fcd <intr73_stub>:
c0021fcd:	55                   	push   %ebp
c0021fce:	6a 00                	push   $0x0
c0021fd0:	6a 73                	push   $0x73
c0021fd2:	e9 44 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fd7 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0021fd7:	55                   	push   %ebp
c0021fd8:	6a 00                	push   $0x0
c0021fda:	6a 74                	push   $0x74
c0021fdc:	e9 3a fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fe1 <intr75_stub>:
c0021fe1:	55                   	push   %ebp
c0021fe2:	6a 00                	push   $0x0
c0021fe4:	6a 75                	push   $0x75
c0021fe6:	e9 30 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021feb <intr76_stub>:
c0021feb:	55                   	push   %ebp
c0021fec:	6a 00                	push   $0x0
c0021fee:	6a 76                	push   $0x76
c0021ff0:	e9 26 fb ff ff       	jmp    c0021b1b <intr_entry>

c0021ff5 <intr77_stub>:
c0021ff5:	55                   	push   %ebp
c0021ff6:	6a 00                	push   $0x0
c0021ff8:	6a 77                	push   $0x77
c0021ffa:	e9 1c fb ff ff       	jmp    c0021b1b <intr_entry>

c0021fff <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0021fff:	55                   	push   %ebp
c0022000:	6a 00                	push   $0x0
c0022002:	6a 78                	push   $0x78
c0022004:	e9 12 fb ff ff       	jmp    c0021b1b <intr_entry>

c0022009 <intr79_stub>:
c0022009:	55                   	push   %ebp
c002200a:	6a 00                	push   $0x0
c002200c:	6a 79                	push   $0x79
c002200e:	e9 08 fb ff ff       	jmp    c0021b1b <intr_entry>

c0022013 <intr7a_stub>:
c0022013:	55                   	push   %ebp
c0022014:	6a 00                	push   $0x0
c0022016:	6a 7a                	push   $0x7a
c0022018:	e9 fe fa ff ff       	jmp    c0021b1b <intr_entry>

c002201d <intr7b_stub>:
c002201d:	55                   	push   %ebp
c002201e:	6a 00                	push   $0x0
c0022020:	6a 7b                	push   $0x7b
c0022022:	e9 f4 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022027 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c0022027:	55                   	push   %ebp
c0022028:	6a 00                	push   $0x0
c002202a:	6a 7c                	push   $0x7c
c002202c:	e9 ea fa ff ff       	jmp    c0021b1b <intr_entry>

c0022031 <intr7d_stub>:
c0022031:	55                   	push   %ebp
c0022032:	6a 00                	push   $0x0
c0022034:	6a 7d                	push   $0x7d
c0022036:	e9 e0 fa ff ff       	jmp    c0021b1b <intr_entry>

c002203b <intr7e_stub>:
c002203b:	55                   	push   %ebp
c002203c:	6a 00                	push   $0x0
c002203e:	6a 7e                	push   $0x7e
c0022040:	e9 d6 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022045 <intr7f_stub>:
c0022045:	55                   	push   %ebp
c0022046:	6a 00                	push   $0x0
c0022048:	6a 7f                	push   $0x7f
c002204a:	e9 cc fa ff ff       	jmp    c0021b1b <intr_entry>

c002204f <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c002204f:	55                   	push   %ebp
c0022050:	6a 00                	push   $0x0
c0022052:	68 80 00 00 00       	push   $0x80
c0022057:	e9 bf fa ff ff       	jmp    c0021b1b <intr_entry>

c002205c <intr81_stub>:
c002205c:	55                   	push   %ebp
c002205d:	6a 00                	push   $0x0
c002205f:	68 81 00 00 00       	push   $0x81
c0022064:	e9 b2 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022069 <intr82_stub>:
c0022069:	55                   	push   %ebp
c002206a:	6a 00                	push   $0x0
c002206c:	68 82 00 00 00       	push   $0x82
c0022071:	e9 a5 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022076 <intr83_stub>:
c0022076:	55                   	push   %ebp
c0022077:	6a 00                	push   $0x0
c0022079:	68 83 00 00 00       	push   $0x83
c002207e:	e9 98 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022083 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022083:	55                   	push   %ebp
c0022084:	6a 00                	push   $0x0
c0022086:	68 84 00 00 00       	push   $0x84
c002208b:	e9 8b fa ff ff       	jmp    c0021b1b <intr_entry>

c0022090 <intr85_stub>:
c0022090:	55                   	push   %ebp
c0022091:	6a 00                	push   $0x0
c0022093:	68 85 00 00 00       	push   $0x85
c0022098:	e9 7e fa ff ff       	jmp    c0021b1b <intr_entry>

c002209d <intr86_stub>:
c002209d:	55                   	push   %ebp
c002209e:	6a 00                	push   $0x0
c00220a0:	68 86 00 00 00       	push   $0x86
c00220a5:	e9 71 fa ff ff       	jmp    c0021b1b <intr_entry>

c00220aa <intr87_stub>:
c00220aa:	55                   	push   %ebp
c00220ab:	6a 00                	push   $0x0
c00220ad:	68 87 00 00 00       	push   $0x87
c00220b2:	e9 64 fa ff ff       	jmp    c0021b1b <intr_entry>

c00220b7 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c00220b7:	55                   	push   %ebp
c00220b8:	6a 00                	push   $0x0
c00220ba:	68 88 00 00 00       	push   $0x88
c00220bf:	e9 57 fa ff ff       	jmp    c0021b1b <intr_entry>

c00220c4 <intr89_stub>:
c00220c4:	55                   	push   %ebp
c00220c5:	6a 00                	push   $0x0
c00220c7:	68 89 00 00 00       	push   $0x89
c00220cc:	e9 4a fa ff ff       	jmp    c0021b1b <intr_entry>

c00220d1 <intr8a_stub>:
c00220d1:	55                   	push   %ebp
c00220d2:	6a 00                	push   $0x0
c00220d4:	68 8a 00 00 00       	push   $0x8a
c00220d9:	e9 3d fa ff ff       	jmp    c0021b1b <intr_entry>

c00220de <intr8b_stub>:
c00220de:	55                   	push   %ebp
c00220df:	6a 00                	push   $0x0
c00220e1:	68 8b 00 00 00       	push   $0x8b
c00220e6:	e9 30 fa ff ff       	jmp    c0021b1b <intr_entry>

c00220eb <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00220eb:	55                   	push   %ebp
c00220ec:	6a 00                	push   $0x0
c00220ee:	68 8c 00 00 00       	push   $0x8c
c00220f3:	e9 23 fa ff ff       	jmp    c0021b1b <intr_entry>

c00220f8 <intr8d_stub>:
c00220f8:	55                   	push   %ebp
c00220f9:	6a 00                	push   $0x0
c00220fb:	68 8d 00 00 00       	push   $0x8d
c0022100:	e9 16 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022105 <intr8e_stub>:
c0022105:	55                   	push   %ebp
c0022106:	6a 00                	push   $0x0
c0022108:	68 8e 00 00 00       	push   $0x8e
c002210d:	e9 09 fa ff ff       	jmp    c0021b1b <intr_entry>

c0022112 <intr8f_stub>:
c0022112:	55                   	push   %ebp
c0022113:	6a 00                	push   $0x0
c0022115:	68 8f 00 00 00       	push   $0x8f
c002211a:	e9 fc f9 ff ff       	jmp    c0021b1b <intr_entry>

c002211f <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c002211f:	55                   	push   %ebp
c0022120:	6a 00                	push   $0x0
c0022122:	68 90 00 00 00       	push   $0x90
c0022127:	e9 ef f9 ff ff       	jmp    c0021b1b <intr_entry>

c002212c <intr91_stub>:
c002212c:	55                   	push   %ebp
c002212d:	6a 00                	push   $0x0
c002212f:	68 91 00 00 00       	push   $0x91
c0022134:	e9 e2 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022139 <intr92_stub>:
c0022139:	55                   	push   %ebp
c002213a:	6a 00                	push   $0x0
c002213c:	68 92 00 00 00       	push   $0x92
c0022141:	e9 d5 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022146 <intr93_stub>:
c0022146:	55                   	push   %ebp
c0022147:	6a 00                	push   $0x0
c0022149:	68 93 00 00 00       	push   $0x93
c002214e:	e9 c8 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022153 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022153:	55                   	push   %ebp
c0022154:	6a 00                	push   $0x0
c0022156:	68 94 00 00 00       	push   $0x94
c002215b:	e9 bb f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022160 <intr95_stub>:
c0022160:	55                   	push   %ebp
c0022161:	6a 00                	push   $0x0
c0022163:	68 95 00 00 00       	push   $0x95
c0022168:	e9 ae f9 ff ff       	jmp    c0021b1b <intr_entry>

c002216d <intr96_stub>:
c002216d:	55                   	push   %ebp
c002216e:	6a 00                	push   $0x0
c0022170:	68 96 00 00 00       	push   $0x96
c0022175:	e9 a1 f9 ff ff       	jmp    c0021b1b <intr_entry>

c002217a <intr97_stub>:
c002217a:	55                   	push   %ebp
c002217b:	6a 00                	push   $0x0
c002217d:	68 97 00 00 00       	push   $0x97
c0022182:	e9 94 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022187 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022187:	55                   	push   %ebp
c0022188:	6a 00                	push   $0x0
c002218a:	68 98 00 00 00       	push   $0x98
c002218f:	e9 87 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022194 <intr99_stub>:
c0022194:	55                   	push   %ebp
c0022195:	6a 00                	push   $0x0
c0022197:	68 99 00 00 00       	push   $0x99
c002219c:	e9 7a f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221a1 <intr9a_stub>:
c00221a1:	55                   	push   %ebp
c00221a2:	6a 00                	push   $0x0
c00221a4:	68 9a 00 00 00       	push   $0x9a
c00221a9:	e9 6d f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221ae <intr9b_stub>:
c00221ae:	55                   	push   %ebp
c00221af:	6a 00                	push   $0x0
c00221b1:	68 9b 00 00 00       	push   $0x9b
c00221b6:	e9 60 f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221bb <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c00221bb:	55                   	push   %ebp
c00221bc:	6a 00                	push   $0x0
c00221be:	68 9c 00 00 00       	push   $0x9c
c00221c3:	e9 53 f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221c8 <intr9d_stub>:
c00221c8:	55                   	push   %ebp
c00221c9:	6a 00                	push   $0x0
c00221cb:	68 9d 00 00 00       	push   $0x9d
c00221d0:	e9 46 f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221d5 <intr9e_stub>:
c00221d5:	55                   	push   %ebp
c00221d6:	6a 00                	push   $0x0
c00221d8:	68 9e 00 00 00       	push   $0x9e
c00221dd:	e9 39 f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221e2 <intr9f_stub>:
c00221e2:	55                   	push   %ebp
c00221e3:	6a 00                	push   $0x0
c00221e5:	68 9f 00 00 00       	push   $0x9f
c00221ea:	e9 2c f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221ef <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00221ef:	55                   	push   %ebp
c00221f0:	6a 00                	push   $0x0
c00221f2:	68 a0 00 00 00       	push   $0xa0
c00221f7:	e9 1f f9 ff ff       	jmp    c0021b1b <intr_entry>

c00221fc <intra1_stub>:
c00221fc:	55                   	push   %ebp
c00221fd:	6a 00                	push   $0x0
c00221ff:	68 a1 00 00 00       	push   $0xa1
c0022204:	e9 12 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022209 <intra2_stub>:
c0022209:	55                   	push   %ebp
c002220a:	6a 00                	push   $0x0
c002220c:	68 a2 00 00 00       	push   $0xa2
c0022211:	e9 05 f9 ff ff       	jmp    c0021b1b <intr_entry>

c0022216 <intra3_stub>:
c0022216:	55                   	push   %ebp
c0022217:	6a 00                	push   $0x0
c0022219:	68 a3 00 00 00       	push   $0xa3
c002221e:	e9 f8 f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022223 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022223:	55                   	push   %ebp
c0022224:	6a 00                	push   $0x0
c0022226:	68 a4 00 00 00       	push   $0xa4
c002222b:	e9 eb f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022230 <intra5_stub>:
c0022230:	55                   	push   %ebp
c0022231:	6a 00                	push   $0x0
c0022233:	68 a5 00 00 00       	push   $0xa5
c0022238:	e9 de f8 ff ff       	jmp    c0021b1b <intr_entry>

c002223d <intra6_stub>:
c002223d:	55                   	push   %ebp
c002223e:	6a 00                	push   $0x0
c0022240:	68 a6 00 00 00       	push   $0xa6
c0022245:	e9 d1 f8 ff ff       	jmp    c0021b1b <intr_entry>

c002224a <intra7_stub>:
c002224a:	55                   	push   %ebp
c002224b:	6a 00                	push   $0x0
c002224d:	68 a7 00 00 00       	push   $0xa7
c0022252:	e9 c4 f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022257 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022257:	55                   	push   %ebp
c0022258:	6a 00                	push   $0x0
c002225a:	68 a8 00 00 00       	push   $0xa8
c002225f:	e9 b7 f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022264 <intra9_stub>:
c0022264:	55                   	push   %ebp
c0022265:	6a 00                	push   $0x0
c0022267:	68 a9 00 00 00       	push   $0xa9
c002226c:	e9 aa f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022271 <intraa_stub>:
c0022271:	55                   	push   %ebp
c0022272:	6a 00                	push   $0x0
c0022274:	68 aa 00 00 00       	push   $0xaa
c0022279:	e9 9d f8 ff ff       	jmp    c0021b1b <intr_entry>

c002227e <intrab_stub>:
c002227e:	55                   	push   %ebp
c002227f:	6a 00                	push   $0x0
c0022281:	68 ab 00 00 00       	push   $0xab
c0022286:	e9 90 f8 ff ff       	jmp    c0021b1b <intr_entry>

c002228b <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c002228b:	55                   	push   %ebp
c002228c:	6a 00                	push   $0x0
c002228e:	68 ac 00 00 00       	push   $0xac
c0022293:	e9 83 f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022298 <intrad_stub>:
c0022298:	55                   	push   %ebp
c0022299:	6a 00                	push   $0x0
c002229b:	68 ad 00 00 00       	push   $0xad
c00222a0:	e9 76 f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222a5 <intrae_stub>:
c00222a5:	55                   	push   %ebp
c00222a6:	6a 00                	push   $0x0
c00222a8:	68 ae 00 00 00       	push   $0xae
c00222ad:	e9 69 f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222b2 <intraf_stub>:
c00222b2:	55                   	push   %ebp
c00222b3:	6a 00                	push   $0x0
c00222b5:	68 af 00 00 00       	push   $0xaf
c00222ba:	e9 5c f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222bf <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c00222bf:	55                   	push   %ebp
c00222c0:	6a 00                	push   $0x0
c00222c2:	68 b0 00 00 00       	push   $0xb0
c00222c7:	e9 4f f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222cc <intrb1_stub>:
c00222cc:	55                   	push   %ebp
c00222cd:	6a 00                	push   $0x0
c00222cf:	68 b1 00 00 00       	push   $0xb1
c00222d4:	e9 42 f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222d9 <intrb2_stub>:
c00222d9:	55                   	push   %ebp
c00222da:	6a 00                	push   $0x0
c00222dc:	68 b2 00 00 00       	push   $0xb2
c00222e1:	e9 35 f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222e6 <intrb3_stub>:
c00222e6:	55                   	push   %ebp
c00222e7:	6a 00                	push   $0x0
c00222e9:	68 b3 00 00 00       	push   $0xb3
c00222ee:	e9 28 f8 ff ff       	jmp    c0021b1b <intr_entry>

c00222f3 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00222f3:	55                   	push   %ebp
c00222f4:	6a 00                	push   $0x0
c00222f6:	68 b4 00 00 00       	push   $0xb4
c00222fb:	e9 1b f8 ff ff       	jmp    c0021b1b <intr_entry>

c0022300 <intrb5_stub>:
c0022300:	55                   	push   %ebp
c0022301:	6a 00                	push   $0x0
c0022303:	68 b5 00 00 00       	push   $0xb5
c0022308:	e9 0e f8 ff ff       	jmp    c0021b1b <intr_entry>

c002230d <intrb6_stub>:
c002230d:	55                   	push   %ebp
c002230e:	6a 00                	push   $0x0
c0022310:	68 b6 00 00 00       	push   $0xb6
c0022315:	e9 01 f8 ff ff       	jmp    c0021b1b <intr_entry>

c002231a <intrb7_stub>:
c002231a:	55                   	push   %ebp
c002231b:	6a 00                	push   $0x0
c002231d:	68 b7 00 00 00       	push   $0xb7
c0022322:	e9 f4 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022327 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022327:	55                   	push   %ebp
c0022328:	6a 00                	push   $0x0
c002232a:	68 b8 00 00 00       	push   $0xb8
c002232f:	e9 e7 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022334 <intrb9_stub>:
c0022334:	55                   	push   %ebp
c0022335:	6a 00                	push   $0x0
c0022337:	68 b9 00 00 00       	push   $0xb9
c002233c:	e9 da f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022341 <intrba_stub>:
c0022341:	55                   	push   %ebp
c0022342:	6a 00                	push   $0x0
c0022344:	68 ba 00 00 00       	push   $0xba
c0022349:	e9 cd f7 ff ff       	jmp    c0021b1b <intr_entry>

c002234e <intrbb_stub>:
c002234e:	55                   	push   %ebp
c002234f:	6a 00                	push   $0x0
c0022351:	68 bb 00 00 00       	push   $0xbb
c0022356:	e9 c0 f7 ff ff       	jmp    c0021b1b <intr_entry>

c002235b <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c002235b:	55                   	push   %ebp
c002235c:	6a 00                	push   $0x0
c002235e:	68 bc 00 00 00       	push   $0xbc
c0022363:	e9 b3 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022368 <intrbd_stub>:
c0022368:	55                   	push   %ebp
c0022369:	6a 00                	push   $0x0
c002236b:	68 bd 00 00 00       	push   $0xbd
c0022370:	e9 a6 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022375 <intrbe_stub>:
c0022375:	55                   	push   %ebp
c0022376:	6a 00                	push   $0x0
c0022378:	68 be 00 00 00       	push   $0xbe
c002237d:	e9 99 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022382 <intrbf_stub>:
c0022382:	55                   	push   %ebp
c0022383:	6a 00                	push   $0x0
c0022385:	68 bf 00 00 00       	push   $0xbf
c002238a:	e9 8c f7 ff ff       	jmp    c0021b1b <intr_entry>

c002238f <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c002238f:	55                   	push   %ebp
c0022390:	6a 00                	push   $0x0
c0022392:	68 c0 00 00 00       	push   $0xc0
c0022397:	e9 7f f7 ff ff       	jmp    c0021b1b <intr_entry>

c002239c <intrc1_stub>:
c002239c:	55                   	push   %ebp
c002239d:	6a 00                	push   $0x0
c002239f:	68 c1 00 00 00       	push   $0xc1
c00223a4:	e9 72 f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223a9 <intrc2_stub>:
c00223a9:	55                   	push   %ebp
c00223aa:	6a 00                	push   $0x0
c00223ac:	68 c2 00 00 00       	push   $0xc2
c00223b1:	e9 65 f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223b6 <intrc3_stub>:
c00223b6:	55                   	push   %ebp
c00223b7:	6a 00                	push   $0x0
c00223b9:	68 c3 00 00 00       	push   $0xc3
c00223be:	e9 58 f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223c3 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c00223c3:	55                   	push   %ebp
c00223c4:	6a 00                	push   $0x0
c00223c6:	68 c4 00 00 00       	push   $0xc4
c00223cb:	e9 4b f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223d0 <intrc5_stub>:
c00223d0:	55                   	push   %ebp
c00223d1:	6a 00                	push   $0x0
c00223d3:	68 c5 00 00 00       	push   $0xc5
c00223d8:	e9 3e f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223dd <intrc6_stub>:
c00223dd:	55                   	push   %ebp
c00223de:	6a 00                	push   $0x0
c00223e0:	68 c6 00 00 00       	push   $0xc6
c00223e5:	e9 31 f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223ea <intrc7_stub>:
c00223ea:	55                   	push   %ebp
c00223eb:	6a 00                	push   $0x0
c00223ed:	68 c7 00 00 00       	push   $0xc7
c00223f2:	e9 24 f7 ff ff       	jmp    c0021b1b <intr_entry>

c00223f7 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00223f7:	55                   	push   %ebp
c00223f8:	6a 00                	push   $0x0
c00223fa:	68 c8 00 00 00       	push   $0xc8
c00223ff:	e9 17 f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022404 <intrc9_stub>:
c0022404:	55                   	push   %ebp
c0022405:	6a 00                	push   $0x0
c0022407:	68 c9 00 00 00       	push   $0xc9
c002240c:	e9 0a f7 ff ff       	jmp    c0021b1b <intr_entry>

c0022411 <intrca_stub>:
c0022411:	55                   	push   %ebp
c0022412:	6a 00                	push   $0x0
c0022414:	68 ca 00 00 00       	push   $0xca
c0022419:	e9 fd f6 ff ff       	jmp    c0021b1b <intr_entry>

c002241e <intrcb_stub>:
c002241e:	55                   	push   %ebp
c002241f:	6a 00                	push   $0x0
c0022421:	68 cb 00 00 00       	push   $0xcb
c0022426:	e9 f0 f6 ff ff       	jmp    c0021b1b <intr_entry>

c002242b <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c002242b:	55                   	push   %ebp
c002242c:	6a 00                	push   $0x0
c002242e:	68 cc 00 00 00       	push   $0xcc
c0022433:	e9 e3 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022438 <intrcd_stub>:
c0022438:	55                   	push   %ebp
c0022439:	6a 00                	push   $0x0
c002243b:	68 cd 00 00 00       	push   $0xcd
c0022440:	e9 d6 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022445 <intrce_stub>:
c0022445:	55                   	push   %ebp
c0022446:	6a 00                	push   $0x0
c0022448:	68 ce 00 00 00       	push   $0xce
c002244d:	e9 c9 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022452 <intrcf_stub>:
c0022452:	55                   	push   %ebp
c0022453:	6a 00                	push   $0x0
c0022455:	68 cf 00 00 00       	push   $0xcf
c002245a:	e9 bc f6 ff ff       	jmp    c0021b1b <intr_entry>

c002245f <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c002245f:	55                   	push   %ebp
c0022460:	6a 00                	push   $0x0
c0022462:	68 d0 00 00 00       	push   $0xd0
c0022467:	e9 af f6 ff ff       	jmp    c0021b1b <intr_entry>

c002246c <intrd1_stub>:
c002246c:	55                   	push   %ebp
c002246d:	6a 00                	push   $0x0
c002246f:	68 d1 00 00 00       	push   $0xd1
c0022474:	e9 a2 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022479 <intrd2_stub>:
c0022479:	55                   	push   %ebp
c002247a:	6a 00                	push   $0x0
c002247c:	68 d2 00 00 00       	push   $0xd2
c0022481:	e9 95 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022486 <intrd3_stub>:
c0022486:	55                   	push   %ebp
c0022487:	6a 00                	push   $0x0
c0022489:	68 d3 00 00 00       	push   $0xd3
c002248e:	e9 88 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022493 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022493:	55                   	push   %ebp
c0022494:	6a 00                	push   $0x0
c0022496:	68 d4 00 00 00       	push   $0xd4
c002249b:	e9 7b f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224a0 <intrd5_stub>:
c00224a0:	55                   	push   %ebp
c00224a1:	6a 00                	push   $0x0
c00224a3:	68 d5 00 00 00       	push   $0xd5
c00224a8:	e9 6e f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224ad <intrd6_stub>:
c00224ad:	55                   	push   %ebp
c00224ae:	6a 00                	push   $0x0
c00224b0:	68 d6 00 00 00       	push   $0xd6
c00224b5:	e9 61 f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224ba <intrd7_stub>:
c00224ba:	55                   	push   %ebp
c00224bb:	6a 00                	push   $0x0
c00224bd:	68 d7 00 00 00       	push   $0xd7
c00224c2:	e9 54 f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224c7 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c00224c7:	55                   	push   %ebp
c00224c8:	6a 00                	push   $0x0
c00224ca:	68 d8 00 00 00       	push   $0xd8
c00224cf:	e9 47 f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224d4 <intrd9_stub>:
c00224d4:	55                   	push   %ebp
c00224d5:	6a 00                	push   $0x0
c00224d7:	68 d9 00 00 00       	push   $0xd9
c00224dc:	e9 3a f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224e1 <intrda_stub>:
c00224e1:	55                   	push   %ebp
c00224e2:	6a 00                	push   $0x0
c00224e4:	68 da 00 00 00       	push   $0xda
c00224e9:	e9 2d f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224ee <intrdb_stub>:
c00224ee:	55                   	push   %ebp
c00224ef:	6a 00                	push   $0x0
c00224f1:	68 db 00 00 00       	push   $0xdb
c00224f6:	e9 20 f6 ff ff       	jmp    c0021b1b <intr_entry>

c00224fb <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c00224fb:	55                   	push   %ebp
c00224fc:	6a 00                	push   $0x0
c00224fe:	68 dc 00 00 00       	push   $0xdc
c0022503:	e9 13 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022508 <intrdd_stub>:
c0022508:	55                   	push   %ebp
c0022509:	6a 00                	push   $0x0
c002250b:	68 dd 00 00 00       	push   $0xdd
c0022510:	e9 06 f6 ff ff       	jmp    c0021b1b <intr_entry>

c0022515 <intrde_stub>:
c0022515:	55                   	push   %ebp
c0022516:	6a 00                	push   $0x0
c0022518:	68 de 00 00 00       	push   $0xde
c002251d:	e9 f9 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022522 <intrdf_stub>:
c0022522:	55                   	push   %ebp
c0022523:	6a 00                	push   $0x0
c0022525:	68 df 00 00 00       	push   $0xdf
c002252a:	e9 ec f5 ff ff       	jmp    c0021b1b <intr_entry>

c002252f <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c002252f:	55                   	push   %ebp
c0022530:	6a 00                	push   $0x0
c0022532:	68 e0 00 00 00       	push   $0xe0
c0022537:	e9 df f5 ff ff       	jmp    c0021b1b <intr_entry>

c002253c <intre1_stub>:
c002253c:	55                   	push   %ebp
c002253d:	6a 00                	push   $0x0
c002253f:	68 e1 00 00 00       	push   $0xe1
c0022544:	e9 d2 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022549 <intre2_stub>:
c0022549:	55                   	push   %ebp
c002254a:	6a 00                	push   $0x0
c002254c:	68 e2 00 00 00       	push   $0xe2
c0022551:	e9 c5 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022556 <intre3_stub>:
c0022556:	55                   	push   %ebp
c0022557:	6a 00                	push   $0x0
c0022559:	68 e3 00 00 00       	push   $0xe3
c002255e:	e9 b8 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022563 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022563:	55                   	push   %ebp
c0022564:	6a 00                	push   $0x0
c0022566:	68 e4 00 00 00       	push   $0xe4
c002256b:	e9 ab f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022570 <intre5_stub>:
c0022570:	55                   	push   %ebp
c0022571:	6a 00                	push   $0x0
c0022573:	68 e5 00 00 00       	push   $0xe5
c0022578:	e9 9e f5 ff ff       	jmp    c0021b1b <intr_entry>

c002257d <intre6_stub>:
c002257d:	55                   	push   %ebp
c002257e:	6a 00                	push   $0x0
c0022580:	68 e6 00 00 00       	push   $0xe6
c0022585:	e9 91 f5 ff ff       	jmp    c0021b1b <intr_entry>

c002258a <intre7_stub>:
c002258a:	55                   	push   %ebp
c002258b:	6a 00                	push   $0x0
c002258d:	68 e7 00 00 00       	push   $0xe7
c0022592:	e9 84 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022597 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022597:	55                   	push   %ebp
c0022598:	6a 00                	push   $0x0
c002259a:	68 e8 00 00 00       	push   $0xe8
c002259f:	e9 77 f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225a4 <intre9_stub>:
c00225a4:	55                   	push   %ebp
c00225a5:	6a 00                	push   $0x0
c00225a7:	68 e9 00 00 00       	push   $0xe9
c00225ac:	e9 6a f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225b1 <intrea_stub>:
c00225b1:	55                   	push   %ebp
c00225b2:	6a 00                	push   $0x0
c00225b4:	68 ea 00 00 00       	push   $0xea
c00225b9:	e9 5d f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225be <intreb_stub>:
c00225be:	55                   	push   %ebp
c00225bf:	6a 00                	push   $0x0
c00225c1:	68 eb 00 00 00       	push   $0xeb
c00225c6:	e9 50 f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225cb <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c00225cb:	55                   	push   %ebp
c00225cc:	6a 00                	push   $0x0
c00225ce:	68 ec 00 00 00       	push   $0xec
c00225d3:	e9 43 f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225d8 <intred_stub>:
c00225d8:	55                   	push   %ebp
c00225d9:	6a 00                	push   $0x0
c00225db:	68 ed 00 00 00       	push   $0xed
c00225e0:	e9 36 f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225e5 <intree_stub>:
c00225e5:	55                   	push   %ebp
c00225e6:	6a 00                	push   $0x0
c00225e8:	68 ee 00 00 00       	push   $0xee
c00225ed:	e9 29 f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225f2 <intref_stub>:
c00225f2:	55                   	push   %ebp
c00225f3:	6a 00                	push   $0x0
c00225f5:	68 ef 00 00 00       	push   $0xef
c00225fa:	e9 1c f5 ff ff       	jmp    c0021b1b <intr_entry>

c00225ff <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c00225ff:	55                   	push   %ebp
c0022600:	6a 00                	push   $0x0
c0022602:	68 f0 00 00 00       	push   $0xf0
c0022607:	e9 0f f5 ff ff       	jmp    c0021b1b <intr_entry>

c002260c <intrf1_stub>:
c002260c:	55                   	push   %ebp
c002260d:	6a 00                	push   $0x0
c002260f:	68 f1 00 00 00       	push   $0xf1
c0022614:	e9 02 f5 ff ff       	jmp    c0021b1b <intr_entry>

c0022619 <intrf2_stub>:
c0022619:	55                   	push   %ebp
c002261a:	6a 00                	push   $0x0
c002261c:	68 f2 00 00 00       	push   $0xf2
c0022621:	e9 f5 f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022626 <intrf3_stub>:
c0022626:	55                   	push   %ebp
c0022627:	6a 00                	push   $0x0
c0022629:	68 f3 00 00 00       	push   $0xf3
c002262e:	e9 e8 f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022633 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022633:	55                   	push   %ebp
c0022634:	6a 00                	push   $0x0
c0022636:	68 f4 00 00 00       	push   $0xf4
c002263b:	e9 db f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022640 <intrf5_stub>:
c0022640:	55                   	push   %ebp
c0022641:	6a 00                	push   $0x0
c0022643:	68 f5 00 00 00       	push   $0xf5
c0022648:	e9 ce f4 ff ff       	jmp    c0021b1b <intr_entry>

c002264d <intrf6_stub>:
c002264d:	55                   	push   %ebp
c002264e:	6a 00                	push   $0x0
c0022650:	68 f6 00 00 00       	push   $0xf6
c0022655:	e9 c1 f4 ff ff       	jmp    c0021b1b <intr_entry>

c002265a <intrf7_stub>:
c002265a:	55                   	push   %ebp
c002265b:	6a 00                	push   $0x0
c002265d:	68 f7 00 00 00       	push   $0xf7
c0022662:	e9 b4 f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022667 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022667:	55                   	push   %ebp
c0022668:	6a 00                	push   $0x0
c002266a:	68 f8 00 00 00       	push   $0xf8
c002266f:	e9 a7 f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022674 <intrf9_stub>:
c0022674:	55                   	push   %ebp
c0022675:	6a 00                	push   $0x0
c0022677:	68 f9 00 00 00       	push   $0xf9
c002267c:	e9 9a f4 ff ff       	jmp    c0021b1b <intr_entry>

c0022681 <intrfa_stub>:
c0022681:	55                   	push   %ebp
c0022682:	6a 00                	push   $0x0
c0022684:	68 fa 00 00 00       	push   $0xfa
c0022689:	e9 8d f4 ff ff       	jmp    c0021b1b <intr_entry>

c002268e <intrfb_stub>:
c002268e:	55                   	push   %ebp
c002268f:	6a 00                	push   $0x0
c0022691:	68 fb 00 00 00       	push   $0xfb
c0022696:	e9 80 f4 ff ff       	jmp    c0021b1b <intr_entry>

c002269b <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c002269b:	55                   	push   %ebp
c002269c:	6a 00                	push   $0x0
c002269e:	68 fc 00 00 00       	push   $0xfc
c00226a3:	e9 73 f4 ff ff       	jmp    c0021b1b <intr_entry>

c00226a8 <intrfd_stub>:
c00226a8:	55                   	push   %ebp
c00226a9:	6a 00                	push   $0x0
c00226ab:	68 fd 00 00 00       	push   $0xfd
c00226b0:	e9 66 f4 ff ff       	jmp    c0021b1b <intr_entry>

c00226b5 <intrfe_stub>:
c00226b5:	55                   	push   %ebp
c00226b6:	6a 00                	push   $0x0
c00226b8:	68 fe 00 00 00       	push   $0xfe
c00226bd:	e9 59 f4 ff ff       	jmp    c0021b1b <intr_entry>

c00226c2 <intrff_stub>:
c00226c2:	55                   	push   %ebp
c00226c3:	6a 00                	push   $0x0
c00226c5:	68 ff 00 00 00       	push   $0xff
c00226ca:	e9 4c f4 ff ff       	jmp    c0021b1b <intr_entry>

c00226cf <priority_less_cond>:
  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
}

bool priority_less_cond(const struct list_elem *e1,const struct list_elem *e2,void *aux){
  return list_entry(e1,struct semaphore_elem,elem)->owner->priority > list_entry(e2,struct semaphore_elem,elem)->owner->priority;
c00226cf:	8b 44 24 04          	mov    0x4(%esp),%eax
c00226d3:	8b 50 1c             	mov    0x1c(%eax),%edx
c00226d6:	8b 44 24 08          	mov    0x8(%esp),%eax
c00226da:	8b 40 1c             	mov    0x1c(%eax),%eax
c00226dd:	8b 40 1c             	mov    0x1c(%eax),%eax
c00226e0:	39 42 1c             	cmp    %eax,0x1c(%edx)
c00226e3:	0f 9f c0             	setg   %al
}
c00226e6:	c3                   	ret    

c00226e7 <sema_init>:
     decrement it.
   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c00226e7:	83 ec 0c             	sub    $0xc,%esp
c00226ea:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (sema != NULL);
c00226ee:	85 c0                	test   %eax,%eax
c00226f0:	75 1e                	jne    c0022710 <sema_init+0x29>
c00226f2:	83 ec 0c             	sub    $0xc,%esp
c00226f5:	68 8a da 02 c0       	push   $0xc002da8a
c00226fa:	68 3f d2 02 c0       	push   $0xc002d23f
c00226ff:	68 28 bd 02 c0       	push   $0xc002bd28
c0022704:	6a 2a                	push   $0x2a
c0022706:	68 97 da 02 c0       	push   $0xc002da97
c002270b:	e8 bd 55 00 00       	call   c0027ccd <debug_panic>

  sema->value = value;
c0022710:	8b 54 24 14          	mov    0x14(%esp),%edx
c0022714:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022716:	83 ec 0c             	sub    $0xc,%esp
c0022719:	83 c0 04             	add    $0x4,%eax
c002271c:	50                   	push   %eax
c002271d:	e8 52 56 00 00       	call   c0027d74 <list_init>
}
c0022722:	83 c4 1c             	add    $0x1c,%esp
c0022725:	c3                   	ret    

c0022726 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022726:	57                   	push   %edi
c0022727:	56                   	push   %esi
c0022728:	53                   	push   %ebx
c0022729:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c002272d:	85 db                	test   %ebx,%ebx
c002272f:	75 1e                	jne    c002274f <sema_down+0x29>
c0022731:	83 ec 0c             	sub    $0xc,%esp
c0022734:	68 8a da 02 c0       	push   $0xc002da8a
c0022739:	68 3f d2 02 c0       	push   $0xc002d23f
c002273e:	68 1c bd 02 c0       	push   $0xc002bd1c
c0022743:	6a 3b                	push   $0x3b
c0022745:	68 97 da 02 c0       	push   $0xc002da97
c002274a:	e8 7e 55 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!intr_context ());
c002274f:	e8 7b f1 ff ff       	call   c00218cf <intr_context>
c0022754:	84 c0                	test   %al,%al
c0022756:	74 1e                	je     c0022776 <sema_down+0x50>
c0022758:	83 ec 0c             	sub    $0xc,%esp
c002275b:	68 2a d6 02 c0       	push   $0xc002d62a
c0022760:	68 3f d2 02 c0       	push   $0xc002d23f
c0022765:	68 1c bd 02 c0       	push   $0xc002bd1c
c002276a:	6a 3c                	push   $0x3c
c002276c:	68 97 da 02 c0       	push   $0xc002da97
c0022771:	e8 57 55 00 00       	call   c0027ccd <debug_panic>

  old_level = intr_disable ();
c0022776:	e8 15 ef ff ff       	call   c0021690 <intr_disable>
c002277b:	89 c7                	mov    %eax,%edi
  while (sema->value == 0) 
c002277d:	8b 03                	mov    (%ebx),%eax
c002277f:	85 c0                	test   %eax,%eax
c0022781:	75 23                	jne    c00227a6 <sema_down+0x80>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022783:	8d 73 04             	lea    0x4(%ebx),%esi
c0022786:	e8 4f e2 ff ff       	call   c00209da <thread_current>
c002278b:	83 ec 08             	sub    $0x8,%esp
c002278e:	83 c0 50             	add    $0x50,%eax
c0022791:	50                   	push   %eax
c0022792:	56                   	push   %esi
c0022793:	e8 80 5a 00 00       	call   c0028218 <list_push_back>
      thread_block ();
c0022798:	e8 69 e8 ff ff       	call   c0021006 <thread_block>

  ASSERT (sema != NULL);
  ASSERT (!intr_context ());

  old_level = intr_disable ();
  while (sema->value == 0) 
c002279d:	8b 03                	mov    (%ebx),%eax
c002279f:	83 c4 10             	add    $0x10,%esp
c00227a2:	85 c0                	test   %eax,%eax
c00227a4:	74 e0                	je     c0022786 <sema_down+0x60>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
      thread_block ();
    }
  sema->value--;
c00227a6:	83 e8 01             	sub    $0x1,%eax
c00227a9:	89 03                	mov    %eax,(%ebx)
  intr_set_level (old_level);
c00227ab:	83 ec 0c             	sub    $0xc,%esp
c00227ae:	57                   	push   %edi
c00227af:	e8 e3 ee ff ff       	call   c0021697 <intr_set_level>
}
c00227b4:	83 c4 10             	add    $0x10,%esp
c00227b7:	5b                   	pop    %ebx
c00227b8:	5e                   	pop    %esi
c00227b9:	5f                   	pop    %edi
c00227ba:	c3                   	ret    

c00227bb <sema_try_down>:
   semaphore is not already 0.  Returns true if the semaphore is
   decremented, false otherwise.
   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c00227bb:	56                   	push   %esi
c00227bc:	53                   	push   %ebx
c00227bd:	83 ec 04             	sub    $0x4,%esp
c00227c0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c00227c4:	85 db                	test   %ebx,%ebx
c00227c6:	75 1e                	jne    c00227e6 <sema_try_down+0x2b>
c00227c8:	83 ec 0c             	sub    $0xc,%esp
c00227cb:	68 8a da 02 c0       	push   $0xc002da8a
c00227d0:	68 3f d2 02 c0       	push   $0xc002d23f
c00227d5:	68 0c bd 02 c0       	push   $0xc002bd0c
c00227da:	6a 52                	push   $0x52
c00227dc:	68 97 da 02 c0       	push   $0xc002da97
c00227e1:	e8 e7 54 00 00       	call   c0027ccd <debug_panic>

  old_level = intr_disable ();
c00227e6:	e8 a5 ee ff ff       	call   c0021690 <intr_disable>
  if (sema->value > 0) 
c00227eb:	8b 13                	mov    (%ebx),%edx
    {
      sema->value--;
      success = true; 
    }
  else
    success = false;
c00227ed:	be 00 00 00 00       	mov    $0x0,%esi
  bool success;

  ASSERT (sema != NULL);

  old_level = intr_disable ();
  if (sema->value > 0) 
c00227f2:	85 d2                	test   %edx,%edx
c00227f4:	74 0a                	je     c0022800 <sema_try_down+0x45>
    {
      sema->value--;
c00227f6:	83 ea 01             	sub    $0x1,%edx
c00227f9:	89 13                	mov    %edx,(%ebx)
      success = true; 
c00227fb:	be 01 00 00 00       	mov    $0x1,%esi
    }
  else
    success = false;
  intr_set_level (old_level);
c0022800:	83 ec 0c             	sub    $0xc,%esp
c0022803:	50                   	push   %eax
c0022804:	e8 8e ee ff ff       	call   c0021697 <intr_set_level>


  return success;
}
c0022809:	89 f0                	mov    %esi,%eax
c002280b:	83 c4 14             	add    $0x14,%esp
c002280e:	5b                   	pop    %ebx
c002280f:	5e                   	pop    %esi
c0022810:	c3                   	ret    

c0022811 <sema_up>:
/* Up or "V" operation on a semaphore.  Increments SEMA's value
   and wakes up one thread of those waiting for SEMA, if any.
   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022811:	57                   	push   %edi
c0022812:	56                   	push   %esi
c0022813:	53                   	push   %ebx
c0022814:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022818:	85 db                	test   %ebx,%ebx
c002281a:	75 1e                	jne    c002283a <sema_up+0x29>
c002281c:	83 ec 0c             	sub    $0xc,%esp
c002281f:	68 8a da 02 c0       	push   $0xc002da8a
c0022824:	68 3f d2 02 c0       	push   $0xc002d23f
c0022829:	68 04 bd 02 c0       	push   $0xc002bd04
c002282e:	6a 6a                	push   $0x6a
c0022830:	68 97 da 02 c0       	push   $0xc002da97
c0022835:	e8 93 54 00 00       	call   c0027ccd <debug_panic>

  old_level = intr_disable ();
c002283a:	e8 51 ee ff ff       	call   c0021690 <intr_disable>
c002283f:	89 c7                	mov    %eax,%edi
  if (!list_empty (&sema->waiters)) {
c0022841:	8d 73 04             	lea    0x4(%ebx),%esi
c0022844:	83 ec 0c             	sub    $0xc,%esp
c0022847:	56                   	push   %esi
c0022848:	e8 75 5a 00 00       	call   c00282c2 <list_empty>
c002284d:	83 c4 10             	add    $0x10,%esp
c0022850:	84 c0                	test   %al,%al
c0022852:	75 28                	jne    c002287c <sema_up+0x6b>
    struct list_elem *next_to_run = list_max(&sema->waiters,thread_cmp_priority_2,NULL);
c0022854:	83 ec 04             	sub    $0x4,%esp
c0022857:	6a 00                	push   $0x0
c0022859:	68 3e 14 02 c0       	push   $0xc002143e
c002285e:	56                   	push   %esi
c002285f:	e8 bf 5f 00 00       	call   c0028823 <list_max>
c0022864:	89 c6                	mov    %eax,%esi
    list_remove(next_to_run);
c0022866:	89 04 24             	mov    %eax,(%esp)
c0022869:	e8 c7 59 00 00       	call   c0028235 <list_remove>
    thread_unblock(list_entry(next_to_run,struct thread,elem));
c002286e:	83 ee 50             	sub    $0x50,%esi
c0022871:	89 34 24             	mov    %esi,(%esp)
c0022874:	e8 c9 e0 ff ff       	call   c0020942 <thread_unblock>
c0022879:	83 c4 10             	add    $0x10,%esp
  }
    //thread_unblock (list_entry (list_pop_front (&sema->waiters),struct thread, elem));
  sema->value++;
c002287c:	83 03 01             	addl   $0x1,(%ebx)
  intr_set_level (old_level);
c002287f:	83 ec 0c             	sub    $0xc,%esp
c0022882:	57                   	push   %edi
c0022883:	e8 0f ee ff ff       	call   c0021697 <intr_set_level>
  thread_yield();
c0022888:	e8 bc e8 ff ff       	call   c0021149 <thread_yield>
}
c002288d:	83 c4 10             	add    $0x10,%esp
c0022890:	5b                   	pop    %ebx
c0022891:	5e                   	pop    %esi
c0022892:	5f                   	pop    %edi
c0022893:	c3                   	ret    

c0022894 <sema_test_helper>:
}

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022894:	57                   	push   %edi
c0022895:	56                   	push   %esi
c0022896:	53                   	push   %ebx
c0022897:	8b 74 24 10          	mov    0x10(%esp),%esi
c002289b:	bb 0a 00 00 00       	mov    $0xa,%ebx
  int i;

  for (i = 0; i < 10; i++) 
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
c00228a0:	8d 7e 14             	lea    0x14(%esi),%edi
  struct semaphore *sema = sema_;
  int i;

  for (i = 0; i < 10; i++) 
    {
      sema_down (&sema[0]);
c00228a3:	83 ec 0c             	sub    $0xc,%esp
c00228a6:	56                   	push   %esi
c00228a7:	e8 7a fe ff ff       	call   c0022726 <sema_down>
      sema_up (&sema[1]);
c00228ac:	89 3c 24             	mov    %edi,(%esp)
c00228af:	e8 5d ff ff ff       	call   c0022811 <sema_up>
sema_test_helper (void *sema_) 
{
  struct semaphore *sema = sema_;
  int i;

  for (i = 0; i < 10; i++) 
c00228b4:	83 c4 10             	add    $0x10,%esp
c00228b7:	83 eb 01             	sub    $0x1,%ebx
c00228ba:	75 e7                	jne    c00228a3 <sema_test_helper+0xf>
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
    }
}
c00228bc:	5b                   	pop    %ebx
c00228bd:	5e                   	pop    %esi
c00228be:	5f                   	pop    %edi
c00228bf:	c3                   	ret    

c00228c0 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c00228c0:	57                   	push   %edi
c00228c1:	56                   	push   %esi
c00228c2:	53                   	push   %ebx
c00228c3:	83 ec 3c             	sub    $0x3c,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c00228c6:	68 ad da 02 c0       	push   $0xc002daad
c00228cb:	e8 85 37 00 00       	call   c0026055 <printf>
  sema_init (&sema[0], 0);
c00228d0:	83 c4 08             	add    $0x8,%esp
c00228d3:	6a 00                	push   $0x0
c00228d5:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c00228d9:	53                   	push   %ebx
c00228da:	e8 08 fe ff ff       	call   c00226e7 <sema_init>
  sema_init (&sema[1], 0);
c00228df:	83 c4 08             	add    $0x8,%esp
c00228e2:	6a 00                	push   $0x0
c00228e4:	8d 44 24 28          	lea    0x28(%esp),%eax
c00228e8:	50                   	push   %eax
c00228e9:	e8 f9 fd ff ff       	call   c00226e7 <sema_init>
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00228ee:	53                   	push   %ebx
c00228ef:	68 94 28 02 c0       	push   $0xc0022894
c00228f4:	6a 1f                	push   $0x1f
c00228f6:	68 c3 da 02 c0       	push   $0xc002dac3
c00228fb:	e8 c1 e8 ff ff       	call   c00211c1 <thread_create>
c0022900:	83 c4 20             	add    $0x20,%esp
c0022903:	bb 0a 00 00 00       	mov    $0xa,%ebx
  for (i = 0; i < 10; i++) 
    {
      sema_up (&sema[0]);
c0022908:	8d 7c 24 08          	lea    0x8(%esp),%edi
      sema_down (&sema[1]);
c002290c:	8d 74 24 1c          	lea    0x1c(%esp),%esi
  sema_init (&sema[0], 0);
  sema_init (&sema[1], 0);
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
  for (i = 0; i < 10; i++) 
    {
      sema_up (&sema[0]);
c0022910:	83 ec 0c             	sub    $0xc,%esp
c0022913:	57                   	push   %edi
c0022914:	e8 f8 fe ff ff       	call   c0022811 <sema_up>
      sema_down (&sema[1]);
c0022919:	89 34 24             	mov    %esi,(%esp)
c002291c:	e8 05 fe ff ff       	call   c0022726 <sema_down>

  printf ("Testing semaphores...");
  sema_init (&sema[0], 0);
  sema_init (&sema[1], 0);
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
  for (i = 0; i < 10; i++) 
c0022921:	83 c4 10             	add    $0x10,%esp
c0022924:	83 eb 01             	sub    $0x1,%ebx
c0022927:	75 e7                	jne    c0022910 <sema_self_test+0x50>
    {
      sema_up (&sema[0]);
      sema_down (&sema[1]);
    }
  printf ("done.\n");
c0022929:	83 ec 0c             	sub    $0xc,%esp
c002292c:	68 cd da 02 c0       	push   $0xc002dacd
c0022931:	e8 ce 6d 00 00       	call   c0029704 <puts>
}
c0022936:	83 c4 40             	add    $0x40,%esp
c0022939:	5b                   	pop    %ebx
c002293a:	5e                   	pop    %esi
c002293b:	5f                   	pop    %edi
c002293c:	c3                   	ret    

c002293d <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c002293d:	83 ec 0c             	sub    $0xc,%esp
c0022940:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022944:	85 c0                	test   %eax,%eax
c0022946:	75 21                	jne    c0022969 <lock_init+0x2c>
c0022948:	83 ec 0c             	sub    $0xc,%esp
c002294b:	68 d3 da 02 c0       	push   $0xc002dad3
c0022950:	68 3f d2 02 c0       	push   $0xc002d23f
c0022955:	68 f8 bc 02 c0       	push   $0xc002bcf8
c002295a:	68 ae 00 00 00       	push   $0xae
c002295f:	68 97 da 02 c0       	push   $0xc002da97
c0022964:	e8 64 53 00 00       	call   c0027ccd <debug_panic>

  lock->holder = NULL;
c0022969:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c002296f:	83 ec 08             	sub    $0x8,%esp
c0022972:	6a 01                	push   $0x1
c0022974:	83 c0 04             	add    $0x4,%eax
c0022977:	50                   	push   %eax
c0022978:	e8 6a fd ff ff       	call   c00226e7 <sema_init>
}
c002297d:	83 c4 1c             	add    $0x1c,%esp
c0022980:	c3                   	ret    

c0022981 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022981:	53                   	push   %ebx
c0022982:	83 ec 08             	sub    $0x8,%esp
c0022985:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (lock != NULL);
c0022989:	85 c0                	test   %eax,%eax
c002298b:	75 21                	jne    c00229ae <lock_held_by_current_thread+0x2d>
c002298d:	83 ec 0c             	sub    $0xc,%esp
c0022990:	68 d3 da 02 c0       	push   $0xc002dad3
c0022995:	68 3f d2 02 c0       	push   $0xc002d23f
c002299a:	68 a8 bc 02 c0       	push   $0xc002bca8
c002299f:	68 1c 01 00 00       	push   $0x11c
c00229a4:	68 97 da 02 c0       	push   $0xc002da97
c00229a9:	e8 1f 53 00 00       	call   c0027ccd <debug_panic>

  return lock->holder == thread_current ();
c00229ae:	8b 18                	mov    (%eax),%ebx
c00229b0:	e8 25 e0 ff ff       	call   c00209da <thread_current>
c00229b5:	39 c3                	cmp    %eax,%ebx
c00229b7:	0f 94 c0             	sete   %al
}
c00229ba:	83 c4 08             	add    $0x8,%esp
c00229bd:	5b                   	pop    %ebx
c00229be:	c3                   	ret    

c00229bf <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c00229bf:	56                   	push   %esi
c00229c0:	53                   	push   %ebx
c00229c1:	83 ec 04             	sub    $0x4,%esp
c00229c4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level;
  old_level = intr_disable();
c00229c8:	e8 c3 ec ff ff       	call   c0021690 <intr_disable>
  ASSERT (lock != NULL);
c00229cd:	85 db                	test   %ebx,%ebx
c00229cf:	75 21                	jne    c00229f2 <lock_acquire+0x33>
c00229d1:	83 ec 0c             	sub    $0xc,%esp
c00229d4:	68 d3 da 02 c0       	push   $0xc002dad3
c00229d9:	68 3f d2 02 c0       	push   $0xc002d23f
c00229de:	68 e8 bc 02 c0       	push   $0xc002bce8
c00229e3:	68 c0 00 00 00       	push   $0xc0
c00229e8:	68 97 da 02 c0       	push   $0xc002da97
c00229ed:	e8 db 52 00 00       	call   c0027ccd <debug_panic>
c00229f2:	89 c6                	mov    %eax,%esi
  ASSERT (!intr_context ());
c00229f4:	e8 d6 ee ff ff       	call   c00218cf <intr_context>
c00229f9:	84 c0                	test   %al,%al
c00229fb:	74 21                	je     c0022a1e <lock_acquire+0x5f>
c00229fd:	83 ec 0c             	sub    $0xc,%esp
c0022a00:	68 2a d6 02 c0       	push   $0xc002d62a
c0022a05:	68 3f d2 02 c0       	push   $0xc002d23f
c0022a0a:	68 e8 bc 02 c0       	push   $0xc002bce8
c0022a0f:	68 c1 00 00 00       	push   $0xc1
c0022a14:	68 97 da 02 c0       	push   $0xc002da97
c0022a19:	e8 af 52 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022a1e:	83 ec 0c             	sub    $0xc,%esp
c0022a21:	53                   	push   %ebx
c0022a22:	e8 5a ff ff ff       	call   c0022981 <lock_held_by_current_thread>
c0022a27:	83 c4 10             	add    $0x10,%esp
c0022a2a:	84 c0                	test   %al,%al
c0022a2c:	74 21                	je     c0022a4f <lock_acquire+0x90>
c0022a2e:	83 ec 0c             	sub    $0xc,%esp
c0022a31:	68 f0 da 02 c0       	push   $0xc002daf0
c0022a36:	68 3f d2 02 c0       	push   $0xc002d23f
c0022a3b:	68 e8 bc 02 c0       	push   $0xc002bce8
c0022a40:	68 c2 00 00 00       	push   $0xc2
c0022a45:	68 97 da 02 c0       	push   $0xc002da97
c0022a4a:	e8 7e 52 00 00       	call   c0027ccd <debug_panic>
  struct thread *current_thread = thread_current();
c0022a4f:	e8 86 df ff ff       	call   c00209da <thread_current>
  if(lock->holder!=NULL && current_thread->priority > lock->holder->priority && !thread_mlfqs){
c0022a54:	8b 13                	mov    (%ebx),%edx
c0022a56:	85 d2                	test   %edx,%edx
c0022a58:	74 24                	je     c0022a7e <lock_acquire+0xbf>
c0022a5a:	8b 4a 1c             	mov    0x1c(%edx),%ecx
c0022a5d:	39 48 1c             	cmp    %ecx,0x1c(%eax)
c0022a60:	7e 1c                	jle    c0022a7e <lock_acquire+0xbf>
c0022a62:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0022a69:	75 13                	jne    c0022a7e <lock_acquire+0xbf>
    current_thread->donate_thread = lock->holder;
c0022a6b:	89 50 40             	mov    %edx,0x40(%eax)
    while(current_thread->donate_thread !=NULL){
      current_thread->donate_thread->priority = current_thread->priority;
c0022a6e:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0022a71:	89 4a 1c             	mov    %ecx,0x1c(%edx)
      current_thread = current_thread->donate_thread;
c0022a74:	8b 40 40             	mov    0x40(%eax),%eax
  ASSERT (!intr_context ());
  ASSERT (!lock_held_by_current_thread (lock));
  struct thread *current_thread = thread_current();
  if(lock->holder!=NULL && current_thread->priority > lock->holder->priority && !thread_mlfqs){
    current_thread->donate_thread = lock->holder;
    while(current_thread->donate_thread !=NULL){
c0022a77:	8b 50 40             	mov    0x40(%eax),%edx
c0022a7a:	85 d2                	test   %edx,%edx
c0022a7c:	75 f0                	jne    c0022a6e <lock_acquire+0xaf>
      current_thread->donate_thread->priority = current_thread->priority;
      current_thread = current_thread->donate_thread;
    }
  }

  sema_down (&lock->semaphore);
c0022a7e:	83 ec 0c             	sub    $0xc,%esp
c0022a81:	8d 43 04             	lea    0x4(%ebx),%eax
c0022a84:	50                   	push   %eax
c0022a85:	e8 9c fc ff ff       	call   c0022726 <sema_down>
  lock->holder = thread_current ();
c0022a8a:	e8 4b df ff ff       	call   c00209da <thread_current>
c0022a8f:	89 03                	mov    %eax,(%ebx)
  list_push_back(&thread_current()->hold_locks,&lock->elem);
c0022a91:	e8 44 df ff ff       	call   c00209da <thread_current>
c0022a96:	83 c4 08             	add    $0x8,%esp
c0022a99:	83 c3 18             	add    $0x18,%ebx
c0022a9c:	53                   	push   %ebx
c0022a9d:	83 c0 30             	add    $0x30,%eax
c0022aa0:	50                   	push   %eax
c0022aa1:	e8 72 57 00 00       	call   c0028218 <list_push_back>
  intr_set_level(old_level);
c0022aa6:	89 34 24             	mov    %esi,(%esp)
c0022aa9:	e8 e9 eb ff ff       	call   c0021697 <intr_set_level>
}
c0022aae:	83 c4 14             	add    $0x14,%esp
c0022ab1:	5b                   	pop    %ebx
c0022ab2:	5e                   	pop    %esi
c0022ab3:	c3                   	ret    

c0022ab4 <lock_try_acquire>:
   thread.
   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022ab4:	56                   	push   %esi
c0022ab5:	53                   	push   %ebx
c0022ab6:	83 ec 04             	sub    $0x4,%esp
c0022ab9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  bool success;

  ASSERT (lock != NULL);
c0022abd:	85 db                	test   %ebx,%ebx
c0022abf:	75 21                	jne    c0022ae2 <lock_try_acquire+0x2e>
c0022ac1:	83 ec 0c             	sub    $0xc,%esp
c0022ac4:	68 d3 da 02 c0       	push   $0xc002dad3
c0022ac9:	68 3f d2 02 c0       	push   $0xc002d23f
c0022ace:	68 d4 bc 02 c0       	push   $0xc002bcd4
c0022ad3:	68 dc 00 00 00       	push   $0xdc
c0022ad8:	68 97 da 02 c0       	push   $0xc002da97
c0022add:	e8 eb 51 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022ae2:	83 ec 0c             	sub    $0xc,%esp
c0022ae5:	53                   	push   %ebx
c0022ae6:	e8 96 fe ff ff       	call   c0022981 <lock_held_by_current_thread>
c0022aeb:	83 c4 10             	add    $0x10,%esp
c0022aee:	84 c0                	test   %al,%al
c0022af0:	74 21                	je     c0022b13 <lock_try_acquire+0x5f>
c0022af2:	83 ec 0c             	sub    $0xc,%esp
c0022af5:	68 f0 da 02 c0       	push   $0xc002daf0
c0022afa:	68 3f d2 02 c0       	push   $0xc002d23f
c0022aff:	68 d4 bc 02 c0       	push   $0xc002bcd4
c0022b04:	68 dd 00 00 00       	push   $0xdd
c0022b09:	68 97 da 02 c0       	push   $0xc002da97
c0022b0e:	e8 ba 51 00 00       	call   c0027ccd <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022b13:	83 ec 0c             	sub    $0xc,%esp
c0022b16:	8d 43 04             	lea    0x4(%ebx),%eax
c0022b19:	50                   	push   %eax
c0022b1a:	e8 9c fc ff ff       	call   c00227bb <sema_try_down>
c0022b1f:	89 c6                	mov    %eax,%esi
  if (success){
c0022b21:	83 c4 10             	add    $0x10,%esp
c0022b24:	84 c0                	test   %al,%al
c0022b26:	74 1f                	je     c0022b47 <lock_try_acquire+0x93>
    lock->holder = thread_current ();
c0022b28:	e8 ad de ff ff       	call   c00209da <thread_current>
c0022b2d:	89 03                	mov    %eax,(%ebx)
    list_push_back(&thread_current()->hold_locks,&lock->elem);
c0022b2f:	e8 a6 de ff ff       	call   c00209da <thread_current>
c0022b34:	83 ec 08             	sub    $0x8,%esp
c0022b37:	83 c3 18             	add    $0x18,%ebx
c0022b3a:	53                   	push   %ebx
c0022b3b:	83 c0 30             	add    $0x30,%eax
c0022b3e:	50                   	push   %eax
c0022b3f:	e8 d4 56 00 00       	call   c0028218 <list_push_back>
c0022b44:	83 c4 10             	add    $0x10,%esp
  }
    
  return success;
}
c0022b47:	89 f0                	mov    %esi,%eax
c0022b49:	83 c4 04             	add    $0x4,%esp
c0022b4c:	5b                   	pop    %ebx
c0022b4d:	5e                   	pop    %esi
c0022b4e:	c3                   	ret    

c0022b4f <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022b4f:	55                   	push   %ebp
c0022b50:	57                   	push   %edi
c0022b51:	56                   	push   %esi
c0022b52:	53                   	push   %ebx
c0022b53:	83 ec 1c             	sub    $0x1c,%esp
c0022b56:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  enum intr_level old_level;
  old_level = intr_disable();
c0022b5a:	e8 31 eb ff ff       	call   c0021690 <intr_disable>
c0022b5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  ASSERT (lock != NULL);
c0022b63:	85 db                	test   %ebx,%ebx
c0022b65:	75 21                	jne    c0022b88 <lock_release+0x39>
c0022b67:	83 ec 0c             	sub    $0xc,%esp
c0022b6a:	68 d3 da 02 c0       	push   $0xc002dad3
c0022b6f:	68 3f d2 02 c0       	push   $0xc002d23f
c0022b74:	68 c4 bc 02 c0       	push   $0xc002bcc4
c0022b79:	68 f1 00 00 00       	push   $0xf1
c0022b7e:	68 97 da 02 c0       	push   $0xc002da97
c0022b83:	e8 45 51 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022b88:	83 ec 0c             	sub    $0xc,%esp
c0022b8b:	53                   	push   %ebx
c0022b8c:	e8 f0 fd ff ff       	call   c0022981 <lock_held_by_current_thread>
c0022b91:	83 c4 10             	add    $0x10,%esp
c0022b94:	84 c0                	test   %al,%al
c0022b96:	75 21                	jne    c0022bb9 <lock_release+0x6a>
c0022b98:	83 ec 0c             	sub    $0xc,%esp
c0022b9b:	68 14 db 02 c0       	push   $0xc002db14
c0022ba0:	68 3f d2 02 c0       	push   $0xc002d23f
c0022ba5:	68 c4 bc 02 c0       	push   $0xc002bcc4
c0022baa:	68 f2 00 00 00       	push   $0xf2
c0022baf:	68 97 da 02 c0       	push   $0xc002da97
c0022bb4:	e8 14 51 00 00       	call   c0027ccd <debug_panic>
  if(!thread_mlfqs){
c0022bb9:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0022bc0:	0f 85 d4 00 00 00    	jne    c0022c9a <lock_release+0x14b>
    struct thread *current_thread = thread_current();
c0022bc6:	e8 0f de ff ff       	call   c00209da <thread_current>
c0022bcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    struct list_elem *temp;
    int cur_priority = -1;
    if(!list_empty(&current_thread->hold_locks)){
c0022bcf:	8d 78 30             	lea    0x30(%eax),%edi
c0022bd2:	83 ec 0c             	sub    $0xc,%esp
c0022bd5:	57                   	push   %edi
c0022bd6:	e8 e7 56 00 00       	call   c00282c2 <list_empty>
c0022bdb:	83 c4 10             	add    $0x10,%esp
  ASSERT (lock != NULL);
  ASSERT (lock_held_by_current_thread (lock));
  if(!thread_mlfqs){
    struct thread *current_thread = thread_current();
    struct list_elem *temp;
    int cur_priority = -1;
c0022bde:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
c0022be5:	ff 
    if(!list_empty(&current_thread->hold_locks)){
c0022be6:	84 c0                	test   %al,%al
c0022be8:	75 6c                	jne    c0022c56 <lock_release+0x107>
      for(temp = list_begin(&current_thread->hold_locks);temp !=list_end(&current_thread->hold_locks);temp = list_next(temp)){
c0022bea:	83 ec 0c             	sub    $0xc,%esp
c0022bed:	57                   	push   %edi
c0022bee:	e8 c4 51 00 00       	call   c0027db7 <list_begin>
c0022bf3:	89 c6                	mov    %eax,%esi
c0022bf5:	83 c4 10             	add    $0x10,%esp
  ASSERT (lock != NULL);
  ASSERT (lock_held_by_current_thread (lock));
  if(!thread_mlfqs){
    struct thread *current_thread = thread_current();
    struct list_elem *temp;
    int cur_priority = -1;
c0022bf8:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
c0022bff:	ff 
    if(!list_empty(&current_thread->hold_locks)){
      for(temp = list_begin(&current_thread->hold_locks);temp !=list_end(&current_thread->hold_locks);temp = list_next(temp)){
c0022c00:	eb 44                	jmp    c0022c46 <lock_release+0xf7>
        struct lock *temp_lock = list_entry(temp,struct lock,elem);
c0022c02:	8d 46 e8             	lea    -0x18(%esi),%eax
        if(temp_lock == lock){
c0022c05:	39 c3                	cmp    %eax,%ebx
c0022c07:	74 2f                	je     c0022c38 <lock_release+0xe9>
          continue;
      }
        struct list *waiters = &temp_lock->semaphore.waiters;
c0022c09:	8d 6e f0             	lea    -0x10(%esi),%ebp
        if(list_size(waiters)!=0){
c0022c0c:	83 ec 0c             	sub    $0xc,%esp
c0022c0f:	55                   	push   %ebp
c0022c10:	e8 6a 56 00 00       	call   c002827f <list_size>
c0022c15:	83 c4 10             	add    $0x10,%esp
c0022c18:	85 c0                	test   %eax,%eax
c0022c1a:	74 1c                	je     c0022c38 <lock_release+0xe9>
          int p = list_entry(list_front(waiters),struct thread,elem)->priority;
c0022c1c:	83 ec 0c             	sub    $0xc,%esp
c0022c1f:	55                   	push   %ebp
c0022c20:	e8 c1 56 00 00       	call   c00282e6 <list_front>
c0022c25:	8b 40 cc             	mov    -0x34(%eax),%eax
c0022c28:	83 c4 10             	add    $0x10,%esp
c0022c2b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0022c2f:	39 c1                	cmp    %eax,%ecx
c0022c31:	0f 4d c1             	cmovge %ecx,%eax
c0022c34:	89 44 24 08          	mov    %eax,0x8(%esp)
  if(!thread_mlfqs){
    struct thread *current_thread = thread_current();
    struct list_elem *temp;
    int cur_priority = -1;
    if(!list_empty(&current_thread->hold_locks)){
      for(temp = list_begin(&current_thread->hold_locks);temp !=list_end(&current_thread->hold_locks);temp = list_next(temp)){
c0022c38:	83 ec 0c             	sub    $0xc,%esp
c0022c3b:	56                   	push   %esi
c0022c3c:	e8 a6 51 00 00       	call   c0027de7 <list_next>
c0022c41:	89 c6                	mov    %eax,%esi
c0022c43:	83 c4 10             	add    $0x10,%esp
c0022c46:	83 ec 0c             	sub    $0xc,%esp
c0022c49:	57                   	push   %edi
c0022c4a:	e8 de 51 00 00       	call   c0027e2d <list_end>
c0022c4f:	83 c4 10             	add    $0x10,%esp
c0022c52:	39 c6                	cmp    %eax,%esi
c0022c54:	75 ac                	jne    c0022c02 <lock_release+0xb3>
          if(p>cur_priority)
            cur_priority = p;
        }
      }
    }
    if(cur_priority>current_thread->inital_priority){
c0022c56:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0022c5a:	8b 41 2c             	mov    0x2c(%ecx),%eax
c0022c5d:	8b 54 24 08          	mov    0x8(%esp),%edx
c0022c61:	39 c2                	cmp    %eax,%edx
        current_thread->priority = cur_priority;
c0022c63:	0f 4f c2             	cmovg  %edx,%eax
c0022c66:	89 41 1c             	mov    %eax,0x1c(%ecx)
      }
    else{
      current_thread->priority = current_thread->inital_priority; 
    }
    list_remove(&lock->elem);
c0022c69:	83 ec 0c             	sub    $0xc,%esp
c0022c6c:	8d 43 18             	lea    0x18(%ebx),%eax
c0022c6f:	50                   	push   %eax
c0022c70:	e8 c0 55 00 00       	call   c0028235 <list_remove>
    if(!list_empty(&lock->semaphore.waiters)){
c0022c75:	8d 73 08             	lea    0x8(%ebx),%esi
c0022c78:	89 34 24             	mov    %esi,(%esp)
c0022c7b:	e8 42 56 00 00       	call   c00282c2 <list_empty>
c0022c80:	83 c4 10             	add    $0x10,%esp
c0022c83:	84 c0                	test   %al,%al
c0022c85:	75 13                	jne    c0022c9a <lock_release+0x14b>
      list_entry(list_front(&lock->semaphore.waiters),struct thread,elem)->donate_thread = NULL;
c0022c87:	83 ec 0c             	sub    $0xc,%esp
c0022c8a:	56                   	push   %esi
c0022c8b:	e8 56 56 00 00       	call   c00282e6 <list_front>
c0022c90:	c7 40 f0 00 00 00 00 	movl   $0x0,-0x10(%eax)
c0022c97:	83 c4 10             	add    $0x10,%esp
    }
  }
  
  lock->holder = NULL;
c0022c9a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sema_up (&lock->semaphore);
c0022ca0:	83 ec 0c             	sub    $0xc,%esp
c0022ca3:	83 c3 04             	add    $0x4,%ebx
c0022ca6:	53                   	push   %ebx
c0022ca7:	e8 65 fb ff ff       	call   c0022811 <sema_up>
  intr_set_level(old_level);
c0022cac:	83 c4 04             	add    $0x4,%esp
c0022caf:	ff 74 24 10          	pushl  0x10(%esp)
c0022cb3:	e8 df e9 ff ff       	call   c0021697 <intr_set_level>
}
c0022cb8:	83 c4 2c             	add    $0x2c,%esp
c0022cbb:	5b                   	pop    %ebx
c0022cbc:	5e                   	pop    %esi
c0022cbd:	5f                   	pop    %edi
c0022cbe:	5d                   	pop    %ebp
c0022cbf:	c3                   	ret    

c0022cc0 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022cc0:	83 ec 0c             	sub    $0xc,%esp
c0022cc3:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (cond != NULL);
c0022cc7:	85 c0                	test   %eax,%eax
c0022cc9:	75 21                	jne    c0022cec <cond_init+0x2c>
c0022ccb:	83 ec 0c             	sub    $0xc,%esp
c0022cce:	68 e0 da 02 c0       	push   $0xc002dae0
c0022cd3:	68 3f d2 02 c0       	push   $0xc002d23f
c0022cd8:	68 9c bc 02 c0       	push   $0xc002bc9c
c0022cdd:	68 2f 01 00 00       	push   $0x12f
c0022ce2:	68 97 da 02 c0       	push   $0xc002da97
c0022ce7:	e8 e1 4f 00 00       	call   c0027ccd <debug_panic>

  list_init (&cond->waiters);
c0022cec:	83 ec 0c             	sub    $0xc,%esp
c0022cef:	50                   	push   %eax
c0022cf0:	e8 7f 50 00 00       	call   c0027d74 <list_init>
}
c0022cf5:	83 c4 1c             	add    $0x1c,%esp
c0022cf8:	c3                   	ret    

c0022cf9 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022cf9:	55                   	push   %ebp
c0022cfa:	57                   	push   %edi
c0022cfb:	56                   	push   %esi
c0022cfc:	53                   	push   %ebx
c0022cfd:	83 ec 2c             	sub    $0x2c,%esp
c0022d00:	8b 74 24 40          	mov    0x40(%esp),%esi
c0022d04:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022d08:	85 f6                	test   %esi,%esi
c0022d0a:	75 21                	jne    c0022d2d <cond_wait+0x34>
c0022d0c:	83 ec 0c             	sub    $0xc,%esp
c0022d0f:	68 e0 da 02 c0       	push   $0xc002dae0
c0022d14:	68 3f d2 02 c0       	push   $0xc002d23f
c0022d19:	68 90 bc 02 c0       	push   $0xc002bc90
c0022d1e:	68 4a 01 00 00       	push   $0x14a
c0022d23:	68 97 da 02 c0       	push   $0xc002da97
c0022d28:	e8 a0 4f 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock != NULL);
c0022d2d:	85 db                	test   %ebx,%ebx
c0022d2f:	75 21                	jne    c0022d52 <cond_wait+0x59>
c0022d31:	83 ec 0c             	sub    $0xc,%esp
c0022d34:	68 d3 da 02 c0       	push   $0xc002dad3
c0022d39:	68 3f d2 02 c0       	push   $0xc002d23f
c0022d3e:	68 90 bc 02 c0       	push   $0xc002bc90
c0022d43:	68 4b 01 00 00       	push   $0x14b
c0022d48:	68 97 da 02 c0       	push   $0xc002da97
c0022d4d:	e8 7b 4f 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!intr_context ());
c0022d52:	e8 78 eb ff ff       	call   c00218cf <intr_context>
c0022d57:	84 c0                	test   %al,%al
c0022d59:	74 21                	je     c0022d7c <cond_wait+0x83>
c0022d5b:	83 ec 0c             	sub    $0xc,%esp
c0022d5e:	68 2a d6 02 c0       	push   $0xc002d62a
c0022d63:	68 3f d2 02 c0       	push   $0xc002d23f
c0022d68:	68 90 bc 02 c0       	push   $0xc002bc90
c0022d6d:	68 4c 01 00 00       	push   $0x14c
c0022d72:	68 97 da 02 c0       	push   $0xc002da97
c0022d77:	e8 51 4f 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d7c:	83 ec 0c             	sub    $0xc,%esp
c0022d7f:	53                   	push   %ebx
c0022d80:	e8 fc fb ff ff       	call   c0022981 <lock_held_by_current_thread>
c0022d85:	83 c4 10             	add    $0x10,%esp
c0022d88:	84 c0                	test   %al,%al
c0022d8a:	75 21                	jne    c0022dad <cond_wait+0xb4>
c0022d8c:	83 ec 0c             	sub    $0xc,%esp
c0022d8f:	68 14 db 02 c0       	push   $0xc002db14
c0022d94:	68 3f d2 02 c0       	push   $0xc002d23f
c0022d99:	68 90 bc 02 c0       	push   $0xc002bc90
c0022d9e:	68 4d 01 00 00       	push   $0x14d
c0022da3:	68 97 da 02 c0       	push   $0xc002da97
c0022da8:	e8 20 4f 00 00       	call   c0027ccd <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022dad:	83 ec 08             	sub    $0x8,%esp
c0022db0:	6a 00                	push   $0x0
c0022db2:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c0022db6:	8d 7c 24 14          	lea    0x14(%esp),%edi
c0022dba:	57                   	push   %edi
c0022dbb:	e8 27 f9 ff ff       	call   c00226e7 <sema_init>
  waiter.owner = thread_current();
c0022dc0:	e8 15 dc ff ff       	call   c00209da <thread_current>
c0022dc5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  list_insert_ordered (&cond->waiters, &waiter.elem,priority_less_cond,NULL);
c0022dc9:	6a 00                	push   $0x0
c0022dcb:	68 cf 26 02 c0       	push   $0xc00226cf
c0022dd0:	55                   	push   %ebp
c0022dd1:	56                   	push   %esi
c0022dd2:	e8 8a 58 00 00       	call   c0028661 <list_insert_ordered>
  lock_release (lock);
c0022dd7:	83 c4 14             	add    $0x14,%esp
c0022dda:	53                   	push   %ebx
c0022ddb:	e8 6f fd ff ff       	call   c0022b4f <lock_release>
  sema_down (&waiter.semaphore);
c0022de0:	89 3c 24             	mov    %edi,(%esp)
c0022de3:	e8 3e f9 ff ff       	call   c0022726 <sema_down>
  lock_acquire (lock);
c0022de8:	89 1c 24             	mov    %ebx,(%esp)
c0022deb:	e8 cf fb ff ff       	call   c00229bf <lock_acquire>
}
c0022df0:	83 c4 3c             	add    $0x3c,%esp
c0022df3:	5b                   	pop    %ebx
c0022df4:	5e                   	pop    %esi
c0022df5:	5f                   	pop    %edi
c0022df6:	5d                   	pop    %ebp
c0022df7:	c3                   	ret    

c0022df8 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022df8:	56                   	push   %esi
c0022df9:	53                   	push   %ebx
c0022dfa:	83 ec 04             	sub    $0x4,%esp
c0022dfd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0022e01:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (cond != NULL);
c0022e05:	85 db                	test   %ebx,%ebx
c0022e07:	75 21                	jne    c0022e2a <cond_signal+0x32>
c0022e09:	83 ec 0c             	sub    $0xc,%esp
c0022e0c:	68 e0 da 02 c0       	push   $0xc002dae0
c0022e11:	68 3f d2 02 c0       	push   $0xc002d23f
c0022e16:	68 84 bc 02 c0       	push   $0xc002bc84
c0022e1b:	68 60 01 00 00       	push   $0x160
c0022e20:	68 97 da 02 c0       	push   $0xc002da97
c0022e25:	e8 a3 4e 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock != NULL);
c0022e2a:	85 f6                	test   %esi,%esi
c0022e2c:	75 21                	jne    c0022e4f <cond_signal+0x57>
c0022e2e:	83 ec 0c             	sub    $0xc,%esp
c0022e31:	68 d3 da 02 c0       	push   $0xc002dad3
c0022e36:	68 3f d2 02 c0       	push   $0xc002d23f
c0022e3b:	68 84 bc 02 c0       	push   $0xc002bc84
c0022e40:	68 61 01 00 00       	push   $0x161
c0022e45:	68 97 da 02 c0       	push   $0xc002da97
c0022e4a:	e8 7e 4e 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!intr_context ());
c0022e4f:	e8 7b ea ff ff       	call   c00218cf <intr_context>
c0022e54:	84 c0                	test   %al,%al
c0022e56:	74 21                	je     c0022e79 <cond_signal+0x81>
c0022e58:	83 ec 0c             	sub    $0xc,%esp
c0022e5b:	68 2a d6 02 c0       	push   $0xc002d62a
c0022e60:	68 3f d2 02 c0       	push   $0xc002d23f
c0022e65:	68 84 bc 02 c0       	push   $0xc002bc84
c0022e6a:	68 62 01 00 00       	push   $0x162
c0022e6f:	68 97 da 02 c0       	push   $0xc002da97
c0022e74:	e8 54 4e 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022e79:	83 ec 0c             	sub    $0xc,%esp
c0022e7c:	56                   	push   %esi
c0022e7d:	e8 ff fa ff ff       	call   c0022981 <lock_held_by_current_thread>
c0022e82:	83 c4 10             	add    $0x10,%esp
c0022e85:	84 c0                	test   %al,%al
c0022e87:	75 21                	jne    c0022eaa <cond_signal+0xb2>
c0022e89:	83 ec 0c             	sub    $0xc,%esp
c0022e8c:	68 14 db 02 c0       	push   $0xc002db14
c0022e91:	68 3f d2 02 c0       	push   $0xc002d23f
c0022e96:	68 84 bc 02 c0       	push   $0xc002bc84
c0022e9b:	68 63 01 00 00       	push   $0x163
c0022ea0:	68 97 da 02 c0       	push   $0xc002da97
c0022ea5:	e8 23 4e 00 00       	call   c0027ccd <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0022eaa:	83 ec 0c             	sub    $0xc,%esp
c0022ead:	53                   	push   %ebx
c0022eae:	e8 0f 54 00 00       	call   c00282c2 <list_empty>
c0022eb3:	83 c4 10             	add    $0x10,%esp
c0022eb6:	84 c0                	test   %al,%al
c0022eb8:	75 17                	jne    c0022ed1 <cond_signal+0xd9>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0022eba:	83 ec 0c             	sub    $0xc,%esp
c0022ebd:	53                   	push   %ebx
c0022ebe:	e8 61 54 00 00       	call   c0028324 <list_pop_front>
c0022ec3:	83 c0 08             	add    $0x8,%eax
c0022ec6:	89 04 24             	mov    %eax,(%esp)
c0022ec9:	e8 43 f9 ff ff       	call   c0022811 <sema_up>
c0022ece:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0022ed1:	83 c4 04             	add    $0x4,%esp
c0022ed4:	5b                   	pop    %ebx
c0022ed5:	5e                   	pop    %esi
c0022ed6:	c3                   	ret    

c0022ed7 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0022ed7:	56                   	push   %esi
c0022ed8:	53                   	push   %ebx
c0022ed9:	83 ec 04             	sub    $0x4,%esp
c0022edc:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0022ee0:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT (cond != NULL);
c0022ee4:	85 db                	test   %ebx,%ebx
c0022ee6:	75 21                	jne    c0022f09 <cond_broadcast+0x32>
c0022ee8:	83 ec 0c             	sub    $0xc,%esp
c0022eeb:	68 e0 da 02 c0       	push   $0xc002dae0
c0022ef0:	68 3f d2 02 c0       	push   $0xc002d23f
c0022ef5:	68 74 bc 02 c0       	push   $0xc002bc74
c0022efa:	68 72 01 00 00       	push   $0x172
c0022eff:	68 97 da 02 c0       	push   $0xc002da97
c0022f04:	e8 c4 4d 00 00       	call   c0027ccd <debug_panic>
  ASSERT (lock != NULL);
c0022f09:	85 f6                	test   %esi,%esi
c0022f0b:	75 2e                	jne    c0022f3b <cond_broadcast+0x64>
c0022f0d:	83 ec 0c             	sub    $0xc,%esp
c0022f10:	68 d3 da 02 c0       	push   $0xc002dad3
c0022f15:	68 3f d2 02 c0       	push   $0xc002d23f
c0022f1a:	68 74 bc 02 c0       	push   $0xc002bc74
c0022f1f:	68 73 01 00 00       	push   $0x173
c0022f24:	68 97 da 02 c0       	push   $0xc002da97
c0022f29:	e8 9f 4d 00 00       	call   c0027ccd <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0022f2e:	83 ec 08             	sub    $0x8,%esp
c0022f31:	56                   	push   %esi
c0022f32:	53                   	push   %ebx
c0022f33:	e8 c0 fe ff ff       	call   c0022df8 <cond_signal>
c0022f38:	83 c4 10             	add    $0x10,%esp
cond_broadcast (struct condition *cond, struct lock *lock) 
{
  ASSERT (cond != NULL);
  ASSERT (lock != NULL);

  while (!list_empty (&cond->waiters))
c0022f3b:	83 ec 0c             	sub    $0xc,%esp
c0022f3e:	53                   	push   %ebx
c0022f3f:	e8 7e 53 00 00       	call   c00282c2 <list_empty>
c0022f44:	83 c4 10             	add    $0x10,%esp
c0022f47:	84 c0                	test   %al,%al
c0022f49:	74 e3                	je     c0022f2e <cond_broadcast+0x57>
    cond_signal (cond, lock);
}
c0022f4b:	83 c4 04             	add    $0x4,%esp
c0022f4e:	5b                   	pop    %ebx
c0022f4f:	5e                   	pop    %esi
c0022f50:	c3                   	ret    

c0022f51 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0022f51:	55                   	push   %ebp
c0022f52:	57                   	push   %edi
c0022f53:	56                   	push   %esi
c0022f54:	53                   	push   %ebx
c0022f55:	83 ec 18             	sub    $0x18,%esp
c0022f58:	89 c7                	mov    %eax,%edi
c0022f5a:	89 d5                	mov    %edx,%ebp
c0022f5c:	89 ce                	mov    %ecx,%esi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0022f5e:	51                   	push   %ecx
c0022f5f:	e8 9f 59 00 00       	call   c0028903 <bitmap_buf_size>
c0022f64:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
c0022f6a:	c1 eb 0c             	shr    $0xc,%ebx
  if (bm_pages > page_cnt)
c0022f6d:	83 c4 10             	add    $0x10,%esp
c0022f70:	39 de                	cmp    %ebx,%esi
c0022f72:	73 20                	jae    c0022f94 <init_pool+0x43>
    PANIC ("Not enough memory in %s for bitmap.", name);
c0022f74:	83 ec 0c             	sub    $0xc,%esp
c0022f77:	ff 74 24 2c          	pushl  0x2c(%esp)
c0022f7b:	68 38 db 02 c0       	push   $0xc002db38
c0022f80:	68 60 bd 02 c0       	push   $0xc002bd60
c0022f85:	68 a1 00 00 00       	push   $0xa1
c0022f8a:	68 8c db 02 c0       	push   $0xc002db8c
c0022f8f:	e8 39 4d 00 00       	call   c0027ccd <debug_panic>
  page_cnt -= bm_pages;
c0022f94:	29 de                	sub    %ebx,%esi

  printf ("%zu pages available in %s.\n", page_cnt, name);
c0022f96:	83 ec 04             	sub    $0x4,%esp
c0022f99:	ff 74 24 24          	pushl  0x24(%esp)
c0022f9d:	56                   	push   %esi
c0022f9e:	68 a3 db 02 c0       	push   $0xc002dba3
c0022fa3:	e8 ad 30 00 00       	call   c0026055 <printf>

  /* Initialize the pool. */
  lock_init (&p->lock);
c0022fa8:	89 3c 24             	mov    %edi,(%esp)
c0022fab:	e8 8d f9 ff ff       	call   c002293d <lock_init>
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0022fb0:	c1 e3 0c             	shl    $0xc,%ebx
c0022fb3:	83 c4 0c             	add    $0xc,%esp
c0022fb6:	53                   	push   %ebx
c0022fb7:	55                   	push   %ebp
c0022fb8:	56                   	push   %esi
c0022fb9:	e8 2a 5c 00 00       	call   c0028be8 <bitmap_create_in_buf>
c0022fbe:	89 47 20             	mov    %eax,0x20(%edi)
  p->base = base + bm_pages * PGSIZE;
c0022fc1:	01 eb                	add    %ebp,%ebx
c0022fc3:	89 5f 24             	mov    %ebx,0x24(%edi)
}
c0022fc6:	83 c4 1c             	add    $0x1c,%esp
c0022fc9:	5b                   	pop    %ebx
c0022fca:	5e                   	pop    %esi
c0022fcb:	5f                   	pop    %edi
c0022fcc:	5d                   	pop    %ebp
c0022fcd:	c3                   	ret    

c0022fce <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0022fce:	56                   	push   %esi
c0022fcf:	53                   	push   %ebx
c0022fd0:	83 ec 04             	sub    $0x4,%esp
c0022fd3:	8b 54 24 10          	mov    0x10(%esp),%edx
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0022fd7:	8b 1d 7e 01 02 c0    	mov    0xc002017e,%ebx
c0022fdd:	c1 e3 0c             	shl    $0xc,%ebx
/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
  ASSERT ((void *) paddr < PHYS_BASE);
c0022fe0:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c0022fe6:	76 1e                	jbe    c0023006 <palloc_init+0x38>
c0022fe8:	83 ec 0c             	sub    $0xc,%esp
c0022feb:	68 bf db 02 c0       	push   $0xc002dbbf
c0022ff0:	68 3f d2 02 c0       	push   $0xc002d23f
c0022ff5:	68 6c bd 02 c0       	push   $0xc002bd6c
c0022ffa:	6a 4a                	push   $0x4a
c0022ffc:	68 82 d2 02 c0       	push   $0xc002d282
c0023001:	e8 c7 4c 00 00       	call   c0027ccd <debug_panic>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023006:	8d 83 ff 0f f0 ff    	lea    -0xff001(%ebx),%eax
c002300c:	81 eb 00 00 10 00    	sub    $0x100000,%ebx
c0023012:	0f 48 d8             	cmovs  %eax,%ebx
c0023015:	c1 fb 0c             	sar    $0xc,%ebx
  size_t user_pages = free_pages / 2;
c0023018:	89 de                	mov    %ebx,%esi
c002301a:	d1 ee                	shr    %esi
c002301c:	39 d6                	cmp    %edx,%esi
c002301e:	0f 47 f2             	cmova  %edx,%esi
  size_t kernel_pages;
  if (user_pages > user_page_limit)
    user_pages = user_page_limit;
  kernel_pages = free_pages - user_pages;
c0023021:	29 f3                	sub    %esi,%ebx

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023023:	83 ec 0c             	sub    $0xc,%esp
c0023026:	68 da db 02 c0       	push   $0xc002dbda
c002302b:	89 d9                	mov    %ebx,%ecx
c002302d:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023032:	b8 00 90 03 c0       	mov    $0xc0039000,%eax
c0023037:	e8 15 ff ff ff       	call   c0022f51 <init_pool>
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002303c:	c1 e3 0c             	shl    $0xc,%ebx
c002303f:	8d 93 00 00 10 c0    	lea    -0x3ff00000(%ebx),%edx
c0023045:	c7 04 24 e6 db 02 c0 	movl   $0xc002dbe6,(%esp)
c002304c:	89 f1                	mov    %esi,%ecx
c002304e:	b8 c0 8f 03 c0       	mov    $0xc0038fc0,%eax
c0023053:	e8 f9 fe ff ff       	call   c0022f51 <init_pool>
             user_pages, "user pool");
}
c0023058:	83 c4 14             	add    $0x14,%esp
c002305b:	5b                   	pop    %ebx
c002305c:	5e                   	pop    %esi
c002305d:	c3                   	ret    

c002305e <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c002305e:	55                   	push   %ebp
c002305f:	57                   	push   %edi
c0023060:	56                   	push   %esi
c0023061:	53                   	push   %ebx
c0023062:	83 ec 0c             	sub    $0xc,%esp
c0023065:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0023069:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002306d:	89 f8                	mov    %edi,%eax
c002306f:	83 e0 04             	and    $0x4,%eax
c0023072:	b8 00 90 03 c0       	mov    $0xc0039000,%eax
c0023077:	bb c0 8f 03 c0       	mov    $0xc0038fc0,%ebx
c002307c:	0f 44 d8             	cmove  %eax,%ebx
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c002307f:	85 ed                	test   %ebp,%ebp
c0023081:	74 6f                	je     c00230f2 <palloc_get_multiple+0x94>
    return NULL;

  lock_acquire (&pool->lock);
c0023083:	83 ec 0c             	sub    $0xc,%esp
c0023086:	53                   	push   %ebx
c0023087:	e8 33 f9 ff ff       	call   c00229bf <lock_acquire>
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c002308c:	6a 00                	push   $0x0
c002308e:	55                   	push   %ebp
c002308f:	6a 00                	push   $0x0
c0023091:	ff 73 20             	pushl  0x20(%ebx)
c0023094:	e8 2b 5e 00 00       	call   c0028ec4 <bitmap_scan_and_flip>
c0023099:	89 c6                	mov    %eax,%esi
  lock_release (&pool->lock);
c002309b:	83 c4 14             	add    $0x14,%esp
c002309e:	53                   	push   %ebx
c002309f:	e8 ab fa ff ff       	call   c0022b4f <lock_release>

  if (page_idx != BITMAP_ERROR)
c00230a4:	83 c4 10             	add    $0x10,%esp
c00230a7:	83 fe ff             	cmp    $0xffffffff,%esi
c00230aa:	74 28                	je     c00230d4 <palloc_get_multiple+0x76>
    pages = pool->base + PGSIZE * page_idx;
c00230ac:	c1 e6 0c             	shl    $0xc,%esi
  else
    pages = NULL;

  if (pages != NULL) 
c00230af:	03 73 24             	add    0x24(%ebx),%esi
c00230b2:	74 20                	je     c00230d4 <palloc_get_multiple+0x76>
  lock_acquire (&pool->lock);
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
  lock_release (&pool->lock);

  if (page_idx != BITMAP_ERROR)
    pages = pool->base + PGSIZE * page_idx;
c00230b4:	89 f0                	mov    %esi,%eax
  else
    pages = NULL;

  if (pages != NULL) 
    {
      if (flags & PAL_ZERO)
c00230b6:	f7 c7 02 00 00 00    	test   $0x2,%edi
c00230bc:	74 40                	je     c00230fe <palloc_get_multiple+0xa0>
        memset (pages, 0, PGSIZE * page_cnt);
c00230be:	c1 e5 0c             	shl    $0xc,%ebp
c00230c1:	83 ec 04             	sub    $0x4,%esp
c00230c4:	55                   	push   %ebp
c00230c5:	6a 00                	push   $0x0
c00230c7:	56                   	push   %esi
c00230c8:	e8 d7 41 00 00       	call   c00272a4 <memset>
c00230cd:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&pool->lock);
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
  lock_release (&pool->lock);

  if (page_idx != BITMAP_ERROR)
    pages = pool->base + PGSIZE * page_idx;
c00230d0:	89 f0                	mov    %esi,%eax
c00230d2:	eb 2a                	jmp    c00230fe <palloc_get_multiple+0xa0>
      if (flags & PAL_ZERO)
        memset (pages, 0, PGSIZE * page_cnt);
    }
  else 
    {
      if (flags & PAL_ASSERT)
c00230d4:	f7 c7 01 00 00 00    	test   $0x1,%edi
c00230da:	74 1d                	je     c00230f9 <palloc_get_multiple+0x9b>
        PANIC ("palloc_get: out of pages");
c00230dc:	68 f0 db 02 c0       	push   $0xc002dbf0
c00230e1:	68 4c bd 02 c0       	push   $0xc002bd4c
c00230e6:	6a 61                	push   $0x61
c00230e8:	68 8c db 02 c0       	push   $0xc002db8c
c00230ed:	e8 db 4b 00 00       	call   c0027ccd <debug_panic>
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
    return NULL;
c00230f2:	b8 00 00 00 00       	mov    $0x0,%eax
c00230f7:	eb 05                	jmp    c00230fe <palloc_get_multiple+0xa0>
    {
      if (flags & PAL_ASSERT)
        PANIC ("palloc_get: out of pages");
    }

  return pages;
c00230f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00230fe:	83 c4 0c             	add    $0xc,%esp
c0023101:	5b                   	pop    %ebx
c0023102:	5e                   	pop    %esi
c0023103:	5f                   	pop    %edi
c0023104:	5d                   	pop    %ebp
c0023105:	c3                   	ret    

c0023106 <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c0023106:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple (flags, 1);
c0023109:	6a 01                	push   $0x1
c002310b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002310f:	e8 4a ff ff ff       	call   c002305e <palloc_get_multiple>
}
c0023114:	83 c4 1c             	add    $0x1c,%esp
c0023117:	c3                   	ret    

c0023118 <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c0023118:	55                   	push   %ebp
c0023119:	57                   	push   %edi
c002311a:	56                   	push   %esi
c002311b:	53                   	push   %ebx
c002311c:	83 ec 0c             	sub    $0xc,%esp
c002311f:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0023123:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
c0023129:	74 1e                	je     c0023149 <palloc_free_multiple+0x31>
c002312b:	83 ec 0c             	sub    $0xc,%esp
c002312e:	68 09 dc 02 c0       	push   $0xc002dc09
c0023133:	68 3f d2 02 c0       	push   $0xc002d23f
c0023138:	68 34 bd 02 c0       	push   $0xc002bd34
c002313d:	6a 7b                	push   $0x7b
c002313f:	68 8c db 02 c0       	push   $0xc002db8c
c0023144:	e8 84 4b 00 00       	call   c0027ccd <debug_panic>
  if (pages == NULL || page_cnt == 0)
c0023149:	85 db                	test   %ebx,%ebx
c002314b:	0f 84 e3 00 00 00    	je     c0023234 <palloc_free_multiple+0x11c>
c0023151:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023156:	0f 84 d8 00 00 00    	je     c0023234 <palloc_free_multiple+0x11c>
  return (uintptr_t) va & PGMASK;
}

/* Virtual page number. */
static inline uintptr_t pg_no (const void *va) {
  return (uintptr_t) va >> PGBITS;
c002315c:	89 de                	mov    %ebx,%esi
c002315e:	c1 ee 0c             	shr    $0xc,%esi
c0023161:	8b 3d 24 90 03 c0    	mov    0xc0039024,%edi
c0023167:	c1 ef 0c             	shr    $0xc,%edi
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c002316a:	83 ec 0c             	sub    $0xc,%esp
c002316d:	ff 35 20 90 03 c0    	pushl  0xc0039020
c0023173:	e8 c4 57 00 00       	call   c002893c <bitmap_size>

  ASSERT (pg_ofs (pages) == 0);
  if (pages == NULL || page_cnt == 0)
    return;

  if (page_from_pool (&kernel_pool, pages))
c0023178:	01 f8                	add    %edi,%eax
c002317a:	83 c4 10             	add    $0x10,%esp
c002317d:	39 c6                	cmp    %eax,%esi
c002317f:	73 09                	jae    c002318a <palloc_free_multiple+0x72>
    pool = &kernel_pool;
c0023181:	bd 00 90 03 c0       	mov    $0xc0039000,%ebp

  ASSERT (pg_ofs (pages) == 0);
  if (pages == NULL || page_cnt == 0)
    return;

  if (page_from_pool (&kernel_pool, pages))
c0023186:	39 fe                	cmp    %edi,%esi
c0023188:	73 42                	jae    c00231cc <palloc_free_multiple+0xb4>
c002318a:	8b 3d e4 8f 03 c0    	mov    0xc0038fe4,%edi
c0023190:	c1 ef 0c             	shr    $0xc,%edi
static bool
page_from_pool (const struct pool *pool, void *page) 
{
  size_t page_no = pg_no (page);
  size_t start_page = pg_no (pool->base);
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023193:	83 ec 0c             	sub    $0xc,%esp
c0023196:	ff 35 e0 8f 03 c0    	pushl  0xc0038fe0
c002319c:	e8 9b 57 00 00       	call   c002893c <bitmap_size>
  if (pages == NULL || page_cnt == 0)
    return;

  if (page_from_pool (&kernel_pool, pages))
    pool = &kernel_pool;
  else if (page_from_pool (&user_pool, pages))
c00231a1:	01 f8                	add    %edi,%eax
c00231a3:	83 c4 10             	add    $0x10,%esp
c00231a6:	39 c6                	cmp    %eax,%esi
c00231a8:	73 04                	jae    c00231ae <palloc_free_multiple+0x96>
c00231aa:	39 fe                	cmp    %edi,%esi
c00231ac:	73 19                	jae    c00231c7 <palloc_free_multiple+0xaf>
    pool = &user_pool;
  else
    NOT_REACHED ();
c00231ae:	68 c0 d6 02 c0       	push   $0xc002d6c0
c00231b3:	68 34 bd 02 c0       	push   $0xc002bd34
c00231b8:	68 84 00 00 00       	push   $0x84
c00231bd:	68 8c db 02 c0       	push   $0xc002db8c
c00231c2:	e8 06 4b 00 00       	call   c0027ccd <debug_panic>
    return;

  if (page_from_pool (&kernel_pool, pages))
    pool = &kernel_pool;
  else if (page_from_pool (&user_pool, pages))
    pool = &user_pool;
c00231c7:	bd c0 8f 03 c0       	mov    $0xc0038fc0,%ebp
  else
    NOT_REACHED ();

  page_idx = pg_no (pages) - pg_no (pool->base);
c00231cc:	8b 45 24             	mov    0x24(%ebp),%eax
c00231cf:	c1 e8 0c             	shr    $0xc,%eax
c00231d2:	29 c6                	sub    %eax,%esi

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c00231d4:	83 ec 04             	sub    $0x4,%esp
c00231d7:	8b 44 24 28          	mov    0x28(%esp),%eax
c00231db:	c1 e0 0c             	shl    $0xc,%eax
c00231de:	50                   	push   %eax
c00231df:	68 cc 00 00 00       	push   $0xcc
c00231e4:	53                   	push   %ebx
c00231e5:	e8 ba 40 00 00       	call   c00272a4 <memset>
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c00231ea:	83 c4 0c             	add    $0xc,%esp
c00231ed:	ff 74 24 28          	pushl  0x28(%esp)
c00231f1:	56                   	push   %esi
c00231f2:	ff 75 20             	pushl  0x20(%ebp)
c00231f5:	e8 ff 5b 00 00       	call   c0028df9 <bitmap_all>
c00231fa:	83 c4 10             	add    $0x10,%esp
c00231fd:	84 c0                	test   %al,%al
c00231ff:	75 21                	jne    c0023222 <palloc_free_multiple+0x10a>
c0023201:	83 ec 0c             	sub    $0xc,%esp
c0023204:	68 5c db 02 c0       	push   $0xc002db5c
c0023209:	68 3f d2 02 c0       	push   $0xc002d23f
c002320e:	68 34 bd 02 c0       	push   $0xc002bd34
c0023213:	68 8c 00 00 00       	push   $0x8c
c0023218:	68 8c db 02 c0       	push   $0xc002db8c
c002321d:	e8 ab 4a 00 00       	call   c0027ccd <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023222:	6a 00                	push   $0x0
c0023224:	ff 74 24 28          	pushl  0x28(%esp)
c0023228:	56                   	push   %esi
c0023229:	ff 75 20             	pushl  0x20(%ebp)
c002322c:	e8 58 58 00 00       	call   c0028a89 <bitmap_set_multiple>
c0023231:	83 c4 10             	add    $0x10,%esp
}
c0023234:	83 c4 0c             	add    $0xc,%esp
c0023237:	5b                   	pop    %ebx
c0023238:	5e                   	pop    %esi
c0023239:	5f                   	pop    %edi
c002323a:	5d                   	pop    %ebp
c002323b:	c3                   	ret    

c002323c <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c002323c:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple (page, 1);
c002323f:	6a 01                	push   $0x1
c0023241:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023245:	e8 ce fe ff ff       	call   c0023118 <palloc_free_multiple>
}
c002324a:	83 c4 1c             	add    $0x1c,%esp
c002324d:	c3                   	ret    

c002324e <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c002324e:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (a != NULL);
c0023251:	85 c0                	test   %eax,%eax
c0023253:	75 21                	jne    c0023276 <arena_to_block+0x28>
c0023255:	83 ec 0c             	sub    $0xc,%esp
c0023258:	68 8d da 02 c0       	push   $0xc002da8d
c002325d:	68 3f d2 02 c0       	push   $0xc002d23f
c0023262:	68 8c bd 02 c0       	push   $0xc002bd8c
c0023267:	68 20 01 00 00       	push   $0x120
c002326c:	68 1d dc 02 c0       	push   $0xc002dc1d
c0023271:	e8 57 4a 00 00       	call   c0027ccd <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023276:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c002327c:	74 21                	je     c002329f <arena_to_block+0x51>
c002327e:	83 ec 0c             	sub    $0xc,%esp
c0023281:	68 34 dc 02 c0       	push   $0xc002dc34
c0023286:	68 3f d2 02 c0       	push   $0xc002d23f
c002328b:	68 8c bd 02 c0       	push   $0xc002bd8c
c0023290:	68 21 01 00 00       	push   $0x121
c0023295:	68 1d dc 02 c0       	push   $0xc002dc1d
c002329a:	e8 2e 4a 00 00       	call   c0027ccd <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c002329f:	8b 48 04             	mov    0x4(%eax),%ecx
c00232a2:	39 51 04             	cmp    %edx,0x4(%ecx)
c00232a5:	77 21                	ja     c00232c8 <arena_to_block+0x7a>
c00232a7:	83 ec 0c             	sub    $0xc,%esp
c00232aa:	68 4c dc 02 c0       	push   $0xc002dc4c
c00232af:	68 3f d2 02 c0       	push   $0xc002d23f
c00232b4:	68 8c bd 02 c0       	push   $0xc002bd8c
c00232b9:	68 22 01 00 00       	push   $0x122
c00232be:	68 1d dc 02 c0       	push   $0xc002dc1d
c00232c3:	e8 05 4a 00 00       	call   c0027ccd <debug_panic>
  return (struct block *) ((uint8_t *) a
c00232c8:	0f af 11             	imul   (%ecx),%edx
c00232cb:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
                           + sizeof *a
                           + idx * a->desc->block_size);
}
c00232cf:	83 c4 0c             	add    $0xc,%esp
c00232d2:	c3                   	ret    

c00232d3 <block_to_arena>:
}

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c00232d3:	53                   	push   %ebx
c00232d4:	83 ec 08             	sub    $0x8,%esp
  struct arena *a = pg_round_down (b);

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c00232d7:	89 c1                	mov    %eax,%ecx
c00232d9:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c00232df:	75 21                	jne    c0023302 <block_to_arena+0x2f>
c00232e1:	83 ec 0c             	sub    $0xc,%esp
c00232e4:	68 8d da 02 c0       	push   $0xc002da8d
c00232e9:	68 3f d2 02 c0       	push   $0xc002d23f
c00232ee:	68 7c bd 02 c0       	push   $0xc002bd7c
c00232f3:	68 11 01 00 00       	push   $0x111
c00232f8:	68 1d dc 02 c0       	push   $0xc002dc1d
c00232fd:	e8 cb 49 00 00       	call   c0027ccd <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023302:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0023308:	74 21                	je     c002332b <block_to_arena+0x58>
c002330a:	83 ec 0c             	sub    $0xc,%esp
c002330d:	68 34 dc 02 c0       	push   $0xc002dc34
c0023312:	68 3f d2 02 c0       	push   $0xc002d23f
c0023317:	68 7c bd 02 c0       	push   $0xc002bd7c
c002331c:	68 12 01 00 00       	push   $0x112
c0023321:	68 1d dc 02 c0       	push   $0xc002dc1d
c0023326:	e8 a2 49 00 00       	call   c0027ccd <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c002332b:	8b 59 04             	mov    0x4(%ecx),%ebx
c002332e:	85 db                	test   %ebx,%ebx
c0023330:	74 34                	je     c0023366 <block_to_arena+0x93>
c0023332:	25 ff 0f 00 00       	and    $0xfff,%eax
c0023337:	83 e8 0c             	sub    $0xc,%eax
c002333a:	ba 00 00 00 00       	mov    $0x0,%edx
c002333f:	f7 33                	divl   (%ebx)
c0023341:	85 d2                	test   %edx,%edx
c0023343:	74 4c                	je     c0023391 <block_to_arena+0xbe>
c0023345:	83 ec 0c             	sub    $0xc,%esp
c0023348:	68 6c dc 02 c0       	push   $0xc002dc6c
c002334d:	68 3f d2 02 c0       	push   $0xc002d23f
c0023352:	68 7c bd 02 c0       	push   $0xc002bd7c
c0023357:	68 16 01 00 00       	push   $0x116
c002335c:	68 1d dc 02 c0       	push   $0xc002dc1d
c0023361:	e8 67 49 00 00       	call   c0027ccd <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023366:	25 ff 0f 00 00       	and    $0xfff,%eax
c002336b:	83 f8 0c             	cmp    $0xc,%eax
c002336e:	74 21                	je     c0023391 <block_to_arena+0xbe>
c0023370:	83 ec 0c             	sub    $0xc,%esp
c0023373:	68 b4 dc 02 c0       	push   $0xc002dcb4
c0023378:	68 3f d2 02 c0       	push   $0xc002d23f
c002337d:	68 7c bd 02 c0       	push   $0xc002bd7c
c0023382:	68 17 01 00 00       	push   $0x117
c0023387:	68 1d dc 02 c0       	push   $0xc002dc1d
c002338c:	e8 3c 49 00 00       	call   c0027ccd <debug_panic>

  return a;
}
c0023391:	89 c8                	mov    %ecx,%eax
c0023393:	83 c4 08             	add    $0x8,%esp
c0023396:	5b                   	pop    %ebx
c0023397:	c3                   	ret    

c0023398 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c0023398:	57                   	push   %edi
c0023399:	56                   	push   %esi
c002339a:	53                   	push   %ebx
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
    {
      struct desc *d = &descs[desc_cnt++];
c002339b:	8b 1d 40 90 03 c0    	mov    0xc0039040,%ebx
c00233a1:	8d 43 01             	lea    0x1(%ebx),%eax
c00233a4:	a3 40 90 03 c0       	mov    %eax,0xc0039040
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00233a9:	83 f8 0a             	cmp    $0xa,%eax
c00233ac:	76 77                	jbe    c0023425 <malloc_init+0x8d>
c00233ae:	eb 13                	jmp    c00233c3 <malloc_init+0x2b>
{
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
    {
      struct desc *d = &descs[desc_cnt++];
c00233b0:	8b 1d 40 90 03 c0    	mov    0xc0039040,%ebx
c00233b6:	8d 43 01             	lea    0x1(%ebx),%eax
c00233b9:	a3 40 90 03 c0       	mov    %eax,0xc0039040
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00233be:	83 f8 0a             	cmp    $0xa,%eax
c00233c1:	76 1e                	jbe    c00233e1 <malloc_init+0x49>
c00233c3:	83 ec 0c             	sub    $0xc,%esp
c00233c6:	68 e0 dc 02 c0       	push   $0xc002dce0
c00233cb:	68 3f d2 02 c0       	push   $0xc002d23f
c00233d0:	68 9c bd 02 c0       	push   $0xc002bd9c
c00233d5:	6a 4f                	push   $0x4f
c00233d7:	68 1d dc 02 c0       	push   $0xc002dc1d
c00233dc:	e8 ec 48 00 00       	call   c0027ccd <debug_panic>
      d->block_size = block_size;
c00233e1:	6b db 38             	imul   $0x38,%ebx,%ebx
c00233e4:	89 b3 60 90 03 c0    	mov    %esi,-0x3ffc6fa0(%ebx)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c00233ea:	89 f8                	mov    %edi,%eax
c00233ec:	ba 00 00 00 00       	mov    $0x0,%edx
c00233f1:	f7 f6                	div    %esi
c00233f3:	89 83 64 90 03 c0    	mov    %eax,-0x3ffc6f9c(%ebx)
      list_init (&d->free_list);
c00233f9:	83 ec 0c             	sub    $0xc,%esp
c00233fc:	8d 8b 68 90 03 c0    	lea    -0x3ffc6f98(%ebx),%ecx
c0023402:	51                   	push   %ecx
c0023403:	e8 6c 49 00 00       	call   c0027d74 <list_init>
      lock_init (&d->lock);
c0023408:	81 c3 78 90 03 c0    	add    $0xc0039078,%ebx
c002340e:	89 1c 24             	mov    %ebx,(%esp)
c0023411:	e8 27 f5 ff ff       	call   c002293d <lock_init>
void
malloc_init (void) 
{
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023416:	01 f6                	add    %esi,%esi
c0023418:	83 c4 10             	add    $0x10,%esp
c002341b:	81 fe ff 07 00 00    	cmp    $0x7ff,%esi
c0023421:	76 8d                	jbe    c00233b0 <malloc_init+0x18>
c0023423:	eb 46                	jmp    c002346b <malloc_init+0xd3>
    {
      struct desc *d = &descs[desc_cnt++];
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
      d->block_size = block_size;
c0023425:	6b db 38             	imul   $0x38,%ebx,%ebx
c0023428:	c7 83 60 90 03 c0 10 	movl   $0x10,-0x3ffc6fa0(%ebx)
c002342f:	00 00 00 
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023432:	c7 83 64 90 03 c0 ff 	movl   $0xff,-0x3ffc6f9c(%ebx)
c0023439:	00 00 00 
      list_init (&d->free_list);
c002343c:	83 ec 0c             	sub    $0xc,%esp
c002343f:	8d 83 68 90 03 c0    	lea    -0x3ffc6f98(%ebx),%eax
c0023445:	50                   	push   %eax
c0023446:	e8 29 49 00 00       	call   c0027d74 <list_init>
      lock_init (&d->lock);
c002344b:	81 c3 78 90 03 c0    	add    $0xc0039078,%ebx
c0023451:	89 1c 24             	mov    %ebx,(%esp)
c0023454:	e8 e4 f4 ff ff       	call   c002293d <lock_init>
c0023459:	83 c4 10             	add    $0x10,%esp
void
malloc_init (void) 
{
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002345c:	be 20 00 00 00       	mov    $0x20,%esi
    {
      struct desc *d = &descs[desc_cnt++];
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
      d->block_size = block_size;
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023461:	bf f4 0f 00 00       	mov    $0xff4,%edi
c0023466:	e9 45 ff ff ff       	jmp    c00233b0 <malloc_init+0x18>
      list_init (&d->free_list);
      lock_init (&d->lock);
    }
}
c002346b:	5b                   	pop    %ebx
c002346c:	5e                   	pop    %esi
c002346d:	5f                   	pop    %edi
c002346e:	c3                   	ret    

c002346f <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c002346f:	55                   	push   %ebp
c0023470:	57                   	push   %edi
c0023471:	56                   	push   %esi
c0023472:	53                   	push   %ebx
c0023473:	83 ec 1c             	sub    $0x1c,%esp
c0023476:	8b 54 24 30          	mov    0x30(%esp),%edx
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c002347a:	85 d2                	test   %edx,%edx
c002347c:	0f 84 20 01 00 00    	je     c00235a2 <malloc+0x133>
    return NULL;

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023482:	6b 05 40 90 03 c0 38 	imul   $0x38,0xc0039040,%eax
c0023489:	05 60 90 03 c0       	add    $0xc0039060,%eax
c002348e:	3d 60 90 03 c0       	cmp    $0xc0039060,%eax
c0023493:	76 1c                	jbe    c00234b1 <malloc+0x42>
    if (d->block_size >= size)
c0023495:	3b 15 60 90 03 c0    	cmp    0xc0039060,%edx
c002349b:	76 1b                	jbe    c00234b8 <malloc+0x49>
c002349d:	bb 60 90 03 c0       	mov    $0xc0039060,%ebx
c00234a2:	eb 04                	jmp    c00234a8 <malloc+0x39>
c00234a4:	3b 13                	cmp    (%ebx),%edx
c00234a6:	76 15                	jbe    c00234bd <malloc+0x4e>
  if (size == 0)
    return NULL;

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c00234a8:	83 c3 38             	add    $0x38,%ebx
c00234ab:	39 c3                	cmp    %eax,%ebx
c00234ad:	72 f5                	jb     c00234a4 <malloc+0x35>
c00234af:	eb 0c                	jmp    c00234bd <malloc+0x4e>
c00234b1:	bb 60 90 03 c0       	mov    $0xc0039060,%ebx
c00234b6:	eb 05                	jmp    c00234bd <malloc+0x4e>
    if (d->block_size >= size)
c00234b8:	bb 60 90 03 c0       	mov    $0xc0039060,%ebx
      break;
  if (d == descs + desc_cnt) 
c00234bd:	39 d8                	cmp    %ebx,%eax
c00234bf:	75 37                	jne    c00234f8 <malloc+0x89>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00234c1:	8d 9a 0b 10 00 00    	lea    0x100b(%edx),%ebx
c00234c7:	c1 eb 0c             	shr    $0xc,%ebx
      a = palloc_get_multiple (0, page_cnt);
c00234ca:	83 ec 08             	sub    $0x8,%esp
c00234cd:	53                   	push   %ebx
c00234ce:	6a 00                	push   $0x0
c00234d0:	e8 89 fb ff ff       	call   c002305e <palloc_get_multiple>
      if (a == NULL)
c00234d5:	83 c4 10             	add    $0x10,%esp
c00234d8:	85 c0                	test   %eax,%eax
c00234da:	0f 84 c9 00 00 00    	je     c00235a9 <malloc+0x13a>
        return NULL;

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c00234e0:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c00234e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c00234ed:	89 58 08             	mov    %ebx,0x8(%eax)
      return a + 1;
c00234f0:	83 c0 0c             	add    $0xc,%eax
c00234f3:	e9 b6 00 00 00       	jmp    c00235ae <malloc+0x13f>
    }

  lock_acquire (&d->lock);
c00234f8:	8d 43 18             	lea    0x18(%ebx),%eax
c00234fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
c00234ff:	83 ec 0c             	sub    $0xc,%esp
c0023502:	50                   	push   %eax
c0023503:	e8 b7 f4 ff ff       	call   c00229bf <lock_acquire>

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023508:	8d 7b 08             	lea    0x8(%ebx),%edi
c002350b:	89 3c 24             	mov    %edi,(%esp)
c002350e:	e8 af 4d 00 00       	call   c00282c2 <list_empty>
c0023513:	83 c4 10             	add    $0x10,%esp
c0023516:	84 c0                	test   %al,%al
c0023518:	74 61                	je     c002357b <malloc+0x10c>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c002351a:	83 ec 0c             	sub    $0xc,%esp
c002351d:	6a 00                	push   $0x0
c002351f:	e8 e2 fb ff ff       	call   c0023106 <palloc_get_page>
c0023524:	89 c5                	mov    %eax,%ebp
      if (a == NULL) 
c0023526:	83 c4 10             	add    $0x10,%esp
c0023529:	85 c0                	test   %eax,%eax
c002352b:	75 16                	jne    c0023543 <malloc+0xd4>
        {
          lock_release (&d->lock);
c002352d:	83 ec 0c             	sub    $0xc,%esp
c0023530:	ff 74 24 18          	pushl  0x18(%esp)
c0023534:	e8 16 f6 ff ff       	call   c0022b4f <lock_release>
          return NULL; 
c0023539:	83 c4 10             	add    $0x10,%esp
c002353c:	b8 00 00 00 00       	mov    $0x0,%eax
c0023541:	eb 6b                	jmp    c00235ae <malloc+0x13f>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0023543:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023549:	89 58 04             	mov    %ebx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c002354c:	8b 43 04             	mov    0x4(%ebx),%eax
c002354f:	89 45 08             	mov    %eax,0x8(%ebp)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023552:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0023556:	74 23                	je     c002357b <malloc+0x10c>
c0023558:	be 00 00 00 00       	mov    $0x0,%esi
        {
          struct block *b = arena_to_block (a, i);
c002355d:	89 f2                	mov    %esi,%edx
c002355f:	89 e8                	mov    %ebp,%eax
c0023561:	e8 e8 fc ff ff       	call   c002324e <arena_to_block>
          list_push_back (&d->free_list, &b->free_elem);
c0023566:	83 ec 08             	sub    $0x8,%esp
c0023569:	50                   	push   %eax
c002356a:	57                   	push   %edi
c002356b:	e8 a8 4c 00 00       	call   c0028218 <list_push_back>

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
      a->desc = d;
      a->free_cnt = d->blocks_per_arena;
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023570:	83 c6 01             	add    $0x1,%esi
c0023573:	83 c4 10             	add    $0x10,%esp
c0023576:	39 73 04             	cmp    %esi,0x4(%ebx)
c0023579:	77 e2                	ja     c002355d <malloc+0xee>
          list_push_back (&d->free_list, &b->free_elem);
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c002357b:	83 ec 0c             	sub    $0xc,%esp
c002357e:	57                   	push   %edi
c002357f:	e8 a0 4d 00 00       	call   c0028324 <list_pop_front>
c0023584:	89 c3                	mov    %eax,%ebx
  a = block_to_arena (b);
c0023586:	e8 48 fd ff ff       	call   c00232d3 <block_to_arena>
  a->free_cnt--;
c002358b:	83 68 08 01          	subl   $0x1,0x8(%eax)
  lock_release (&d->lock);
c002358f:	83 c4 04             	add    $0x4,%esp
c0023592:	ff 74 24 18          	pushl  0x18(%esp)
c0023596:	e8 b4 f5 ff ff       	call   c0022b4f <lock_release>
  return b;
c002359b:	83 c4 10             	add    $0x10,%esp
c002359e:	89 d8                	mov    %ebx,%eax
c00235a0:	eb 0c                	jmp    c00235ae <malloc+0x13f>
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
    return NULL;
c00235a2:	b8 00 00 00 00       	mov    $0x0,%eax
c00235a7:	eb 05                	jmp    c00235ae <malloc+0x13f>
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
      a = palloc_get_multiple (0, page_cnt);
      if (a == NULL)
        return NULL;
c00235a9:	b8 00 00 00 00       	mov    $0x0,%eax
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
  a = block_to_arena (b);
  a->free_cnt--;
  lock_release (&d->lock);
  return b;
}
c00235ae:	83 c4 1c             	add    $0x1c,%esp
c00235b1:	5b                   	pop    %ebx
c00235b2:	5e                   	pop    %esi
c00235b3:	5f                   	pop    %edi
c00235b4:	5d                   	pop    %ebp
c00235b5:	c3                   	ret    

c00235b6 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c00235b6:	56                   	push   %esi
c00235b7:	53                   	push   %ebx
c00235b8:	83 ec 04             	sub    $0x4,%esp
c00235bb:	8b 44 24 10          	mov    0x10(%esp),%eax
c00235bf:	8b 54 24 14          	mov    0x14(%esp),%edx
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c00235c3:	89 c3                	mov    %eax,%ebx
c00235c5:	0f af da             	imul   %edx,%ebx
  if (size < a || size < b)
c00235c8:	39 d8                	cmp    %ebx,%eax
c00235ca:	77 29                	ja     c00235f5 <calloc+0x3f>
c00235cc:	39 da                	cmp    %ebx,%edx
c00235ce:	77 25                	ja     c00235f5 <calloc+0x3f>
    return NULL;

  /* Allocate and zero memory. */
  p = malloc (size);
c00235d0:	83 ec 0c             	sub    $0xc,%esp
c00235d3:	53                   	push   %ebx
c00235d4:	e8 96 fe ff ff       	call   c002346f <malloc>
c00235d9:	89 c6                	mov    %eax,%esi
  if (p != NULL)
c00235db:	83 c4 10             	add    $0x10,%esp
c00235de:	85 c0                	test   %eax,%eax
c00235e0:	74 18                	je     c00235fa <calloc+0x44>
    memset (p, 0, size);
c00235e2:	83 ec 04             	sub    $0x4,%esp
c00235e5:	53                   	push   %ebx
c00235e6:	6a 00                	push   $0x0
c00235e8:	50                   	push   %eax
c00235e9:	e8 b6 3c 00 00       	call   c00272a4 <memset>
c00235ee:	83 c4 10             	add    $0x10,%esp

  return p;
c00235f1:	89 f0                	mov    %esi,%eax
c00235f3:	eb 05                	jmp    c00235fa <calloc+0x44>
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
  if (size < a || size < b)
    return NULL;
c00235f5:	b8 00 00 00 00       	mov    $0x0,%eax
  p = malloc (size);
  if (p != NULL)
    memset (p, 0, size);

  return p;
}
c00235fa:	83 c4 04             	add    $0x4,%esp
c00235fd:	5b                   	pop    %ebx
c00235fe:	5e                   	pop    %esi
c00235ff:	c3                   	ret    

c0023600 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023600:	55                   	push   %ebp
c0023601:	57                   	push   %edi
c0023602:	56                   	push   %esi
c0023603:	53                   	push   %ebx
c0023604:	83 ec 0c             	sub    $0xc,%esp
c0023607:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  if (p != NULL)
c002360b:	85 db                	test   %ebx,%ebx
c002360d:	0f 84 c5 00 00 00    	je     c00236d8 <free+0xd8>
    {
      struct block *b = p;
      struct arena *a = block_to_arena (b);
c0023613:	89 d8                	mov    %ebx,%eax
c0023615:	e8 b9 fc ff ff       	call   c00232d3 <block_to_arena>
c002361a:	89 c7                	mov    %eax,%edi
      struct desc *d = a->desc;
c002361c:	8b 70 04             	mov    0x4(%eax),%esi
      
      if (d != NULL) 
c002361f:	85 f6                	test   %esi,%esi
c0023621:	0f 84 a2 00 00 00    	je     c00236c9 <free+0xc9>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c0023627:	83 ec 04             	sub    $0x4,%esp
c002362a:	ff 36                	pushl  (%esi)
c002362c:	68 cc 00 00 00       	push   $0xcc
c0023631:	53                   	push   %ebx
c0023632:	e8 6d 3c 00 00       	call   c00272a4 <memset>
#endif
  
          lock_acquire (&d->lock);
c0023637:	8d 6e 18             	lea    0x18(%esi),%ebp
c002363a:	89 2c 24             	mov    %ebp,(%esp)
c002363d:	e8 7d f3 ff ff       	call   c00229bf <lock_acquire>

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c0023642:	83 c4 08             	add    $0x8,%esp
c0023645:	53                   	push   %ebx
c0023646:	8d 46 08             	lea    0x8(%esi),%eax
c0023649:	50                   	push   %eax
c002364a:	e8 ac 4b 00 00       	call   c00281fb <list_push_front>

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c002364f:	8b 47 08             	mov    0x8(%edi),%eax
c0023652:	83 c0 01             	add    $0x1,%eax
c0023655:	89 47 08             	mov    %eax,0x8(%edi)
c0023658:	8b 56 04             	mov    0x4(%esi),%edx
c002365b:	83 c4 10             	add    $0x10,%esp
c002365e:	39 d0                	cmp    %edx,%eax
c0023660:	72 59                	jb     c00236bb <free+0xbb>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023662:	39 d0                	cmp    %edx,%eax
c0023664:	75 0b                	jne    c0023671 <free+0x71>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023666:	bb 00 00 00 00       	mov    $0x0,%ebx
c002366b:	85 c0                	test   %eax,%eax
c002366d:	75 23                	jne    c0023692 <free+0x92>
c002366f:	eb 3e                	jmp    c00236af <free+0xaf>
          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023671:	83 ec 0c             	sub    $0xc,%esp
c0023674:	68 0c dd 02 c0       	push   $0xc002dd0c
c0023679:	68 3f d2 02 c0       	push   $0xc002d23f
c002367e:	68 74 bd 02 c0       	push   $0xc002bd74
c0023683:	68 f6 00 00 00       	push   $0xf6
c0023688:	68 1d dc 02 c0       	push   $0xc002dc1d
c002368d:	e8 3b 46 00 00       	call   c0027ccd <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
                {
                  struct block *b = arena_to_block (a, i);
c0023692:	89 da                	mov    %ebx,%edx
c0023694:	89 f8                	mov    %edi,%eax
c0023696:	e8 b3 fb ff ff       	call   c002324e <arena_to_block>
                  list_remove (&b->free_elem);
c002369b:	83 ec 0c             	sub    $0xc,%esp
c002369e:	50                   	push   %eax
c002369f:	e8 91 4b 00 00       	call   c0028235 <list_remove>
          if (++a->free_cnt >= d->blocks_per_arena) 
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
              for (i = 0; i < d->blocks_per_arena; i++) 
c00236a4:	83 c3 01             	add    $0x1,%ebx
c00236a7:	83 c4 10             	add    $0x10,%esp
c00236aa:	39 5e 04             	cmp    %ebx,0x4(%esi)
c00236ad:	77 e3                	ja     c0023692 <free+0x92>
                {
                  struct block *b = arena_to_block (a, i);
                  list_remove (&b->free_elem);
                }
              palloc_free_page (a);
c00236af:	83 ec 0c             	sub    $0xc,%esp
c00236b2:	57                   	push   %edi
c00236b3:	e8 84 fb ff ff       	call   c002323c <palloc_free_page>
c00236b8:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c00236bb:	83 ec 0c             	sub    $0xc,%esp
c00236be:	55                   	push   %ebp
c00236bf:	e8 8b f4 ff ff       	call   c0022b4f <lock_release>
c00236c4:	83 c4 10             	add    $0x10,%esp
c00236c7:	eb 0f                	jmp    c00236d8 <free+0xd8>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c00236c9:	83 ec 08             	sub    $0x8,%esp
c00236cc:	ff 70 08             	pushl  0x8(%eax)
c00236cf:	50                   	push   %eax
c00236d0:	e8 43 fa ff ff       	call   c0023118 <palloc_free_multiple>
          return;
c00236d5:	83 c4 10             	add    $0x10,%esp
        }
    }
}
c00236d8:	83 c4 0c             	add    $0xc,%esp
c00236db:	5b                   	pop    %ebx
c00236dc:	5e                   	pop    %esi
c00236dd:	5f                   	pop    %edi
c00236de:	5d                   	pop    %ebp
c00236df:	c3                   	ret    

c00236e0 <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c00236e0:	57                   	push   %edi
c00236e1:	56                   	push   %esi
c00236e2:	53                   	push   %ebx
c00236e3:	8b 7c 24 10          	mov    0x10(%esp),%edi
c00236e7:	8b 74 24 14          	mov    0x14(%esp),%esi
  if (new_size == 0) 
c00236eb:	85 f6                	test   %esi,%esi
c00236ed:	75 13                	jne    c0023702 <realloc+0x22>
    {
      free (old_block);
c00236ef:	83 ec 0c             	sub    $0xc,%esp
c00236f2:	57                   	push   %edi
c00236f3:	e8 08 ff ff ff       	call   c0023600 <free>
      return NULL;
c00236f8:	83 c4 10             	add    $0x10,%esp
c00236fb:	b8 00 00 00 00       	mov    $0x0,%eax
c0023700:	eb 59                	jmp    c002375b <realloc+0x7b>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023702:	83 ec 0c             	sub    $0xc,%esp
c0023705:	56                   	push   %esi
c0023706:	e8 64 fd ff ff       	call   c002346f <malloc>
c002370b:	89 c3                	mov    %eax,%ebx
      if (old_block != NULL && new_block != NULL)
c002370d:	83 c4 10             	add    $0x10,%esp
c0023710:	85 ff                	test   %edi,%edi
c0023712:	74 45                	je     c0023759 <realloc+0x79>
c0023714:	85 c0                	test   %eax,%eax
c0023716:	74 41                	je     c0023759 <realloc+0x79>
/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
  struct block *b = block;
  struct arena *a = block_to_arena (b);
c0023718:	89 f8                	mov    %edi,%eax
c002371a:	e8 b4 fb ff ff       	call   c00232d3 <block_to_arena>
  struct desc *d = a->desc;
c002371f:	8b 50 04             	mov    0x4(%eax),%edx

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023722:	85 d2                	test   %edx,%edx
c0023724:	74 04                	je     c002372a <realloc+0x4a>
c0023726:	8b 02                	mov    (%edx),%eax
c0023728:	eb 10                	jmp    c002373a <realloc+0x5a>
c002372a:	8b 40 08             	mov    0x8(%eax),%eax
c002372d:	c1 e0 0c             	shl    $0xc,%eax
c0023730:	89 fa                	mov    %edi,%edx
c0023732:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0023738:	29 d0                	sub    %edx,%eax
      void *new_block = malloc (new_size);
      if (old_block != NULL && new_block != NULL)
        {
          size_t old_size = block_size (old_block);
          size_t min_size = new_size < old_size ? new_size : old_size;
          memcpy (new_block, old_block, min_size);
c002373a:	39 c6                	cmp    %eax,%esi
c002373c:	0f 47 f0             	cmova  %eax,%esi
c002373f:	83 ec 04             	sub    $0x4,%esp
c0023742:	56                   	push   %esi
c0023743:	57                   	push   %edi
c0023744:	53                   	push   %ebx
c0023745:	e8 4d 36 00 00       	call   c0026d97 <memcpy>
          free (old_block);
c002374a:	89 3c 24             	mov    %edi,(%esp)
c002374d:	e8 ae fe ff ff       	call   c0023600 <free>
c0023752:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023755:	89 d8                	mov    %ebx,%eax
c0023757:	eb 02                	jmp    c002375b <realloc+0x7b>
c0023759:	89 d8                	mov    %ebx,%eax
    }
}
c002375b:	5b                   	pop    %ebx
c002375c:	5e                   	pop    %esi
c002375d:	5f                   	pop    %edi
c002375e:	c3                   	ret    

c002375f <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c002375f:	57                   	push   %edi
c0023760:	56                   	push   %esi
c0023761:	53                   	push   %ebx
c0023762:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0023766:	8b 74 24 14          	mov    0x14(%esp),%esi
c002376a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c002376e:	f7 c3 fd ff ff ff    	test   $0xfffffffd,%ebx
c0023774:	74 1e                	je     c0023794 <pit_configure_channel+0x35>
c0023776:	83 ec 0c             	sub    $0xc,%esp
c0023779:	68 2f dd 02 c0       	push   $0xc002dd2f
c002377e:	68 3f d2 02 c0       	push   $0xc002d23f
c0023783:	68 a8 bd 02 c0       	push   $0xc002bda8
c0023788:	6a 33                	push   $0x33
c002378a:	68 4c dd 02 c0       	push   $0xc002dd4c
c002378f:	e8 39 45 00 00       	call   c0027ccd <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023794:	8d 46 fe             	lea    -0x2(%esi),%eax
c0023797:	83 f8 01             	cmp    $0x1,%eax
c002379a:	76 1e                	jbe    c00237ba <pit_configure_channel+0x5b>
c002379c:	83 ec 0c             	sub    $0xc,%esp
c002379f:	68 60 dd 02 c0       	push   $0xc002dd60
c00237a4:	68 3f d2 02 c0       	push   $0xc002d23f
c00237a9:	68 a8 bd 02 c0       	push   $0xc002bda8
c00237ae:	6a 34                	push   $0x34
c00237b0:	68 4c dd 02 c0       	push   $0xc002dd4c
c00237b5:	e8 13 45 00 00       	call   c0027ccd <debug_panic>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c00237ba:	bf 00 00 00 00       	mov    $0x0,%edi
  ASSERT (mode == 2 || mode == 3);

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c00237bf:	83 f9 12             	cmp    $0x12,%ecx
c00237c2:	7e 20                	jle    c00237e4 <pit_configure_channel+0x85>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c00237c4:	bf 02 00 00 00       	mov    $0x2,%edi
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
    }
  else if (frequency > PIT_HZ)
c00237c9:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c00237cf:	7f 13                	jg     c00237e4 <pit_configure_channel+0x85>
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c00237d1:	89 c8                	mov    %ecx,%eax
c00237d3:	c1 e8 1f             	shr    $0x1f,%eax
c00237d6:	01 c8                	add    %ecx,%eax
c00237d8:	d1 f8                	sar    %eax
c00237da:	05 dc 34 12 00       	add    $0x1234dc,%eax
c00237df:	99                   	cltd   
c00237e0:	f7 f9                	idiv   %ecx
c00237e2:	89 c7                	mov    %eax,%edi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c00237e4:	e8 a7 de ff ff       	call   c0021690 <intr_disable>
c00237e9:	89 c1                	mov    %eax,%ecx
c00237eb:	01 f6                	add    %esi,%esi
c00237ed:	83 ce 30             	or     $0x30,%esi
c00237f0:	89 d8                	mov    %ebx,%eax
c00237f2:	c1 e0 06             	shl    $0x6,%eax
c00237f5:	09 f0                	or     %esi,%eax
c00237f7:	e6 43                	out    %al,$0x43
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
  outb (PIT_PORT_COUNTER (channel), count);
c00237f9:	8d 53 40             	lea    0x40(%ebx),%edx
c00237fc:	89 f8                	mov    %edi,%eax
c00237fe:	ee                   	out    %al,(%dx)
c00237ff:	89 f8                	mov    %edi,%eax
c0023801:	66 c1 e8 08          	shr    $0x8,%ax
c0023805:	ee                   	out    %al,(%dx)
  outb (PIT_PORT_COUNTER (channel), count >> 8);
  intr_set_level (old_level);
c0023806:	83 ec 0c             	sub    $0xc,%esp
c0023809:	51                   	push   %ecx
c002380a:	e8 88 de ff ff       	call   c0021697 <intr_set_level>
}
c002380f:	83 c4 10             	add    $0x10,%esp
c0023812:	5b                   	pop    %ebx
c0023813:	5e                   	pop    %esi
c0023814:	5f                   	pop    %edi
c0023815:	c3                   	ret    

c0023816 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023816:	53                   	push   %ebx
  while (loops-- > 0)
c0023817:	89 c1                	mov    %eax,%ecx
c0023819:	89 d3                	mov    %edx,%ebx
c002381b:	83 c1 ff             	add    $0xffffffff,%ecx
c002381e:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023821:	85 d2                	test   %edx,%edx
c0023823:	78 18                	js     c002383d <busy_wait+0x27>
c0023825:	85 d2                	test   %edx,%edx
c0023827:	7f 05                	jg     c002382e <busy_wait+0x18>
c0023829:	83 f8 00             	cmp    $0x0,%eax
c002382c:	76 0f                	jbe    c002383d <busy_wait+0x27>
c002382e:	83 c1 ff             	add    $0xffffffff,%ecx
c0023831:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023834:	89 c8                	mov    %ecx,%eax
c0023836:	21 d8                	and    %ebx,%eax
c0023838:	83 f8 ff             	cmp    $0xffffffff,%eax
c002383b:	75 f1                	jne    c002382e <busy_wait+0x18>
    barrier ();
}
c002383d:	5b                   	pop    %ebx
c002383e:	c3                   	ret    

c002383f <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c002383f:	55                   	push   %ebp
c0023840:	57                   	push   %edi
c0023841:	56                   	push   %esi
c0023842:	53                   	push   %ebx
c0023843:	83 ec 04             	sub    $0x4,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c0023846:	8b 2d 98 92 03 c0    	mov    0xc0039298,%ebp
c002384c:	8b 3d 9c 92 03 c0    	mov    0xc003929c,%edi
  while (ticks == start)
c0023852:	8b 35 98 92 03 c0    	mov    0xc0039298,%esi
c0023858:	8b 1d 9c 92 03 c0    	mov    0xc003929c,%ebx
c002385e:	89 f9                	mov    %edi,%ecx
c0023860:	31 d9                	xor    %ebx,%ecx
c0023862:	89 ea                	mov    %ebp,%edx
c0023864:	31 f2                	xor    %esi,%edx
c0023866:	09 d1                	or     %edx,%ecx
c0023868:	74 e8                	je     c0023852 <too_many_loops+0x13>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
  busy_wait (loops);
c002386a:	ba 00 00 00 00       	mov    $0x0,%edx
c002386f:	e8 a2 ff ff ff       	call   c0023816 <busy_wait>

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0023874:	33 35 98 92 03 c0    	xor    0xc0039298,%esi
c002387a:	33 1d 9c 92 03 c0    	xor    0xc003929c,%ebx
c0023880:	09 de                	or     %ebx,%esi
c0023882:	0f 95 c0             	setne  %al
}
c0023885:	83 c4 04             	add    $0x4,%esp
c0023888:	5b                   	pop    %ebx
c0023889:	5e                   	pop    %esi
c002388a:	5f                   	pop    %edi
c002388b:	5d                   	pop    %ebp
c002388c:	c3                   	ret    

c002388d <timer_interrupt>:
}

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{ 
c002388d:	83 ec 0c             	sub    $0xc,%esp
  ticks++;
c0023890:	83 05 98 92 03 c0 01 	addl   $0x1,0xc0039298
c0023897:	83 15 9c 92 03 c0 00 	adcl   $0x0,0xc003929c
  thread_tick ();
c002389e:	e8 9c d1 ff ff       	call   c0020a3f <thread_tick>
  thread_foreachsleep();
c00238a3:	e8 ab db ff ff       	call   c0021453 <thread_foreachsleep>
}
c00238a8:	83 c4 0c             	add    $0xc,%esp
c00238ab:	c3                   	ret    

c00238ac <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c00238ac:	57                   	push   %edi
c00238ad:	56                   	push   %esi
c00238ae:	53                   	push   %ebx
c00238af:	89 c7                	mov    %eax,%edi
c00238b1:	89 d6                	mov    %edx,%esi
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c00238b3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00238b8:	89 c8                	mov    %ecx,%eax
c00238ba:	f7 ea                	imul   %edx
c00238bc:	c1 fa 06             	sar    $0x6,%edx
c00238bf:	89 c8                	mov    %ecx,%eax
c00238c1:	c1 f8 1f             	sar    $0x1f,%eax
c00238c4:	29 c2                	sub    %eax,%edx
c00238c6:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c00238cc:	39 d1                	cmp    %edx,%ecx
c00238ce:	74 21                	je     c00238f1 <real_time_delay+0x45>
c00238d0:	83 ec 0c             	sub    $0xc,%esp
c00238d3:	68 77 dd 02 c0       	push   $0xc002dd77
c00238d8:	68 3f d2 02 c0       	push   $0xc002d23f
c00238dd:	68 c0 bd 02 c0       	push   $0xc002bdc0
c00238e2:	68 fb 00 00 00       	push   $0xfb
c00238e7:	68 89 dd 02 c0       	push   $0xc002dd89
c00238ec:	e8 dc 43 00 00       	call   c0027ccd <debug_panic>
c00238f1:	89 cb                	mov    %ecx,%ebx
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00238f3:	a1 90 92 03 c0       	mov    0xc0039290,%eax
c00238f8:	0f af f0             	imul   %eax,%esi
c00238fb:	f7 e7                	mul    %edi
c00238fd:	01 f2                	add    %esi,%edx
c00238ff:	6a 00                	push   $0x0
c0023901:	68 e8 03 00 00       	push   $0x3e8
c0023906:	52                   	push   %edx
c0023907:	50                   	push   %eax
c0023908:	e8 f4 3d 00 00       	call   c0027701 <__divdi3>
c002390d:	83 c4 10             	add    $0x10,%esp
c0023910:	89 c6                	mov    %eax,%esi
c0023912:	6b ca 64             	imul   $0x64,%edx,%ecx
c0023915:	bf 64 00 00 00       	mov    $0x64,%edi
c002391a:	89 f8                	mov    %edi,%eax
c002391c:	f7 e6                	mul    %esi
c002391e:	89 c6                	mov    %eax,%esi
c0023920:	89 d7                	mov    %edx,%edi
c0023922:	01 cf                	add    %ecx,%edi
c0023924:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0023929:	89 d8                	mov    %ebx,%eax
c002392b:	f7 ea                	imul   %edx
c002392d:	89 d0                	mov    %edx,%eax
c002392f:	c1 f8 06             	sar    $0x6,%eax
c0023932:	c1 fb 1f             	sar    $0x1f,%ebx
c0023935:	29 d8                	sub    %ebx,%eax
c0023937:	99                   	cltd   
c0023938:	52                   	push   %edx
c0023939:	50                   	push   %eax
c002393a:	57                   	push   %edi
c002393b:	56                   	push   %esi
c002393c:	e8 c0 3d 00 00       	call   c0027701 <__divdi3>
c0023941:	83 c4 10             	add    $0x10,%esp
c0023944:	e8 cd fe ff ff       	call   c0023816 <busy_wait>
}
c0023949:	5b                   	pop    %ebx
c002394a:	5e                   	pop    %esi
c002394b:	5f                   	pop    %edi
c002394c:	c3                   	ret    

c002394d <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c002394d:	83 ec 10             	sub    $0x10,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023950:	6a 64                	push   $0x64
c0023952:	6a 02                	push   $0x2
c0023954:	6a 00                	push   $0x0
c0023956:	e8 04 fe ff ff       	call   c002375f <pit_configure_channel>
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c002395b:	83 c4 0c             	add    $0xc,%esp
c002395e:	68 9f dd 02 c0       	push   $0xc002dd9f
c0023963:	68 8d 38 02 c0       	push   $0xc002388d
c0023968:	6a 20                	push   $0x20
c002396a:	e8 c0 de ff ff       	call   c002182f <intr_register_ext>
}
c002396f:	83 c4 1c             	add    $0x1c,%esp
c0023972:	c3                   	ret    

c0023973 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023973:	57                   	push   %edi
c0023974:	56                   	push   %esi
c0023975:	53                   	push   %ebx
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023976:	e8 d8 dc ff ff       	call   c0021653 <intr_get_level>
c002397b:	83 f8 01             	cmp    $0x1,%eax
c002397e:	74 1e                	je     c002399e <timer_calibrate+0x2b>
c0023980:	83 ec 0c             	sub    $0xc,%esp
c0023983:	68 aa dd 02 c0       	push   $0xc002ddaa
c0023988:	68 3f d2 02 c0       	push   $0xc002d23f
c002398d:	68 ec bd 02 c0       	push   $0xc002bdec
c0023992:	6a 32                	push   $0x32
c0023994:	68 89 dd 02 c0       	push   $0xc002dd89
c0023999:	e8 2f 43 00 00       	call   c0027ccd <debug_panic>
  printf ("Calibrating timer...  ");
c002399e:	83 ec 0c             	sub    $0xc,%esp
c00239a1:	68 c7 dd 02 c0       	push   $0xc002ddc7
c00239a6:	e8 aa 26 00 00       	call   c0026055 <printf>

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c00239ab:	c7 05 90 92 03 c0 00 	movl   $0x400,0xc0039290
c00239b2:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c00239b5:	83 c4 10             	add    $0x10,%esp
c00239b8:	eb 28                	jmp    c00239e2 <timer_calibrate+0x6f>
    {
      loops_per_tick <<= 1;
c00239ba:	89 1d 90 92 03 c0    	mov    %ebx,0xc0039290
      ASSERT (loops_per_tick != 0);
c00239c0:	85 db                	test   %ebx,%ebx
c00239c2:	75 1e                	jne    c00239e2 <timer_calibrate+0x6f>
c00239c4:	83 ec 0c             	sub    $0xc,%esp
c00239c7:	68 de dd 02 c0       	push   $0xc002ddde
c00239cc:	68 3f d2 02 c0       	push   $0xc002d23f
c00239d1:	68 ec bd 02 c0       	push   $0xc002bdec
c00239d6:	6a 3b                	push   $0x3b
c00239d8:	68 89 dd 02 c0       	push   $0xc002dd89
c00239dd:	e8 eb 42 00 00       	call   c0027ccd <debug_panic>
  printf ("Calibrating timer...  ");

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
  while (!too_many_loops (loops_per_tick << 1)) 
c00239e2:	8b 35 90 92 03 c0    	mov    0xc0039290,%esi
c00239e8:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
c00239eb:	89 d8                	mov    %ebx,%eax
c00239ed:	e8 4d fe ff ff       	call   c002383f <too_many_loops>
c00239f2:	84 c0                	test   %al,%al
c00239f4:	74 c4                	je     c00239ba <timer_calibrate+0x47>
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00239f6:	89 f3                	mov    %esi,%ebx
c00239f8:	d1 eb                	shr    %ebx
c00239fa:	89 f7                	mov    %esi,%edi
c00239fc:	c1 ef 0a             	shr    $0xa,%edi
c00239ff:	39 df                	cmp    %ebx,%edi
c0023a01:	74 19                	je     c0023a1c <timer_calibrate+0xa9>
    if (!too_many_loops (high_bit | test_bit))
c0023a03:	89 f0                	mov    %esi,%eax
c0023a05:	09 d8                	or     %ebx,%eax
c0023a07:	e8 33 fe ff ff       	call   c002383f <too_many_loops>
c0023a0c:	84 c0                	test   %al,%al
c0023a0e:	75 06                	jne    c0023a16 <timer_calibrate+0xa3>
      loops_per_tick |= test_bit;
c0023a10:	09 1d 90 92 03 c0    	or     %ebx,0xc0039290
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023a16:	d1 eb                	shr    %ebx
c0023a18:	39 df                	cmp    %ebx,%edi
c0023a1a:	75 e7                	jne    c0023a03 <timer_calibrate+0x90>
    if (!too_many_loops (high_bit | test_bit))
      loops_per_tick |= test_bit;

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023a1c:	83 ec 04             	sub    $0x4,%esp
c0023a1f:	b8 64 00 00 00       	mov    $0x64,%eax
c0023a24:	f7 25 90 92 03 c0    	mull   0xc0039290
c0023a2a:	52                   	push   %edx
c0023a2b:	50                   	push   %eax
c0023a2c:	68 f2 dd 02 c0       	push   $0xc002ddf2
c0023a31:	e8 1f 26 00 00       	call   c0026055 <printf>
}
c0023a36:	83 c4 10             	add    $0x10,%esp
c0023a39:	5b                   	pop    %ebx
c0023a3a:	5e                   	pop    %esi
c0023a3b:	5f                   	pop    %edi
c0023a3c:	c3                   	ret    

c0023a3d <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023a3d:	57                   	push   %edi
c0023a3e:	56                   	push   %esi
c0023a3f:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level = intr_disable ();
c0023a42:	e8 49 dc ff ff       	call   c0021690 <intr_disable>
  int64_t t = ticks;
c0023a47:	8b 35 98 92 03 c0    	mov    0xc0039298,%esi
c0023a4d:	8b 3d 9c 92 03 c0    	mov    0xc003929c,%edi
  intr_set_level (old_level);
c0023a53:	83 ec 0c             	sub    $0xc,%esp
c0023a56:	50                   	push   %eax
c0023a57:	e8 3b dc ff ff       	call   c0021697 <intr_set_level>
  return t;
}
c0023a5c:	89 f0                	mov    %esi,%eax
c0023a5e:	89 fa                	mov    %edi,%edx
c0023a60:	83 c4 14             	add    $0x14,%esp
c0023a63:	5e                   	pop    %esi
c0023a64:	5f                   	pop    %edi
c0023a65:	c3                   	ret    

c0023a66 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023a66:	57                   	push   %edi
c0023a67:	56                   	push   %esi
c0023a68:	83 ec 04             	sub    $0x4,%esp
c0023a6b:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023a6f:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks () - then;
c0023a73:	e8 c5 ff ff ff       	call   c0023a3d <timer_ticks>
c0023a78:	29 f0                	sub    %esi,%eax
c0023a7a:	19 fa                	sbb    %edi,%edx
}
c0023a7c:	83 c4 04             	add    $0x4,%esp
c0023a7f:	5e                   	pop    %esi
c0023a80:	5f                   	pop    %edi
c0023a81:	c3                   	ret    

c0023a82 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{ 
c0023a82:	57                   	push   %edi
c0023a83:	56                   	push   %esi
c0023a84:	53                   	push   %ebx
c0023a85:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0023a89:	8b 44 24 14          	mov    0x14(%esp),%eax
  if(ticks<=0){
c0023a8d:	85 c0                	test   %eax,%eax
c0023a8f:	78 5e                	js     c0023aef <timer_sleep+0x6d>
c0023a91:	85 c0                	test   %eax,%eax
c0023a93:	7f 05                	jg     c0023a9a <timer_sleep+0x18>
c0023a95:	83 fb 00             	cmp    $0x0,%ebx
c0023a98:	76 55                	jbe    c0023aef <timer_sleep+0x6d>
    return ;
  }
  enum intr_level old_level = intr_disable();
c0023a9a:	e8 f1 db ff ff       	call   c0021690 <intr_disable>
c0023a9f:	89 c7                	mov    %eax,%edi
  struct thread *current_thread = thread_current();//get current thread
c0023aa1:	e8 34 cf ff ff       	call   c00209da <thread_current>
c0023aa6:	89 c6                	mov    %eax,%esi
  ASSERT(current_thread->status == THREAD_RUNNING);
c0023aa8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0023aac:	74 1e                	je     c0023acc <timer_sleep+0x4a>
c0023aae:	83 ec 0c             	sub    $0xc,%esp
c0023ab1:	68 18 de 02 c0       	push   $0xc002de18
c0023ab6:	68 3f d2 02 c0       	push   $0xc002d23f
c0023abb:	68 e0 bd 02 c0       	push   $0xc002bde0
c0023ac0:	6a 63                	push   $0x63
c0023ac2:	68 89 dd 02 c0       	push   $0xc002dd89
c0023ac7:	e8 01 42 00 00       	call   c0027ccd <debug_panic>
  current_thread->tickstowake = ticks + timer_ticks();
c0023acc:	e8 6c ff ff ff       	call   c0023a3d <timer_ticks>
c0023ad1:	01 c3                	add    %eax,%ebx
c0023ad3:	89 5e 28             	mov    %ebx,0x28(%esi)
  //Ensure that the following operations are atomi
  push_into_sleep_list(current_thread);
c0023ad6:	83 ec 0c             	sub    $0xc,%esp
c0023ad9:	56                   	push   %esi
c0023ada:	e8 05 da ff ff       	call   c00214e4 <push_into_sleep_list>
  thread_block();
c0023adf:	e8 22 d5 ff ff       	call   c0021006 <thread_block>
  intr_set_level(old_level);
c0023ae4:	89 3c 24             	mov    %edi,(%esp)
c0023ae7:	e8 ab db ff ff       	call   c0021697 <intr_set_level>
c0023aec:	83 c4 10             	add    $0x10,%esp
  // while (timer_elapsed (start) < ticks) 
  //   thread_yield ();
}
c0023aef:	5b                   	pop    %ebx
c0023af0:	5e                   	pop    %esi
c0023af1:	5f                   	pop    %edi
c0023af2:	c3                   	ret    

c0023af3 <real_time_sleep>:
}

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c0023af3:	55                   	push   %ebp
c0023af4:	57                   	push   %edi
c0023af5:	56                   	push   %esi
c0023af6:	53                   	push   %ebx
c0023af7:	83 ec 1c             	sub    $0x1c,%esp
c0023afa:	89 c5                	mov    %eax,%ebp
c0023afc:	89 44 24 08          	mov    %eax,0x8(%esp)
c0023b00:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0023b04:	89 ce                	mov    %ecx,%esi
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c0023b06:	6b fa 64             	imul   $0x64,%edx,%edi
c0023b09:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023b0e:	89 d8                	mov    %ebx,%eax
c0023b10:	f7 e5                	mul    %ebp
c0023b12:	89 c1                	mov    %eax,%ecx
c0023b14:	89 d3                	mov    %edx,%ebx
c0023b16:	01 fb                	add    %edi,%ebx
c0023b18:	89 f0                	mov    %esi,%eax
c0023b1a:	99                   	cltd   
c0023b1b:	52                   	push   %edx
c0023b1c:	56                   	push   %esi
c0023b1d:	53                   	push   %ebx
c0023b1e:	51                   	push   %ecx
c0023b1f:	e8 dd 3b 00 00       	call   c0027701 <__divdi3>
c0023b24:	83 c4 10             	add    $0x10,%esp
c0023b27:	89 c7                	mov    %eax,%edi
c0023b29:	89 d5                	mov    %edx,%ebp

  ASSERT (intr_get_level () == INTR_ON);
c0023b2b:	e8 23 db ff ff       	call   c0021653 <intr_get_level>
c0023b30:	83 f8 01             	cmp    $0x1,%eax
c0023b33:	74 21                	je     c0023b56 <real_time_sleep+0x63>
c0023b35:	83 ec 0c             	sub    $0xc,%esp
c0023b38:	68 aa dd 02 c0       	push   $0xc002ddaa
c0023b3d:	68 3f d2 02 c0       	push   $0xc002d23f
c0023b42:	68 d0 bd 02 c0       	push   $0xc002bdd0
c0023b47:	68 e5 00 00 00       	push   $0xe5
c0023b4c:	68 89 dd 02 c0       	push   $0xc002dd89
c0023b51:	e8 77 41 00 00       	call   c0027ccd <debug_panic>
  if (ticks > 0)
c0023b56:	85 ed                	test   %ebp,%ebp
c0023b58:	78 18                	js     c0023b72 <real_time_sleep+0x7f>
c0023b5a:	85 ed                	test   %ebp,%ebp
c0023b5c:	7f 05                	jg     c0023b63 <real_time_sleep+0x70>
c0023b5e:	83 ff 00             	cmp    $0x0,%edi
c0023b61:	76 0f                	jbe    c0023b72 <real_time_sleep+0x7f>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0023b63:	83 ec 08             	sub    $0x8,%esp
c0023b66:	55                   	push   %ebp
c0023b67:	57                   	push   %edi
c0023b68:	e8 15 ff ff ff       	call   c0023a82 <timer_sleep>
c0023b6d:	83 c4 10             	add    $0x10,%esp
c0023b70:	eb 0f                	jmp    c0023b81 <real_time_sleep+0x8e>
    }
  else 
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
c0023b72:	89 f1                	mov    %esi,%ecx
c0023b74:	8b 44 24 08          	mov    0x8(%esp),%eax
c0023b78:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0023b7c:	e8 2b fd ff ff       	call   c00238ac <real_time_delay>
    }
}
c0023b81:	83 c4 1c             	add    $0x1c,%esp
c0023b84:	5b                   	pop    %ebx
c0023b85:	5e                   	pop    %esi
c0023b86:	5f                   	pop    %edi
c0023b87:	5d                   	pop    %ebp
c0023b88:	c3                   	ret    

c0023b89 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023b89:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ms, 1000);
c0023b8c:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0023b91:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023b95:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023b99:	e8 55 ff ff ff       	call   c0023af3 <real_time_sleep>
}
c0023b9e:	83 c4 0c             	add    $0xc,%esp
c0023ba1:	c3                   	ret    

c0023ba2 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023ba2:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (us, 1000 * 1000);
c0023ba5:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0023baa:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023bae:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023bb2:	e8 3c ff ff ff       	call   c0023af3 <real_time_sleep>
}
c0023bb7:	83 c4 0c             	add    $0xc,%esp
c0023bba:	c3                   	ret    

c0023bbb <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023bbb:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023bbe:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0023bc3:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023bc7:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023bcb:	e8 23 ff ff ff       	call   c0023af3 <real_time_sleep>
}
c0023bd0:	83 c4 0c             	add    $0xc,%esp
c0023bd3:	c3                   	ret    

c0023bd4 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0023bd4:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ms, 1000);
c0023bd7:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0023bdc:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023be0:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023be4:	e8 c3 fc ff ff       	call   c00238ac <real_time_delay>
}
c0023be9:	83 c4 0c             	add    $0xc,%esp
c0023bec:	c3                   	ret    

c0023bed <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0023bed:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (us, 1000 * 1000);
c0023bf0:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0023bf5:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023bf9:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023bfd:	e8 aa fc ff ff       	call   c00238ac <real_time_delay>
}
c0023c02:	83 c4 0c             	add    $0xc,%esp
c0023c05:	c3                   	ret    

c0023c06 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0023c06:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay (ns, 1000 * 1000 * 1000);
c0023c09:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0023c0e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0023c12:	8b 54 24 14          	mov    0x14(%esp),%edx
c0023c16:	e8 91 fc ff ff       	call   c00238ac <real_time_delay>
}
c0023c1b:	83 c4 0c             	add    $0xc,%esp
c0023c1e:	c3                   	ret    

c0023c1f <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0023c1f:	83 ec 0c             	sub    $0xc,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0023c22:	e8 16 fe ff ff       	call   c0023a3d <timer_ticks>
c0023c27:	83 ec 04             	sub    $0x4,%esp
c0023c2a:	52                   	push   %edx
c0023c2b:	50                   	push   %eax
c0023c2c:	68 02 de 02 c0       	push   $0xc002de02
c0023c31:	e8 1f 24 00 00       	call   c0026055 <printf>
}
c0023c36:	83 c4 1c             	add    $0x1c,%esp
c0023c39:	c3                   	ret    

c0023c3a <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0023c3a:	55                   	push   %ebp
c0023c3b:	57                   	push   %edi
c0023c3c:	56                   	push   %esi
c0023c3d:	53                   	push   %ebx
c0023c3e:	83 ec 04             	sub    $0x4,%esp
c0023c41:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c0023c44:	0f b6 18             	movzbl (%eax),%ebx
c0023c47:	84 db                	test   %bl,%bl
c0023c49:	74 48                	je     c0023c93 <map_key+0x59>
c0023c4b:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode
        && scancode < k->first_scancode + strlen (k->chars)) 
c0023c4d:	b8 00 00 00 00       	mov    $0x0,%eax
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
  for (; k->first_scancode != 0; k++)
    if (scancode >= k->first_scancode
c0023c52:	0f b6 db             	movzbl %bl,%ebx
c0023c55:	39 d3                	cmp    %edx,%ebx
c0023c57:	77 29                	ja     c0023c82 <map_key+0x48>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0023c59:	8b 6e 04             	mov    0x4(%esi),%ebp
c0023c5c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0023c61:	89 ef                	mov    %ebp,%edi
c0023c63:	f2 ae                	repnz scas %es:(%edi),%al
c0023c65:	f7 d1                	not    %ecx
c0023c67:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c0023c6b:	39 ca                	cmp    %ecx,%edx
c0023c6d:	73 13                	jae    c0023c82 <map_key+0x48>
      {
        *c = k->chars[scancode - k->first_scancode];
c0023c6f:	29 da                	sub    %ebx,%edx
c0023c71:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c0023c76:	8b 3c 24             	mov    (%esp),%edi
c0023c79:	88 07                	mov    %al,(%edi)
        return true; 
c0023c7b:	b8 01 00 00 00       	mov    $0x1,%eax
c0023c80:	eb 16                	jmp    c0023c98 <map_key+0x5e>
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
  for (; k->first_scancode != 0; k++)
c0023c82:	83 c6 08             	add    $0x8,%esi
c0023c85:	0f b6 1e             	movzbl (%esi),%ebx
c0023c88:	84 db                	test   %bl,%bl
c0023c8a:	75 c6                	jne    c0023c52 <map_key+0x18>
      {
        *c = k->chars[scancode - k->first_scancode];
        return true; 
      }

  return false;
c0023c8c:	b8 00 00 00 00       	mov    $0x0,%eax
c0023c91:	eb 05                	jmp    c0023c98 <map_key+0x5e>
c0023c93:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0023c98:	83 c4 04             	add    $0x4,%esp
c0023c9b:	5b                   	pop    %ebx
c0023c9c:	5e                   	pop    %esi
c0023c9d:	5f                   	pop    %edi
c0023c9e:	5d                   	pop    %ebp
c0023c9f:	c3                   	ret    

c0023ca0 <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c0023ca0:	55                   	push   %ebp
c0023ca1:	57                   	push   %edi
c0023ca2:	56                   	push   %esi
c0023ca3:	53                   	push   %ebx
c0023ca4:	83 ec 2c             	sub    $0x2c,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c0023ca7:	0f b6 15 ad 92 03 c0 	movzbl 0xc00392ad,%edx
c0023cae:	80 3d ae 92 03 c0 00 	cmpb   $0x0,0xc00392ae
c0023cb5:	b8 01 00 00 00       	mov    $0x1,%eax
c0023cba:	0f 45 d0             	cmovne %eax,%edx
  bool alt = left_alt || right_alt;
c0023cbd:	0f b6 35 ab 92 03 c0 	movzbl 0xc00392ab,%esi
c0023cc4:	80 3d ac 92 03 c0 00 	cmpb   $0x0,0xc00392ac
c0023ccb:	0f 45 f0             	cmovne %eax,%esi
  bool ctrl = left_ctrl || right_ctrl;
c0023cce:	0f b6 3d a9 92 03 c0 	movzbl 0xc00392a9,%edi
c0023cd5:	80 3d aa 92 03 c0 00 	cmpb   $0x0,0xc00392aa
c0023cdc:	0f 45 f8             	cmovne %eax,%edi
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0023cdf:	e4 60                	in     $0x60,%al

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0023ce1:	0f b6 d8             	movzbl %al,%ebx
  if (code == 0xe0)
c0023ce4:	81 fb e0 00 00 00    	cmp    $0xe0,%ebx
c0023cea:	75 08                	jne    c0023cf4 <keyboard_interrupt+0x54>
c0023cec:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb (DATA_REG);
c0023cee:	0f b6 d8             	movzbl %al,%ebx
c0023cf1:	80 cf e0             	or     $0xe0,%bh

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c0023cf4:	89 dd                	mov    %ebx,%ebp
c0023cf6:	81 e5 80 00 00 00    	and    $0x80,%ebp
  code &= ~0x80u;
c0023cfc:	80 e3 7f             	and    $0x7f,%bl

  /* Interpret key. */
  if (code == 0x3a) 
c0023cff:	83 fb 3a             	cmp    $0x3a,%ebx
c0023d02:	75 14                	jne    c0023d18 <keyboard_interrupt+0x78>
    {
      /* Caps Lock. */
      if (!release)
c0023d04:	85 ed                	test   %ebp,%ebp
c0023d06:	0f 85 42 01 00 00    	jne    c0023e4e <keyboard_interrupt+0x1ae>
        caps_lock = !caps_lock;
c0023d0c:	80 35 a8 92 03 c0 01 	xorb   $0x1,0xc00392a8
c0023d13:	e9 36 01 00 00       	jmp    c0023e4e <keyboard_interrupt+0x1ae>

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c0023d18:	89 d0                	mov    %edx,%eax
c0023d1a:	83 e0 01             	and    $0x1,%eax
c0023d1d:	88 44 24 0f          	mov    %al,0xf(%esp)
    {
      /* Caps Lock. */
      if (!release)
        caps_lock = !caps_lock;
    }
  else if (map_key (invariant_keymap, code, &c)
c0023d21:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0023d25:	89 da                	mov    %ebx,%edx
c0023d27:	b8 c0 be 02 c0       	mov    $0xc002bec0,%eax
c0023d2c:	e8 09 ff ff ff       	call   c0023c3a <map_key>
c0023d31:	84 c0                	test   %al,%al
c0023d33:	75 23                	jne    c0023d58 <keyboard_interrupt+0xb8>
           || (!shift && map_key (unshifted_keymap, code, &c))
c0023d35:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0023d3a:	0f 85 d9 00 00 00    	jne    c0023e19 <keyboard_interrupt+0x179>
c0023d40:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0023d44:	89 da                	mov    %ebx,%edx
c0023d46:	b8 80 be 02 c0       	mov    $0xc002be80,%eax
c0023d4b:	e8 ea fe ff ff       	call   c0023c3a <map_key>
c0023d50:	84 c0                	test   %al,%al
c0023d52:	0f 84 95 00 00 00    	je     c0023ded <keyboard_interrupt+0x14d>
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c0023d58:	85 ed                	test   %ebp,%ebp
c0023d5a:	0f 85 ee 00 00 00    	jne    c0023e4e <keyboard_interrupt+0x1ae>
        {
          /* Reboot if Ctrl+Alt+Del pressed. */
          if (c == 0177 && ctrl && alt)
c0023d60:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c0023d65:	3c 7f                	cmp    $0x7f,%al
c0023d67:	75 13                	jne    c0023d7c <keyboard_interrupt+0xdc>
c0023d69:	21 f7                	and    %esi,%edi
c0023d6b:	f7 c7 01 00 00 00    	test   $0x1,%edi
c0023d71:	0f 84 c4 00 00 00    	je     c0023e3b <keyboard_interrupt+0x19b>
            shutdown_reboot ();
c0023d77:	e8 90 1b 00 00       	call   c002590c <shutdown_reboot>

          /* Handle Ctrl, Shift.
             Note that Ctrl overrides Shift. */
          if (ctrl && c >= 0x40 && c < 0x60) 
c0023d7c:	8d 50 c0             	lea    -0x40(%eax),%edx
c0023d7f:	80 fa 1f             	cmp    $0x1f,%dl
c0023d82:	77 0e                	ja     c0023d92 <keyboard_interrupt+0xf2>
c0023d84:	f7 c7 01 00 00 00    	test   $0x1,%edi
c0023d8a:	74 06                	je     c0023d92 <keyboard_interrupt+0xf2>
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
c0023d8c:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0023d90:	eb 20                	jmp    c0023db2 <keyboard_interrupt+0x112>
            }
          else if (shift == caps_lock)
c0023d92:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0023d97:	3a 0d a8 92 03 c0    	cmp    0xc00392a8,%cl
c0023d9d:	75 13                	jne    c0023db2 <keyboard_interrupt+0x112>
            c = tolower (c);
c0023d9f:	0f b6 c0             	movzbl %al,%eax
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0023da2:	8d 48 bf             	lea    -0x41(%eax),%ecx
c0023da5:	8d 50 20             	lea    0x20(%eax),%edx
c0023da8:	83 f9 19             	cmp    $0x19,%ecx
c0023dab:	0f 46 c2             	cmovbe %edx,%eax
c0023dae:	88 44 24 1f          	mov    %al,0x1f(%esp)

          /* Handle Alt by setting the high bit.
             This 0x80 is unrelated to the one used to
             distinguish key press from key release. */
          if (alt)
c0023db2:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0023db8:	74 05                	je     c0023dbf <keyboard_interrupt+0x11f>
            c += 0x80;
c0023dba:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)

          /* Append to keyboard buffer. */
          if (!input_full ())
c0023dbf:	e8 35 16 00 00       	call   c00253f9 <input_full>
c0023dc4:	84 c0                	test   %al,%al
c0023dc6:	0f 85 82 00 00 00    	jne    c0023e4e <keyboard_interrupt+0x1ae>
            {
              key_cnt++;
c0023dcc:	83 05 a0 92 03 c0 01 	addl   $0x1,0xc00392a0
c0023dd3:	83 15 a4 92 03 c0 00 	adcl   $0x0,0xc00392a4
              input_putc (c);
c0023dda:	83 ec 0c             	sub    $0xc,%esp
c0023ddd:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0023de2:	50                   	push   %eax
c0023de3:	e8 65 15 00 00       	call   c002534d <input_putc>
c0023de8:	83 c4 10             	add    $0x10,%esp
c0023deb:	eb 61                	jmp    c0023e4e <keyboard_interrupt+0x1ae>
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
        if (key->scancode == code)
c0023ded:	83 fb 2a             	cmp    $0x2a,%ebx
c0023df0:	74 0d                	je     c0023dff <keyboard_interrupt+0x15f>
c0023df2:	b8 00 be 02 c0       	mov    $0xc002be00,%eax
c0023df7:	eb 15                	jmp    c0023e0e <keyboard_interrupt+0x16e>
c0023df9:	39 d3                	cmp    %edx,%ebx
c0023dfb:	75 11                	jne    c0023e0e <keyboard_interrupt+0x16e>
c0023dfd:	eb 05                	jmp    c0023e04 <keyboard_interrupt+0x164>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c0023dff:	b8 00 be 02 c0       	mov    $0xc002be00,%eax
        if (key->scancode == code)
          {
            *key->state_var = !release;
c0023e04:	8b 40 04             	mov    0x4(%eax),%eax
c0023e07:	85 ed                	test   %ebp,%ebp
c0023e09:	0f 94 00             	sete   (%eax)
            break;
c0023e0c:	eb 40                	jmp    c0023e4e <keyboard_interrupt+0x1ae>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c0023e0e:	83 c0 08             	add    $0x8,%eax
c0023e11:	8b 10                	mov    (%eax),%edx
c0023e13:	85 d2                	test   %edx,%edx
c0023e15:	75 e2                	jne    c0023df9 <keyboard_interrupt+0x159>
c0023e17:	eb 35                	jmp    c0023e4e <keyboard_interrupt+0x1ae>
      if (!release)
        caps_lock = !caps_lock;
    }
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
c0023e19:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0023e1d:	89 da                	mov    %ebx,%edx
c0023e1f:	b8 40 be 02 c0       	mov    $0xc002be40,%eax
c0023e24:	e8 11 fe ff ff       	call   c0023c3a <map_key>
c0023e29:	84 c0                	test   %al,%al
c0023e2b:	0f 85 27 ff ff ff    	jne    c0023d58 <keyboard_interrupt+0xb8>
c0023e31:	eb ba                	jmp    c0023ded <keyboard_interrupt+0x14d>
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
            }
          else if (shift == caps_lock)
            c = tolower (c);
c0023e33:	0f b6 c0             	movzbl %al,%eax
c0023e36:	e9 73 ff ff ff       	jmp    c0023dae <keyboard_interrupt+0x10e>
          if (ctrl && c >= 0x40 && c < 0x60) 
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
            }
          else if (shift == caps_lock)
c0023e3b:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0023e40:	3a 0d a8 92 03 c0    	cmp    0xc00392a8,%cl
c0023e46:	0f 85 66 ff ff ff    	jne    c0023db2 <keyboard_interrupt+0x112>
c0023e4c:	eb e5                	jmp    c0023e33 <keyboard_interrupt+0x193>
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0023e4e:	83 c4 2c             	add    $0x2c,%esp
c0023e51:	5b                   	pop    %ebx
c0023e52:	5e                   	pop    %esi
c0023e53:	5f                   	pop    %edi
c0023e54:	5d                   	pop    %ebp
c0023e55:	c3                   	ret    

c0023e56 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c0023e56:	83 ec 10             	sub    $0x10,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0023e59:	68 41 de 02 c0       	push   $0xc002de41
c0023e5e:	68 a0 3c 02 c0       	push   $0xc0023ca0
c0023e63:	6a 21                	push   $0x21
c0023e65:	e8 c5 d9 ff ff       	call   c002182f <intr_register_ext>
}
c0023e6a:	83 c4 1c             	add    $0x1c,%esp
c0023e6d:	c3                   	ret    

c0023e6e <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c0023e6e:	83 ec 10             	sub    $0x10,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0023e71:	ff 35 a4 92 03 c0    	pushl  0xc00392a4
c0023e77:	ff 35 a0 92 03 c0    	pushl  0xc00392a0
c0023e7d:	68 4f de 02 c0       	push   $0xc002de4f
c0023e82:	e8 ce 21 00 00       	call   c0026055 <printf>
}
c0023e87:	83 c4 1c             	add    $0x1c,%esp
c0023e8a:	c3                   	ret    

c0023e8b <move_cursor>:
/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0023e8b:	8b 0d b8 92 03 c0    	mov    0xc00392b8,%ecx
c0023e91:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c0023e94:	c1 e1 04             	shl    $0x4,%ecx
c0023e97:	66 03 0d bc 92 03 c0 	add    0xc00392bc,%cx
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0023e9e:	89 c8                	mov    %ecx,%eax
c0023ea0:	b0 00                	mov    $0x0,%al
c0023ea2:	83 c8 0e             	or     $0xe,%eax
c0023ea5:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0023eaa:	66 ef                	out    %ax,(%dx)
c0023eac:	89 c8                	mov    %ecx,%eax
c0023eae:	c1 e0 08             	shl    $0x8,%eax
c0023eb1:	83 c8 0f             	or     $0xf,%eax
c0023eb4:	66 ef                	out    %ax,(%dx)
c0023eb6:	c3                   	ret    

c0023eb7 <newline>:
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
  cx = 0;
c0023eb7:	c7 05 bc 92 03 c0 00 	movl   $0x0,0xc00392bc
c0023ebe:	00 00 00 
  cy++;
c0023ec1:	a1 b8 92 03 c0       	mov    0xc00392b8,%eax
c0023ec6:	83 c0 01             	add    $0x1,%eax
  if (cy >= ROW_CNT)
c0023ec9:	83 f8 18             	cmp    $0x18,%eax
c0023ecc:	77 06                	ja     c0023ed4 <newline+0x1d>
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
  cx = 0;
  cy++;
c0023ece:	a3 b8 92 03 c0       	mov    %eax,0xc00392b8
c0023ed3:	c3                   	ret    
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0023ed4:	53                   	push   %ebx
c0023ed5:	83 ec 0c             	sub    $0xc,%esp
  cx = 0;
  cy++;
  if (cy >= ROW_CNT)
    {
      cy = ROW_CNT - 1;
c0023ed8:	c7 05 b8 92 03 c0 18 	movl   $0x18,0xc00392b8
c0023edf:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0023ee2:	8b 1d b4 92 03 c0    	mov    0xc00392b4,%ebx
c0023ee8:	68 00 0f 00 00       	push   $0xf00
c0023eed:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0023ef3:	50                   	push   %eax
c0023ef4:	53                   	push   %ebx
c0023ef5:	e8 1e 2f 00 00       	call   c0026e18 <memmove>
c0023efa:	8d 83 00 0f 00 00    	lea    0xf00(%ebx),%eax
c0023f00:	8d 93 a0 0f 00 00    	lea    0xfa0(%ebx),%edx
c0023f06:	83 c4 10             	add    $0x10,%esp
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
    {
      fb[y][x][0] = ' ';
c0023f09:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0023f0c:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0023f10:	83 c0 02             	add    $0x2,%eax
static void
clear_row (size_t y) 
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0023f13:	39 d0                	cmp    %edx,%eax
c0023f15:	75 f2                	jne    c0023f09 <newline+0x52>
    {
      cy = ROW_CNT - 1;
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
      clear_row (ROW_CNT - 1);
    }
}
c0023f17:	83 c4 08             	add    $0x8,%esp
c0023f1a:	5b                   	pop    %ebx
c0023f1b:	c3                   	ret    

c0023f1c <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0023f1c:	57                   	push   %edi
c0023f1d:	56                   	push   %esi
c0023f1e:	53                   	push   %ebx
c0023f1f:	8b 74 24 10          	mov    0x10(%esp),%esi
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0023f23:	e8 68 d7 ff ff       	call   c0021690 <intr_disable>
c0023f28:	89 c3                	mov    %eax,%ebx
static void
init (void)
{
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0023f2a:	80 3d b0 92 03 c0 00 	cmpb   $0x0,0xc00392b0
c0023f31:	75 61                	jne    c0023f94 <vga_putc+0x78>
    {
      fb = ptov (0xb8000);
c0023f33:	c7 05 b4 92 03 c0 00 	movl   $0xc00b8000,0xc00392b4
c0023f3a:	80 0b c0 
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023f3d:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0023f42:	b8 0e 00 00 00       	mov    $0xe,%eax
c0023f47:	ee                   	out    %al,(%dx)
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0023f48:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0023f4d:	89 ca                	mov    %ecx,%edx
c0023f4f:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
  cp = inb (0x3d5) << 8;
c0023f50:	89 c7                	mov    %eax,%edi
c0023f52:	c1 e7 08             	shl    $0x8,%edi
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023f55:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0023f5a:	b8 0f 00 00 00       	mov    $0xf,%eax
c0023f5f:	ee                   	out    %al,(%dx)
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0023f60:	89 ca                	mov    %ecx,%edx
c0023f62:	ec                   	in     (%dx),%al

  outb (0x3d4, 0x0f);
  cp |= inb (0x3d5);
c0023f63:	0f b6 c0             	movzbl %al,%eax
c0023f66:	09 f8                	or     %edi,%eax

  *x = cp % COL_CNT;
c0023f68:	0f b7 d0             	movzwl %ax,%edx
c0023f6b:	69 d2 cd cc 00 00    	imul   $0xcccd,%edx,%edx
c0023f71:	c1 ea 16             	shr    $0x16,%edx
c0023f74:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c0023f77:	c1 e1 04             	shl    $0x4,%ecx
c0023f7a:	29 c8                	sub    %ecx,%eax
c0023f7c:	0f b7 c0             	movzwl %ax,%eax
c0023f7f:	a3 bc 92 03 c0       	mov    %eax,0xc00392bc
  *y = cp / COL_CNT;
c0023f84:	0f b7 d2             	movzwl %dx,%edx
c0023f87:	89 15 b8 92 03 c0    	mov    %edx,0xc00392b8
  static bool inited;
  if (!inited)
    {
      fb = ptov (0xb8000);
      find_cursor (&cx, &cy);
      inited = true; 
c0023f8d:	c6 05 b0 92 03 c0 01 	movb   $0x1,0xc00392b0
     that might write to the console. */
  enum intr_level old_level = intr_disable ();

  init ();
  
  switch (c) 
c0023f94:	8d 46 f9             	lea    -0x7(%esi),%eax
c0023f97:	83 f8 06             	cmp    $0x6,%eax
c0023f9a:	0f 87 b5 00 00 00    	ja     c0024055 <vga_putc+0x139>
c0023fa0:	ff 24 85 10 bf 02 c0 	jmp    *-0x3ffd40f0(,%eax,4)
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
    {
      fb[y][x][0] = ' ';
c0023fa7:	a1 b4 92 03 c0       	mov    0xc00392b4,%eax
c0023fac:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c0023fb2:	eb 1e                	jmp    c0023fd2 <vga_putc+0xb6>
  init ();
  
  switch (c) 
    {
    case '\n':
      newline ();
c0023fb4:	e8 fe fe ff ff       	call   c0023eb7 <newline>
      break;
c0023fb9:	e9 e3 00 00 00       	jmp    c00240a1 <vga_putc+0x185>
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
    {
      fb[y][x][0] = ' ';
c0023fbe:	c6 00 20             	movb   $0x20,(%eax)
      fb[y][x][1] = GRAY_ON_BLACK;
c0023fc1:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0023fc5:	83 c0 02             	add    $0x2,%eax
static void
clear_row (size_t y) 
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0023fc8:	39 d0                	cmp    %edx,%eax
c0023fca:	75 f2                	jne    c0023fbe <vga_putc+0xa2>
c0023fcc:	89 d0                	mov    %edx,%eax
static void
cls (void)
{
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0023fce:	39 d1                	cmp    %edx,%ecx
c0023fd0:	74 08                	je     c0023fda <vga_putc+0xbe>
c0023fd2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0023fd8:	eb e4                	jmp    c0023fbe <vga_putc+0xa2>
    clear_row (y);

  cx = cy = 0;
c0023fda:	c7 05 b8 92 03 c0 00 	movl   $0x0,0xc00392b8
c0023fe1:	00 00 00 
c0023fe4:	c7 05 bc 92 03 c0 00 	movl   $0x0,0xc00392bc
c0023feb:	00 00 00 
  move_cursor ();
c0023fee:	e8 98 fe ff ff       	call   c0023e8b <move_cursor>
c0023ff3:	e9 a9 00 00 00       	jmp    c00240a1 <vga_putc+0x185>
    case '\f':
      cls ();
      break;

    case '\b':
      if (cx > 0)
c0023ff8:	a1 bc 92 03 c0       	mov    0xc00392bc,%eax
c0023ffd:	85 c0                	test   %eax,%eax
c0023fff:	0f 84 9c 00 00 00    	je     c00240a1 <vga_putc+0x185>
        cx--;
c0024005:	83 e8 01             	sub    $0x1,%eax
c0024008:	a3 bc 92 03 c0       	mov    %eax,0xc00392bc
c002400d:	e9 8f 00 00 00       	jmp    c00240a1 <vga_putc+0x185>
      break;
      
    case '\r':
      cx = 0;
c0024012:	c7 05 bc 92 03 c0 00 	movl   $0x0,0xc00392bc
c0024019:	00 00 00 
      break;
c002401c:	e9 80 00 00 00       	jmp    c00240a1 <vga_putc+0x185>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024021:	a1 bc 92 03 c0       	mov    0xc00392bc,%eax
c0024026:	83 c0 08             	add    $0x8,%eax
c0024029:	83 e0 f8             	and    $0xfffffff8,%eax
c002402c:	a3 bc 92 03 c0       	mov    %eax,0xc00392bc
      if (cx >= COL_CNT)
c0024031:	83 f8 4f             	cmp    $0x4f,%eax
c0024034:	76 6b                	jbe    c00240a1 <vga_putc+0x185>
        newline ();
c0024036:	e8 7c fe ff ff       	call   c0023eb7 <newline>
c002403b:	eb 64                	jmp    c00240a1 <vga_putc+0x185>
      break;

    case '\a':
      intr_set_level (old_level);
c002403d:	83 ec 0c             	sub    $0xc,%esp
c0024040:	53                   	push   %ebx
c0024041:	e8 51 d6 ff ff       	call   c0021697 <intr_set_level>
      speaker_beep ();
c0024046:	e8 40 1a 00 00       	call   c0025a8b <speaker_beep>
      intr_disable ();
c002404b:	e8 40 d6 ff ff       	call   c0021690 <intr_disable>
      break;
c0024050:	83 c4 10             	add    $0x10,%esp
c0024053:	eb 4c                	jmp    c00240a1 <vga_putc+0x185>
      
    default:
      fb[cy][cx][0] = c;
c0024055:	8b 3d b4 92 03 c0    	mov    0xc00392b4,%edi
c002405b:	a1 b8 92 03 c0       	mov    0xc00392b8,%eax
c0024060:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0024063:	c1 e2 05             	shl    $0x5,%edx
c0024066:	01 fa                	add    %edi,%edx
c0024068:	a1 bc 92 03 c0       	mov    0xc00392bc,%eax
c002406d:	89 f1                	mov    %esi,%ecx
c002406f:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024072:	a1 b8 92 03 c0       	mov    0xc00392b8,%eax
c0024077:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002407a:	c1 e0 05             	shl    $0x5,%eax
c002407d:	01 f8                	add    %edi,%eax
c002407f:	8b 15 bc 92 03 c0    	mov    0xc00392bc,%edx
c0024085:	c6 44 50 01 07       	movb   $0x7,0x1(%eax,%edx,2)
      if (++cx >= COL_CNT)
c002408a:	a1 bc 92 03 c0       	mov    0xc00392bc,%eax
c002408f:	83 c0 01             	add    $0x1,%eax
c0024092:	a3 bc 92 03 c0       	mov    %eax,0xc00392bc
c0024097:	83 f8 4f             	cmp    $0x4f,%eax
c002409a:	76 05                	jbe    c00240a1 <vga_putc+0x185>
        newline ();
c002409c:	e8 16 fe ff ff       	call   c0023eb7 <newline>
      break;
    }

  /* Update cursor position. */
  move_cursor ();
c00240a1:	e8 e5 fd ff ff       	call   c0023e8b <move_cursor>

  intr_set_level (old_level);
c00240a6:	83 ec 0c             	sub    $0xc,%esp
c00240a9:	53                   	push   %ebx
c00240aa:	e8 e8 d5 ff ff       	call   c0021697 <intr_set_level>
}
c00240af:	83 c4 10             	add    $0x10,%esp
c00240b2:	5b                   	pop    %ebx
c00240b3:	5e                   	pop    %esi
c00240b4:	5f                   	pop    %edi
c00240b5:	c3                   	ret    

c00240b6 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c00240b6:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (mode == UNINIT);
c00240b9:	83 3d 30 93 03 c0 00 	cmpl   $0x0,0xc0039330
c00240c0:	74 1e                	je     c00240e0 <init_poll+0x2a>
c00240c2:	83 ec 0c             	sub    $0xc,%esp
c00240c5:	68 c8 de 02 c0       	push   $0xc002dec8
c00240ca:	68 3f d2 02 c0       	push   $0xc002d23f
c00240cf:	68 54 bf 02 c0       	push   $0xc002bf54
c00240d4:	6a 45                	push   $0x45
c00240d6:	68 d7 de 02 c0       	push   $0xc002ded7
c00240db:	e8 ed 3b 00 00       	call   c0027ccd <debug_panic>
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00240e0:	ba f9 03 00 00       	mov    $0x3f9,%edx
c00240e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00240ea:	ee                   	out    %al,(%dx)
c00240eb:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00240f0:	ee                   	out    %al,(%dx)
c00240f1:	ba fb 03 00 00       	mov    $0x3fb,%edx
c00240f6:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c00240fb:	ee                   	out    %al,(%dx)
c00240fc:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024101:	b8 0c 00 00 00       	mov    $0xc,%eax
c0024106:	ee                   	out    %al,(%dx)
c0024107:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002410c:	b8 00 00 00 00       	mov    $0x0,%eax
c0024111:	ee                   	out    %al,(%dx)
c0024112:	ba fb 03 00 00       	mov    $0x3fb,%edx
c0024117:	b8 03 00 00 00       	mov    $0x3,%eax
c002411c:	ee                   	out    %al,(%dx)
c002411d:	ba fc 03 00 00       	mov    $0x3fc,%edx
c0024122:	b8 08 00 00 00       	mov    $0x8,%eax
c0024127:	ee                   	out    %al,(%dx)
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
  outb (FCR_REG, 0);                    /* Disable FIFO. */
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
  intq_init (&txq);
c0024128:	83 ec 0c             	sub    $0xc,%esp
c002412b:	68 c0 92 03 c0       	push   $0xc00392c0
c0024130:	e8 ff 12 00 00       	call   c0025434 <intq_init>
  mode = POLL;
c0024135:	c7 05 30 93 03 c0 01 	movl   $0x1,0xc0039330
c002413c:	00 00 00 
} 
c002413f:	83 c4 1c             	add    $0x1c,%esp
c0024142:	c3                   	ret    

c0024143 <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024143:	53                   	push   %ebx
c0024144:	83 ec 08             	sub    $0x8,%esp
  uint8_t ier = 0;

  ASSERT (intr_get_level () == INTR_OFF);
c0024147:	e8 07 d5 ff ff       	call   c0021653 <intr_get_level>
c002414c:	85 c0                	test   %eax,%eax
c002414e:	74 21                	je     c0024171 <write_ier+0x2e>
c0024150:	83 ec 0c             	sub    $0xc,%esp
c0024153:	68 94 d5 02 c0       	push   $0xc002d594
c0024158:	68 3f d2 02 c0       	push   $0xc002d23f
c002415d:	68 48 bf 02 c0       	push   $0xc002bf48
c0024162:	68 b5 00 00 00       	push   $0xb5
c0024167:	68 d7 de 02 c0       	push   $0xc002ded7
c002416c:	e8 5c 3b 00 00       	call   c0027ccd <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024171:	83 ec 0c             	sub    $0xc,%esp
c0024174:	68 c0 92 03 c0       	push   $0xc00392c0
c0024179:	e8 e5 12 00 00       	call   c0025463 <intq_empty>
c002417e:	83 c4 10             	add    $0x10,%esp
    ier |= IER_XMIT;
c0024181:	3c 01                	cmp    $0x1,%al
c0024183:	19 db                	sbb    %ebx,%ebx
c0024185:	83 e3 02             	and    $0x2,%ebx

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024188:	e8 6c 12 00 00       	call   c00253f9 <input_full>
    ier |= IER_RECV;
c002418d:	89 da                	mov    %ebx,%edx
c002418f:	83 ca 01             	or     $0x1,%edx
c0024192:	84 c0                	test   %al,%al
c0024194:	0f 44 da             	cmove  %edx,%ebx
c0024197:	ba f9 03 00 00       	mov    $0x3f9,%edx
c002419c:	89 d8                	mov    %ebx,%eax
c002419e:	ee                   	out    %al,(%dx)
  
  outb (IER_REG, ier);
}
c002419f:	83 c4 08             	add    $0x8,%esp
c00241a2:	5b                   	pop    %ebx
c00241a3:	c3                   	ret    

c00241a4 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c00241a4:	56                   	push   %esi
c00241a5:	53                   	push   %ebx
c00241a6:	83 ec 04             	sub    $0x4,%esp
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00241a9:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00241ae:	ec                   	in     (%dx),%al
c00241af:	bb fd 03 00 00       	mov    $0x3fd,%ebx
c00241b4:	be f8 03 00 00       	mov    $0x3f8,%esi
c00241b9:	eb 12                	jmp    c00241cd <serial_interrupt+0x29>
c00241bb:	89 f2                	mov    %esi,%edx
c00241bd:	ec                   	in     (%dx),%al
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));
c00241be:	83 ec 0c             	sub    $0xc,%esp
c00241c1:	0f b6 c0             	movzbl %al,%eax
c00241c4:	50                   	push   %eax
c00241c5:	e8 83 11 00 00       	call   c002534d <input_putc>
c00241ca:	83 c4 10             	add    $0x10,%esp
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00241cd:	e8 27 12 00 00       	call   c00253f9 <input_full>
c00241d2:	84 c0                	test   %al,%al
c00241d4:	75 1e                	jne    c00241f4 <serial_interrupt+0x50>
c00241d6:	89 da                	mov    %ebx,%edx
c00241d8:	ec                   	in     (%dx),%al
c00241d9:	a8 01                	test   $0x1,%al
c00241db:	75 de                	jne    c00241bb <serial_interrupt+0x17>
c00241dd:	eb 15                	jmp    c00241f4 <serial_interrupt+0x50>
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
    outb (THR_REG, intq_getc (&txq));
c00241df:	83 ec 0c             	sub    $0xc,%esp
c00241e2:	68 c0 92 03 c0       	push   $0xc00392c0
c00241e7:	e8 4e 14 00 00       	call   c002563a <intq_getc>
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00241ec:	89 f2                	mov    %esi,%edx
c00241ee:	ee                   	out    %al,(%dx)
c00241ef:	83 c4 10             	add    $0x10,%esp
c00241f2:	eb 0a                	jmp    c00241fe <serial_interrupt+0x5a>
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00241f4:	bb fd 03 00 00       	mov    $0x3fd,%ebx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00241f9:	be f8 03 00 00       	mov    $0x3f8,%esi
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c00241fe:	83 ec 0c             	sub    $0xc,%esp
c0024201:	68 c0 92 03 c0       	push   $0xc00392c0
c0024206:	e8 58 12 00 00       	call   c0025463 <intq_empty>
c002420b:	83 c4 10             	add    $0x10,%esp
c002420e:	84 c0                	test   %al,%al
c0024210:	75 07                	jne    c0024219 <serial_interrupt+0x75>
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024212:	89 da                	mov    %ebx,%edx
c0024214:	ec                   	in     (%dx),%al
c0024215:	a8 20                	test   $0x20,%al
c0024217:	75 c6                	jne    c00241df <serial_interrupt+0x3b>
    outb (THR_REG, intq_getc (&txq));

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024219:	e8 25 ff ff ff       	call   c0024143 <write_ier>
}
c002421e:	83 c4 04             	add    $0x4,%esp
c0024221:	5b                   	pop    %ebx
c0024222:	5e                   	pop    %esi
c0024223:	c3                   	ret    

c0024224 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024224:	53                   	push   %ebx
c0024225:	83 ec 08             	sub    $0x8,%esp
c0024228:	89 c3                	mov    %eax,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002422a:	e8 24 d4 ff ff       	call   c0021653 <intr_get_level>
c002422f:	85 c0                	test   %eax,%eax
c0024231:	74 21                	je     c0024254 <putc_poll+0x30>
c0024233:	83 ec 0c             	sub    $0xc,%esp
c0024236:	68 94 d5 02 c0       	push   $0xc002d594
c002423b:	68 3f d2 02 c0       	push   $0xc002d23f
c0024240:	68 3c bf 02 c0       	push   $0xc002bf3c
c0024245:	68 c9 00 00 00       	push   $0xc9
c002424a:	68 d7 de 02 c0       	push   $0xc002ded7
c002424f:	e8 79 3a 00 00       	call   c0027ccd <debug_panic>
c0024254:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0024259:	ec                   	in     (%dx),%al

  while ((inb (LSR_REG) & LSR_THRE) == 0)
c002425a:	a8 20                	test   $0x20,%al
c002425c:	74 fb                	je     c0024259 <putc_poll+0x35>
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002425e:	ba f8 03 00 00       	mov    $0x3f8,%edx
c0024263:	89 d8                	mov    %ebx,%eax
c0024265:	ee                   	out    %al,(%dx)
    continue;
  outb (THR_REG, byte);
}
c0024266:	83 c4 08             	add    $0x8,%esp
c0024269:	5b                   	pop    %ebx
c002426a:	c3                   	ret    

c002426b <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c002426b:	53                   	push   %ebx
c002426c:	83 ec 08             	sub    $0x8,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c002426f:	83 3d 30 93 03 c0 00 	cmpl   $0x0,0xc0039330
c0024276:	75 05                	jne    c002427d <serial_init_queue+0x12>
    init_poll ();
c0024278:	e8 39 fe ff ff       	call   c00240b6 <init_poll>
  ASSERT (mode == POLL);
c002427d:	83 3d 30 93 03 c0 01 	cmpl   $0x1,0xc0039330
c0024284:	74 1e                	je     c00242a4 <serial_init_queue+0x39>
c0024286:	83 ec 0c             	sub    $0xc,%esp
c0024289:	68 ee de 02 c0       	push   $0xc002deee
c002428e:	68 3f d2 02 c0       	push   $0xc002d23f
c0024293:	68 60 bf 02 c0       	push   $0xc002bf60
c0024298:	6a 58                	push   $0x58
c002429a:	68 d7 de 02 c0       	push   $0xc002ded7
c002429f:	e8 29 3a 00 00       	call   c0027ccd <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c00242a4:	83 ec 04             	sub    $0x4,%esp
c00242a7:	68 fb de 02 c0       	push   $0xc002defb
c00242ac:	68 a4 41 02 c0       	push   $0xc00241a4
c00242b1:	6a 24                	push   $0x24
c00242b3:	e8 77 d5 ff ff       	call   c002182f <intr_register_ext>
  mode = QUEUE;
c00242b8:	c7 05 30 93 03 c0 02 	movl   $0x2,0xc0039330
c00242bf:	00 00 00 
  old_level = intr_disable ();
c00242c2:	e8 c9 d3 ff ff       	call   c0021690 <intr_disable>
c00242c7:	89 c3                	mov    %eax,%ebx
  write_ier ();
c00242c9:	e8 75 fe ff ff       	call   c0024143 <write_ier>
  intr_set_level (old_level);
c00242ce:	89 1c 24             	mov    %ebx,(%esp)
c00242d1:	e8 c1 d3 ff ff       	call   c0021697 <intr_set_level>
}
c00242d6:	83 c4 18             	add    $0x18,%esp
c00242d9:	5b                   	pop    %ebx
c00242da:	c3                   	ret    

c00242db <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c00242db:	56                   	push   %esi
c00242dc:	53                   	push   %ebx
c00242dd:	83 ec 04             	sub    $0x4,%esp
c00242e0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  enum intr_level old_level = intr_disable ();
c00242e4:	e8 a7 d3 ff ff       	call   c0021690 <intr_disable>
c00242e9:	89 c6                	mov    %eax,%esi

  if (mode != QUEUE)
c00242eb:	a1 30 93 03 c0       	mov    0xc0039330,%eax
c00242f0:	83 f8 02             	cmp    $0x2,%eax
c00242f3:	74 13                	je     c0024308 <serial_putc+0x2d>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c00242f5:	85 c0                	test   %eax,%eax
c00242f7:	75 05                	jne    c00242fe <serial_putc+0x23>
        init_poll ();
c00242f9:	e8 b8 fd ff ff       	call   c00240b6 <init_poll>
      putc_poll (byte); 
c00242fe:	0f b6 c3             	movzbl %bl,%eax
c0024301:	e8 1e ff ff ff       	call   c0024224 <putc_poll>
c0024306:	eb 49                	jmp    c0024351 <serial_putc+0x76>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024308:	85 f6                	test   %esi,%esi
c002430a:	75 2c                	jne    c0024338 <serial_putc+0x5d>
c002430c:	83 ec 0c             	sub    $0xc,%esp
c002430f:	68 c0 92 03 c0       	push   $0xc00392c0
c0024314:	e8 87 11 00 00       	call   c00254a0 <intq_full>
c0024319:	83 c4 10             	add    $0x10,%esp
c002431c:	84 c0                	test   %al,%al
c002431e:	74 18                	je     c0024338 <serial_putc+0x5d>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0024320:	83 ec 0c             	sub    $0xc,%esp
c0024323:	68 c0 92 03 c0       	push   $0xc00392c0
c0024328:	e8 0d 13 00 00       	call   c002563a <intq_getc>
c002432d:	0f b6 c0             	movzbl %al,%eax
c0024330:	e8 ef fe ff ff       	call   c0024224 <putc_poll>
c0024335:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024338:	83 ec 08             	sub    $0x8,%esp
c002433b:	0f b6 db             	movzbl %bl,%ebx
c002433e:	53                   	push   %ebx
c002433f:	68 c0 92 03 c0       	push   $0xc00392c0
c0024344:	e8 a5 13 00 00       	call   c00256ee <intq_putc>
      write_ier ();
c0024349:	e8 f5 fd ff ff       	call   c0024143 <write_ier>
c002434e:	83 c4 10             	add    $0x10,%esp
    }
  
  intr_set_level (old_level);
c0024351:	83 ec 0c             	sub    $0xc,%esp
c0024354:	56                   	push   %esi
c0024355:	e8 3d d3 ff ff       	call   c0021697 <intr_set_level>
}
c002435a:	83 c4 14             	add    $0x14,%esp
c002435d:	5b                   	pop    %ebx
c002435e:	5e                   	pop    %esi
c002435f:	c3                   	ret    

c0024360 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024360:	53                   	push   %ebx
c0024361:	83 ec 08             	sub    $0x8,%esp
  enum intr_level old_level = intr_disable ();
c0024364:	e8 27 d3 ff ff       	call   c0021690 <intr_disable>
c0024369:	89 c3                	mov    %eax,%ebx
  while (!intq_empty (&txq))
c002436b:	eb 18                	jmp    c0024385 <serial_flush+0x25>
    putc_poll (intq_getc (&txq));
c002436d:	83 ec 0c             	sub    $0xc,%esp
c0024370:	68 c0 92 03 c0       	push   $0xc00392c0
c0024375:	e8 c0 12 00 00       	call   c002563a <intq_getc>
c002437a:	0f b6 c0             	movzbl %al,%eax
c002437d:	e8 a2 fe ff ff       	call   c0024224 <putc_poll>
c0024382:	83 c4 10             	add    $0x10,%esp
   mode. */
void
serial_flush (void) 
{
  enum intr_level old_level = intr_disable ();
  while (!intq_empty (&txq))
c0024385:	83 ec 0c             	sub    $0xc,%esp
c0024388:	68 c0 92 03 c0       	push   $0xc00392c0
c002438d:	e8 d1 10 00 00       	call   c0025463 <intq_empty>
c0024392:	83 c4 10             	add    $0x10,%esp
c0024395:	84 c0                	test   %al,%al
c0024397:	74 d4                	je     c002436d <serial_flush+0xd>
    putc_poll (intq_getc (&txq));
  intr_set_level (old_level);
c0024399:	83 ec 0c             	sub    $0xc,%esp
c002439c:	53                   	push   %ebx
c002439d:	e8 f5 d2 ff ff       	call   c0021697 <intr_set_level>
}
c00243a2:	83 c4 18             	add    $0x18,%esp
c00243a5:	5b                   	pop    %ebx
c00243a6:	c3                   	ret    

c00243a7 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c00243a7:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00243aa:	e8 a4 d2 ff ff       	call   c0021653 <intr_get_level>
c00243af:	85 c0                	test   %eax,%eax
c00243b1:	74 21                	je     c00243d4 <serial_notify+0x2d>
c00243b3:	83 ec 0c             	sub    $0xc,%esp
c00243b6:	68 94 d5 02 c0       	push   $0xc002d594
c00243bb:	68 3f d2 02 c0       	push   $0xc002d23f
c00243c0:	68 2c bf 02 c0       	push   $0xc002bf2c
c00243c5:	68 96 00 00 00       	push   $0x96
c00243ca:	68 d7 de 02 c0       	push   $0xc002ded7
c00243cf:	e8 f9 38 00 00       	call   c0027ccd <debug_panic>
  if (mode == QUEUE)
c00243d4:	83 3d 30 93 03 c0 02 	cmpl   $0x2,0xc0039330
c00243db:	75 05                	jne    c00243e2 <serial_notify+0x3b>
    write_ier ();
c00243dd:	e8 61 fd ff ff       	call   c0024143 <write_ier>
}
c00243e2:	83 c4 0c             	add    $0xc,%esp
c00243e5:	c3                   	ret    

c00243e6 <check_sector>:
/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
  if (sector >= block->size)
c00243e6:	8b 48 1c             	mov    0x1c(%eax),%ecx
c00243e9:	39 d1                	cmp    %edx,%ecx
c00243eb:	77 1f                	ja     c002440c <check_sector+0x26>

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c00243ed:	83 ec 10             	sub    $0x10,%esp
  if (sector >= block->size)
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00243f0:	51                   	push   %ecx
c00243f1:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c00243f2:	83 c0 08             	add    $0x8,%eax
{
  if (sector >= block->size)
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00243f5:	50                   	push   %eax
c00243f6:	68 04 df 02 c0       	push   $0xc002df04
c00243fb:	68 90 bf 02 c0       	push   $0xc002bf90
c0024400:	6a 70                	push   $0x70
c0024402:	68 92 df 02 c0       	push   $0xc002df92
c0024407:	e8 c1 38 00 00       	call   c0027ccd <debug_panic>
c002440c:	f3 c3                	repz ret 

c002440e <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c002440e:	83 ec 0c             	sub    $0xc,%esp
c0024411:	8b 44 24 10          	mov    0x10(%esp),%eax
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024415:	83 f8 05             	cmp    $0x5,%eax
c0024418:	76 1e                	jbe    c0024438 <block_type_name+0x2a>
c002441a:	83 ec 0c             	sub    $0xc,%esp
c002441d:	68 a8 df 02 c0       	push   $0xc002dfa8
c0024422:	68 3f d2 02 c0       	push   $0xc002d23f
c0024427:	68 d8 bf 02 c0       	push   $0xc002bfd8
c002442c:	6a 2f                	push   $0x2f
c002442e:	68 92 df 02 c0       	push   $0xc002df92
c0024433:	e8 95 38 00 00       	call   c0027ccd <debug_panic>
  return block_type_names[type];
c0024438:	8b 04 85 c0 bf 02 c0 	mov    -0x3ffd4040(,%eax,4),%eax
}
c002443f:	83 c4 0c             	add    $0xc,%esp
c0024442:	c3                   	ret    

c0024443 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024443:	83 ec 0c             	sub    $0xc,%esp
c0024446:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c002444a:	83 f8 03             	cmp    $0x3,%eax
c002444d:	76 1e                	jbe    c002446d <block_get_role+0x2a>
c002444f:	83 ec 0c             	sub    $0xc,%esp
c0024452:	68 b9 df 02 c0       	push   $0xc002dfb9
c0024457:	68 3f d2 02 c0       	push   $0xc002d23f
c002445c:	68 b0 bf 02 c0       	push   $0xc002bfb0
c0024461:	6a 38                	push   $0x38
c0024463:	68 92 df 02 c0       	push   $0xc002df92
c0024468:	e8 60 38 00 00       	call   c0027ccd <debug_panic>
  return block_by_role[role];
c002446d:	8b 04 85 34 93 03 c0 	mov    -0x3ffc6ccc(,%eax,4),%eax
}
c0024474:	83 c4 0c             	add    $0xc,%esp
c0024477:	c3                   	ret    

c0024478 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024478:	83 ec 0c             	sub    $0xc,%esp
c002447b:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (role < BLOCK_ROLE_CNT);
c002447f:	83 f8 03             	cmp    $0x3,%eax
c0024482:	76 1e                	jbe    c00244a2 <block_set_role+0x2a>
c0024484:	83 ec 0c             	sub    $0xc,%esp
c0024487:	68 b9 df 02 c0       	push   $0xc002dfb9
c002448c:	68 3f d2 02 c0       	push   $0xc002d23f
c0024491:	68 a0 bf 02 c0       	push   $0xc002bfa0
c0024496:	6a 40                	push   $0x40
c0024498:	68 92 df 02 c0       	push   $0xc002df92
c002449d:	e8 2b 38 00 00       	call   c0027ccd <debug_panic>
  block_by_role[role] = block;
c00244a2:	8b 54 24 14          	mov    0x14(%esp),%edx
c00244a6:	89 14 85 34 93 03 c0 	mov    %edx,-0x3ffc6ccc(,%eax,4)
}
c00244ad:	83 c4 0c             	add    $0xc,%esp
c00244b0:	c3                   	ret    

c00244b1 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c00244b1:	53                   	push   %ebx
c00244b2:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c00244b5:	68 c0 79 03 c0       	push   $0xc00379c0
c00244ba:	e8 f8 38 00 00       	call   c0027db7 <list_begin>
c00244bf:	89 c3                	mov    %eax,%ebx
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c00244c1:	c7 04 24 c0 79 03 c0 	movl   $0xc00379c0,(%esp)
c00244c8:	e8 60 39 00 00       	call   c0027e2d <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00244cd:	39 c3                	cmp    %eax,%ebx
c00244cf:	b8 00 00 00 00       	mov    $0x0,%eax
c00244d4:	0f 45 c3             	cmovne %ebx,%eax
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
  return list_elem_to_block (list_begin (&all_blocks));
}
c00244d7:	83 c4 18             	add    $0x18,%esp
c00244da:	5b                   	pop    %ebx
c00244db:	c3                   	ret    

c00244dc <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c00244dc:	53                   	push   %ebx
c00244dd:	83 ec 14             	sub    $0x14,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c00244e0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00244e4:	e8 fe 38 00 00       	call   c0027de7 <list_next>
c00244e9:	89 c3                	mov    %eax,%ebx
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c00244eb:	c7 04 24 c0 79 03 c0 	movl   $0xc00379c0,(%esp)
c00244f2:	e8 36 39 00 00       	call   c0027e2d <list_end>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00244f7:	39 c3                	cmp    %eax,%ebx
c00244f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00244fe:	0f 45 c3             	cmovne %ebx,%eax
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
  return list_elem_to_block (list_next (&block->list_elem));
}
c0024501:	83 c4 18             	add    $0x18,%esp
c0024504:	5b                   	pop    %ebx
c0024505:	c3                   	ret    

c0024506 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0024506:	56                   	push   %esi
c0024507:	53                   	push   %ebx
c0024508:	83 ec 10             	sub    $0x10,%esp
c002450b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c002450f:	68 c0 79 03 c0       	push   $0xc00379c0
c0024514:	e8 9e 38 00 00       	call   c0027db7 <list_begin>
c0024519:	89 c3                	mov    %eax,%ebx
c002451b:	83 c4 10             	add    $0x10,%esp
c002451e:	eb 22                	jmp    c0024542 <block_get_by_name+0x3c>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
      if (!strcmp (name, block->name))
c0024520:	8d 43 08             	lea    0x8(%ebx),%eax
c0024523:	83 ec 08             	sub    $0x8,%esp
c0024526:	50                   	push   %eax
c0024527:	56                   	push   %esi
c0024528:	e8 37 2a 00 00       	call   c0026f64 <strcmp>
c002452d:	83 c4 10             	add    $0x10,%esp
c0024530:	85 c0                	test   %eax,%eax
c0024532:	74 29                	je     c002455d <block_get_by_name+0x57>
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
       e = list_next (e))
c0024534:	83 ec 0c             	sub    $0xc,%esp
c0024537:	53                   	push   %ebx
c0024538:	e8 aa 38 00 00       	call   c0027de7 <list_next>
c002453d:	89 c3                	mov    %eax,%ebx
c002453f:	83 c4 10             	add    $0x10,%esp
struct block *
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024542:	83 ec 0c             	sub    $0xc,%esp
c0024545:	68 c0 79 03 c0       	push   $0xc00379c0
c002454a:	e8 de 38 00 00       	call   c0027e2d <list_end>
c002454f:	83 c4 10             	add    $0x10,%esp
c0024552:	39 c3                	cmp    %eax,%ebx
c0024554:	75 ca                	jne    c0024520 <block_get_by_name+0x1a>
      struct block *block = list_entry (e, struct block, list_elem);
      if (!strcmp (name, block->name))
        return block;
    }

  return NULL;
c0024556:	b8 00 00 00 00       	mov    $0x0,%eax
c002455b:	eb 02                	jmp    c002455f <block_get_by_name+0x59>
c002455d:	89 d8                	mov    %ebx,%eax
}
c002455f:	83 c4 04             	add    $0x4,%esp
c0024562:	5b                   	pop    %ebx
c0024563:	5e                   	pop    %esi
c0024564:	c3                   	ret    

c0024565 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c0024565:	56                   	push   %esi
c0024566:	53                   	push   %ebx
c0024567:	83 ec 04             	sub    $0x4,%esp
c002456a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002456e:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c0024572:	89 f2                	mov    %esi,%edx
c0024574:	89 d8                	mov    %ebx,%eax
c0024576:	e8 6b fe ff ff       	call   c00243e6 <check_sector>
  block->ops->read (block->aux, sector, buffer);
c002457b:	83 ec 04             	sub    $0x4,%esp
c002457e:	8b 43 20             	mov    0x20(%ebx),%eax
c0024581:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024585:	56                   	push   %esi
c0024586:	ff 73 24             	pushl  0x24(%ebx)
c0024589:	ff 10                	call   *(%eax)
  block->read_cnt++;
c002458b:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c002458f:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0024593:	83 c4 14             	add    $0x14,%esp
c0024596:	5b                   	pop    %ebx
c0024597:	5e                   	pop    %esi
c0024598:	c3                   	ret    

c0024599 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c0024599:	56                   	push   %esi
c002459a:	53                   	push   %ebx
c002459b:	83 ec 04             	sub    $0x4,%esp
c002459e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00245a2:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector (block, sector);
c00245a6:	89 f2                	mov    %esi,%edx
c00245a8:	89 d8                	mov    %ebx,%eax
c00245aa:	e8 37 fe ff ff       	call   c00243e6 <check_sector>
  ASSERT (block->type != BLOCK_FOREIGN);
c00245af:	83 7b 18 05          	cmpl   $0x5,0x18(%ebx)
c00245b3:	75 21                	jne    c00245d6 <block_write+0x3d>
c00245b5:	83 ec 0c             	sub    $0xc,%esp
c00245b8:	68 cf df 02 c0       	push   $0xc002dfcf
c00245bd:	68 3f d2 02 c0       	push   $0xc002d23f
c00245c2:	68 84 bf 02 c0       	push   $0xc002bf84
c00245c7:	68 89 00 00 00       	push   $0x89
c00245cc:	68 92 df 02 c0       	push   $0xc002df92
c00245d1:	e8 f7 36 00 00       	call   c0027ccd <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c00245d6:	83 ec 04             	sub    $0x4,%esp
c00245d9:	8b 43 20             	mov    0x20(%ebx),%eax
c00245dc:	ff 74 24 1c          	pushl  0x1c(%esp)
c00245e0:	56                   	push   %esi
c00245e1:	ff 73 24             	pushl  0x24(%ebx)
c00245e4:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c00245e7:	83 43 30 01          	addl   $0x1,0x30(%ebx)
c00245eb:	83 53 34 00          	adcl   $0x0,0x34(%ebx)
}
c00245ef:	83 c4 14             	add    $0x14,%esp
c00245f2:	5b                   	pop    %ebx
c00245f3:	5e                   	pop    %esi
c00245f4:	c3                   	ret    

c00245f5 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
  return block->size;
c00245f5:	8b 44 24 04          	mov    0x4(%esp),%eax
c00245f9:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00245fc:	c3                   	ret    

c00245fd <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
  return block->name;
c00245fd:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024601:	83 c0 08             	add    $0x8,%eax
}
c0024604:	c3                   	ret    

c0024605 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
  return block->type;
c0024605:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024609:	8b 40 18             	mov    0x18(%eax),%eax
}
c002460c:	c3                   	ret    

c002460d <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c002460d:	57                   	push   %edi
c002460e:	56                   	push   %esi
c002460f:	53                   	push   %ebx
c0024610:	be 34 93 03 c0       	mov    $0xc0039334,%esi
c0024615:	bf 44 93 03 c0       	mov    $0xc0039344,%edi
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
    {
      struct block *block = block_by_role[i];
c002461a:	8b 1e                	mov    (%esi),%ebx
      if (block != NULL)
c002461c:	85 db                	test   %ebx,%ebx
c002461e:	74 2c                	je     c002464c <block_print_stats+0x3f>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024620:	83 ec 0c             	sub    $0xc,%esp
c0024623:	ff 73 18             	pushl  0x18(%ebx)
c0024626:	e8 e3 fd ff ff       	call   c002440e <block_type_name>
c002462b:	83 c4 0c             	add    $0xc,%esp
c002462e:	ff 73 34             	pushl  0x34(%ebx)
c0024631:	ff 73 30             	pushl  0x30(%ebx)
c0024634:	ff 73 2c             	pushl  0x2c(%ebx)
c0024637:	ff 73 28             	pushl  0x28(%ebx)
c002463a:	50                   	push   %eax
c002463b:	83 c3 08             	add    $0x8,%ebx
c002463e:	53                   	push   %ebx
c002463f:	68 38 df 02 c0       	push   $0xc002df38
c0024644:	e8 0c 1a 00 00       	call   c0026055 <printf>
c0024649:	83 c4 20             	add    $0x20,%esp
c002464c:	83 c6 04             	add    $0x4,%esi
void
block_print_stats (void)
{
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002464f:	39 fe                	cmp    %edi,%esi
c0024651:	75 c7                	jne    c002461a <block_print_stats+0xd>
          printf ("%s (%s): %llu reads, %llu writes\n",
                  block->name, block_type_name (block->type),
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0024653:	5b                   	pop    %ebx
c0024654:	5e                   	pop    %esi
c0024655:	5f                   	pop    %edi
c0024656:	c3                   	ret    

c0024657 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0024657:	55                   	push   %ebp
c0024658:	57                   	push   %edi
c0024659:	56                   	push   %esi
c002465a:	53                   	push   %ebx
c002465b:	83 ec 18             	sub    $0x18,%esp
c002465e:	8b 74 24 34          	mov    0x34(%esp),%esi
c0024662:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc (sizeof *block);
c0024666:	6a 38                	push   $0x38
c0024668:	e8 02 ee ff ff       	call   c002346f <malloc>
  if (block == NULL)
c002466d:	83 c4 10             	add    $0x10,%esp
c0024670:	85 c0                	test   %eax,%eax
c0024672:	75 19                	jne    c002468d <block_register+0x36>
    PANIC ("Failed to allocate memory for block device descriptor");
c0024674:	68 5c df 02 c0       	push   $0xc002df5c
c0024679:	68 74 bf 02 c0       	push   $0xc002bf74
c002467e:	68 c1 00 00 00       	push   $0xc1
c0024683:	68 92 df 02 c0       	push   $0xc002df92
c0024688:	e8 40 36 00 00       	call   c0027ccd <debug_panic>
c002468d:	89 c3                	mov    %eax,%ebx

  list_push_back (&all_blocks, &block->list_elem);
c002468f:	83 ec 08             	sub    $0x8,%esp
c0024692:	50                   	push   %eax
c0024693:	68 c0 79 03 c0       	push   $0xc00379c0
c0024698:	e8 7b 3b 00 00       	call   c0028218 <list_push_back>
  strlcpy (block->name, name, sizeof block->name);
c002469d:	8d 6b 08             	lea    0x8(%ebx),%ebp
c00246a0:	83 c4 0c             	add    $0xc,%esp
c00246a3:	6a 10                	push   $0x10
c00246a5:	ff 74 24 28          	pushl  0x28(%esp)
c00246a9:	55                   	push   %ebp
c00246aa:	e8 32 2d 00 00       	call   c00273e1 <strlcpy>
  block->type = type;
c00246af:	8b 44 24 34          	mov    0x34(%esp),%eax
c00246b3:	89 43 18             	mov    %eax,0x18(%ebx)
  block->size = size;
c00246b6:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  block->ops = ops;
c00246b9:	8b 44 24 40          	mov    0x40(%esp),%eax
c00246bd:	89 43 20             	mov    %eax,0x20(%ebx)
  block->aux = aux;
c00246c0:	8b 44 24 44          	mov    0x44(%esp),%eax
c00246c4:	89 43 24             	mov    %eax,0x24(%ebx)
  block->read_cnt = 0;
c00246c7:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
c00246ce:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  block->write_cnt = 0;
c00246d5:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
c00246dc:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00246e3:	83 c4 0c             	add    $0xc,%esp
c00246e6:	57                   	push   %edi
c00246e7:	55                   	push   %ebp
c00246e8:	68 ec df 02 c0       	push   $0xc002dfec
c00246ed:	e8 63 19 00 00       	call   c0026055 <printf>
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00246f2:	83 c4 08             	add    $0x8,%esp
c00246f5:	8b 43 1c             	mov    0x1c(%ebx),%eax
c00246f8:	ba 00 00 00 00       	mov    $0x0,%edx
c00246fd:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0024701:	c1 e0 09             	shl    $0x9,%eax
c0024704:	52                   	push   %edx
c0024705:	50                   	push   %eax
c0024706:	e8 62 22 00 00       	call   c002696d <print_human_readable_size>
  printf (")");
c002470b:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0024712:	e8 5e 50 00 00       	call   c0029775 <putchar>
  if (extra_info != NULL)
c0024717:	83 c4 10             	add    $0x10,%esp
c002471a:	85 f6                	test   %esi,%esi
c002471c:	74 11                	je     c002472f <block_register+0xd8>
    printf (", %s", extra_info);
c002471e:	83 ec 08             	sub    $0x8,%esp
c0024721:	56                   	push   %esi
c0024722:	68 fe df 02 c0       	push   $0xc002dffe
c0024727:	e8 29 19 00 00       	call   c0026055 <printf>
c002472c:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c002472f:	83 ec 0c             	sub    $0xc,%esp
c0024732:	6a 0a                	push   $0xa
c0024734:	e8 3c 50 00 00       	call   c0029775 <putchar>

  return block;
}
c0024739:	89 d8                	mov    %ebx,%eax
c002473b:	83 c4 1c             	add    $0x1c,%esp
c002473e:	5b                   	pop    %ebx
c002473f:	5e                   	pop    %esi
c0024740:	5f                   	pop    %edi
c0024741:	5d                   	pop    %ebp
c0024742:	c3                   	ret    

c0024743 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0024743:	83 ec 10             	sub    $0x10,%esp
c0024746:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read (p->block, p->start + sector, buffer);
c002474a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002474e:	8b 42 04             	mov    0x4(%edx),%eax
c0024751:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024755:	50                   	push   %eax
c0024756:	ff 32                	pushl  (%edx)
c0024758:	e8 08 fe ff ff       	call   c0024565 <block_read>
}
c002475d:	83 c4 1c             	add    $0x1c,%esp
c0024760:	c3                   	ret    

c0024761 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0024761:	55                   	push   %ebp
c0024762:	57                   	push   %edi
c0024763:	56                   	push   %esi
c0024764:	53                   	push   %ebx
c0024765:	81 ec c8 00 00 00    	sub    $0xc8,%esp
c002476b:	89 c5                	mov    %eax,%ebp
c002476d:	89 d3                	mov    %edx,%ebx
c002476f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0024773:	50                   	push   %eax
c0024774:	e8 7c fe ff ff       	call   c00245f5 <block_size>
c0024779:	83 c4 10             	add    $0x10,%esp
c002477c:	39 d8                	cmp    %ebx,%eax
c002477e:	77 20                	ja     c00247a0 <read_partition_table+0x3f>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0024780:	83 ec 0c             	sub    $0xc,%esp
c0024783:	55                   	push   %ebp
c0024784:	e8 74 fe ff ff       	call   c00245fd <block_name>
c0024789:	83 c4 0c             	add    $0xc,%esp
c002478c:	53                   	push   %ebx
c002478d:	50                   	push   %eax
c002478e:	68 b0 e4 02 c0       	push   $0xc002e4b0
c0024793:	e8 bd 18 00 00       	call   c0026055 <printf>
              block_name (block), sector);
      return;
c0024798:	83 c4 10             	add    $0x10,%esp
c002479b:	e9 f6 02 00 00       	jmp    c0024a96 <read_partition_table+0x335>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c00247a0:	83 ec 0c             	sub    $0xc,%esp
c00247a3:	68 00 02 00 00       	push   $0x200
c00247a8:	e8 c2 ec ff ff       	call   c002346f <malloc>
c00247ad:	89 c7                	mov    %eax,%edi
  if (pt == NULL)
c00247af:	83 c4 10             	add    $0x10,%esp
c00247b2:	85 c0                	test   %eax,%eax
c00247b4:	75 16                	jne    c00247cc <read_partition_table+0x6b>
    PANIC ("Failed to allocate memory for partition table.");
c00247b6:	68 e8 e4 02 c0       	push   $0xc002e4e8
c00247bb:	68 10 c4 02 c0       	push   $0xc002c410
c00247c0:	6a 5a                	push   $0x5a
c00247c2:	68 1f e0 02 c0       	push   $0xc002e01f
c00247c7:	e8 01 35 00 00       	call   c0027ccd <debug_panic>
  block_read (block, 0, pt);
c00247cc:	83 ec 04             	sub    $0x4,%esp
c00247cf:	50                   	push   %eax
c00247d0:	6a 00                	push   $0x0
c00247d2:	55                   	push   %ebp
c00247d3:	e8 8d fd ff ff       	call   c0024565 <block_read>

  /* Check signature. */
  if (pt->signature != 0xaa55)
c00247d8:	83 c4 10             	add    $0x10,%esp
c00247db:	66 81 bf fe 01 00 00 	cmpw   $0xaa55,0x1fe(%edi)
c00247e2:	55 aa 
c00247e4:	74 4e                	je     c0024834 <read_partition_table+0xd3>
    {
      if (primary_extended_sector == 0)
c00247e6:	83 3c 24 00          	cmpl   $0x0,(%esp)
c00247ea:	75 1c                	jne    c0024808 <read_partition_table+0xa7>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c00247ec:	83 ec 0c             	sub    $0xc,%esp
c00247ef:	55                   	push   %ebp
c00247f0:	e8 08 fe ff ff       	call   c00245fd <block_name>
c00247f5:	83 c4 08             	add    $0x8,%esp
c00247f8:	50                   	push   %eax
c00247f9:	68 18 e5 02 c0       	push   $0xc002e518
c00247fe:	e8 52 18 00 00       	call   c0026055 <printf>
c0024803:	83 c4 10             	add    $0x10,%esp
c0024806:	eb 1b                	jmp    c0024823 <read_partition_table+0xc2>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c0024808:	83 ec 0c             	sub    $0xc,%esp
c002480b:	55                   	push   %ebp
c002480c:	e8 ec fd ff ff       	call   c00245fd <block_name>
c0024811:	83 c4 0c             	add    $0xc,%esp
c0024814:	53                   	push   %ebx
c0024815:	50                   	push   %eax
c0024816:	68 40 e5 02 c0       	push   $0xc002e540
c002481b:	e8 35 18 00 00       	call   c0026055 <printf>
c0024820:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c0024823:	83 ec 0c             	sub    $0xc,%esp
c0024826:	57                   	push   %edi
c0024827:	e8 d4 ed ff ff       	call   c0023600 <free>
      return;
c002482c:	83 c4 10             	add    $0x10,%esp
c002482f:	e9 62 02 00 00       	jmp    c0024a96 <read_partition_table+0x335>
c0024834:	8d b7 c6 01 00 00    	lea    0x1c6(%edi),%esi
c002483a:	8d 87 06 02 00 00    	lea    0x206(%edi),%eax
c0024840:	89 44 24 08          	mov    %eax,0x8(%esp)
        PANIC ("Failed to allocate memory for partition descriptor");
      p->block = block;
      p->start = start;

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024844:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0024848:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c002484c:	89 74 24 04          	mov    %esi,0x4(%esp)
  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
    {
      struct partition_table_entry *e = &pt->partitions[i];

      if (e->size == 0 || e->type == 0)
c0024850:	8b 5e 04             	mov    0x4(%esi),%ebx
c0024853:	85 db                	test   %ebx,%ebx
c0024855:	0f 84 1e 02 00 00    	je     c0024a79 <read_partition_table+0x318>
c002485b:	0f b6 7e fc          	movzbl -0x4(%esi),%edi
c002485f:	89 f8                	mov    %edi,%eax
c0024861:	84 c0                	test   %al,%al
c0024863:	0f 84 10 02 00 00    	je     c0024a79 <read_partition_table+0x318>
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
               || e->type == 0x0f    /* Windows 98 extended partition. */
               || e->type == 0x85    /* Linux extended partition. */
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0024869:	3c 0f                	cmp    $0xf,%al
c002486b:	0f 94 c2             	sete   %dl
c002486e:	3c c5                	cmp    $0xc5,%al
c0024870:	0f 94 c0             	sete   %al
c0024873:	08 c2                	or     %al,%dl
c0024875:	75 09                	jne    c0024880 <read_partition_table+0x11f>
c0024877:	89 f8                	mov    %edi,%eax
c0024879:	83 e0 7f             	and    $0x7f,%eax
c002487c:	3c 05                	cmp    $0x5,%al
c002487e:	75 68                	jne    c00248e8 <read_partition_table+0x187>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0024880:	83 ec 0c             	sub    $0xc,%esp
c0024883:	55                   	push   %ebp
c0024884:	e8 74 fd ff ff       	call   c00245fd <block_name>
c0024889:	83 c4 0c             	add    $0xc,%esp
c002488c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0024890:	53                   	push   %ebx
c0024891:	50                   	push   %eax
c0024892:	68 74 e5 02 c0       	push   $0xc002e574
c0024897:	e8 b9 17 00 00       	call   c0026055 <printf>
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c002489c:	83 c4 10             	add    $0x10,%esp
c002489f:	85 db                	test   %ebx,%ebx
c00248a1:	75 21                	jne    c00248c4 <read_partition_table+0x163>
            read_partition_table (block, e->offset, e->offset, part_nr);
c00248a3:	8b 44 24 04          	mov    0x4(%esp),%eax
c00248a7:	8b 10                	mov    (%eax),%edx
c00248a9:	83 ec 0c             	sub    $0xc,%esp
c00248ac:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c00248b3:	89 d1                	mov    %edx,%ecx
c00248b5:	89 e8                	mov    %ebp,%eax
c00248b7:	e8 a5 fe ff ff       	call   c0024761 <read_partition_table>
c00248bc:	83 c4 10             	add    $0x10,%esp
c00248bf:	e9 b5 01 00 00       	jmp    c0024a79 <read_partition_table+0x318>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c00248c4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00248c8:	8b 0c 24             	mov    (%esp),%ecx
c00248cb:	89 ca                	mov    %ecx,%edx
c00248cd:	03 10                	add    (%eax),%edx
c00248cf:	83 ec 0c             	sub    $0xc,%esp
c00248d2:	ff b4 24 dc 00 00 00 	pushl  0xdc(%esp)
c00248d9:	89 e8                	mov    %ebp,%eax
c00248db:	e8 81 fe ff ff       	call   c0024761 <read_partition_table>
c00248e0:	83 c4 10             	add    $0x10,%esp
c00248e3:	e9 91 01 00 00       	jmp    c0024a79 <read_partition_table+0x318>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c00248e8:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
c00248ef:	8b 00                	mov    (%eax),%eax
c00248f1:	83 c0 01             	add    $0x1,%eax
c00248f4:	89 44 24 14          	mov    %eax,0x14(%esp)
c00248f8:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
c00248ff:	89 01                	mov    %eax,(%ecx)

          found_partition (block, e->type, e->offset + sector,
c0024901:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0024905:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024909:	03 01                	add    (%ecx),%eax
c002490b:	89 44 24 04          	mov    %eax,0x4(%esp)
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
  if (start >= block_size (block))
c002490f:	83 ec 0c             	sub    $0xc,%esp
c0024912:	55                   	push   %ebp
c0024913:	e8 dd fc ff ff       	call   c00245f5 <block_size>
c0024918:	83 c4 10             	add    $0x10,%esp
c002491b:	39 44 24 04          	cmp    %eax,0x4(%esp)
c002491f:	72 24                	jb     c0024945 <read_partition_table+0x1e4>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0024921:	83 ec 0c             	sub    $0xc,%esp
c0024924:	55                   	push   %ebp
c0024925:	e8 d3 fc ff ff       	call   c00245fd <block_name>
c002492a:	ff 74 24 14          	pushl  0x14(%esp)
c002492e:	ff 74 24 28          	pushl  0x28(%esp)
c0024932:	50                   	push   %eax
c0024933:	68 9c e5 02 c0       	push   $0xc002e59c
c0024938:	e8 18 17 00 00       	call   c0026055 <printf>
c002493d:	83 c4 20             	add    $0x20,%esp
c0024940:	e9 34 01 00 00       	jmp    c0024a79 <read_partition_table+0x318>
            block_name (block), part_nr, start);
  else if (start + size < start || start + size > block_size (block))
c0024945:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024949:	01 d8                	add    %ebx,%eax
c002494b:	89 44 24 18          	mov    %eax,0x18(%esp)
c002494f:	72 12                	jb     c0024963 <read_partition_table+0x202>
c0024951:	83 ec 0c             	sub    $0xc,%esp
c0024954:	55                   	push   %ebp
c0024955:	e8 9b fc ff ff       	call   c00245f5 <block_size>
c002495a:	83 c4 10             	add    $0x10,%esp
c002495d:	39 44 24 18          	cmp    %eax,0x18(%esp)
c0024961:	76 31                	jbe    c0024994 <read_partition_table+0x233>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0024963:	83 ec 0c             	sub    $0xc,%esp
c0024966:	55                   	push   %ebp
c0024967:	e8 89 fc ff ff       	call   c00245f5 <block_size>
c002496c:	89 c3                	mov    %eax,%ebx
c002496e:	89 2c 24             	mov    %ebp,(%esp)
c0024971:	e8 87 fc ff ff       	call   c00245fd <block_name>
c0024976:	89 1c 24             	mov    %ebx,(%esp)
c0024979:	ff 74 24 28          	pushl  0x28(%esp)
c002497d:	ff 74 24 28          	pushl  0x28(%esp)
c0024981:	50                   	push   %eax
c0024982:	68 d4 e5 02 c0       	push   $0xc002e5d4
c0024987:	e8 c9 16 00 00       	call   c0026055 <printf>
c002498c:	83 c4 20             	add    $0x20,%esp
c002498f:	e9 e5 00 00 00       	jmp    c0024a79 <read_partition_table+0x318>
            block_name (block), part_nr, start + size, block_size (block));
  else
    {
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0024994:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c002499b:	00 
c002499c:	89 f8                	mov    %edi,%eax
c002499e:	3c 20                	cmp    $0x20,%al
c00249a0:	74 28                	je     c00249ca <read_partition_table+0x269>
c00249a2:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
c00249a9:	00 
c00249aa:	3c 21                	cmp    $0x21,%al
c00249ac:	74 1c                	je     c00249ca <read_partition_table+0x269>
c00249ae:	c7 44 24 1c 02 00 00 	movl   $0x2,0x1c(%esp)
c00249b5:	00 
c00249b6:	3c 22                	cmp    $0x22,%al
c00249b8:	74 10                	je     c00249ca <read_partition_table+0x269>
c00249ba:	3c 23                	cmp    $0x23,%al
c00249bc:	0f 95 c0             	setne  %al
c00249bf:	0f b6 c0             	movzbl %al,%eax
c00249c2:	8d 44 00 03          	lea    0x3(%eax,%eax,1),%eax
c00249c6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
                              : BLOCK_FOREIGN);
      struct partition *p;
      char extra_info[128];
      char name[16];

      p = malloc (sizeof *p);
c00249ca:	83 ec 0c             	sub    $0xc,%esp
c00249cd:	6a 08                	push   $0x8
c00249cf:	e8 9b ea ff ff       	call   c002346f <malloc>
c00249d4:	89 44 24 28          	mov    %eax,0x28(%esp)
      if (p == NULL)
c00249d8:	83 c4 10             	add    $0x10,%esp
c00249db:	85 c0                	test   %eax,%eax
c00249dd:	75 19                	jne    c00249f8 <read_partition_table+0x297>
        PANIC ("Failed to allocate memory for partition descriptor");
c00249df:	68 08 e6 02 c0       	push   $0xc002e608
c00249e4:	68 00 c4 02 c0       	push   $0xc002c400
c00249e9:	68 b1 00 00 00       	push   $0xb1
c00249ee:	68 1f e0 02 c0       	push   $0xc002e01f
c00249f3:	e8 d5 32 00 00       	call   c0027ccd <debug_panic>
      p->block = block;
c00249f8:	8b 44 24 18          	mov    0x18(%esp),%eax
c00249fc:	89 28                	mov    %ebp,(%eax)
      p->start = start;
c00249fe:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0024a02:	89 48 04             	mov    %ecx,0x4(%eax)

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0024a05:	83 ec 0c             	sub    $0xc,%esp
c0024a08:	55                   	push   %ebp
c0024a09:	e8 ef fb ff ff       	call   c00245fd <block_name>
c0024a0e:	83 c4 04             	add    $0x4,%esp
c0024a11:	ff 74 24 20          	pushl  0x20(%esp)
c0024a15:	50                   	push   %eax
c0024a16:	68 39 e0 02 c0       	push   $0xc002e039
c0024a1b:	6a 10                	push   $0x10
c0024a1d:	8d 4c 24 3c          	lea    0x3c(%esp),%ecx
c0024a21:	51                   	push   %ecx
c0024a22:	e8 3b 1d 00 00       	call   c0026762 <snprintf>
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024a27:	89 f8                	mov    %edi,%eax
c0024a29:	0f b6 f8             	movzbl %al,%edi
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0024a2c:	8b 04 bd 00 c0 02 c0 	mov    -0x3ffd4000(,%edi,4),%eax
c0024a33:	83 c4 14             	add    $0x14,%esp
c0024a36:	85 c0                	test   %eax,%eax
c0024a38:	ba 17 e0 02 c0       	mov    $0xc002e017,%edx
c0024a3d:	0f 44 c2             	cmove  %edx,%eax
        PANIC ("Failed to allocate memory for partition descriptor");
      p->block = block;
      p->start = start;

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0024a40:	57                   	push   %edi
c0024a41:	50                   	push   %eax
c0024a42:	68 3e e0 02 c0       	push   $0xc002e03e
c0024a47:	68 80 00 00 00       	push   $0x80
c0024a4c:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
c0024a50:	51                   	push   %ecx
c0024a51:	e8 0c 1d 00 00       	call   c0026762 <snprintf>
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
c0024a56:	83 c4 18             	add    $0x18,%esp
c0024a59:	ff 74 24 20          	pushl  0x20(%esp)
c0024a5d:	68 d0 79 03 c0       	push   $0xc00379d0
c0024a62:	53                   	push   %ebx
c0024a63:	8d 44 24 44          	lea    0x44(%esp),%eax
c0024a67:	50                   	push   %eax
c0024a68:	ff 74 24 34          	pushl  0x34(%esp)
c0024a6c:	8d 44 24 3c          	lea    0x3c(%esp),%eax
c0024a70:	50                   	push   %eax
c0024a71:	e8 e1 fb ff ff       	call   c0024657 <block_register>
c0024a76:	83 c4 20             	add    $0x20,%esp
c0024a79:	83 c6 10             	add    $0x10,%esi
      free (pt);
      return;
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0024a7c:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0024a80:	0f 85 c6 fd ff ff    	jne    c002484c <read_partition_table+0xeb>
c0024a86:	8b 7c 24 0c          	mov    0xc(%esp),%edi
          found_partition (block, e->type, e->offset + sector,
                           e->size, *part_nr);
        }
    }

  free (pt);
c0024a8a:	83 ec 0c             	sub    $0xc,%esp
c0024a8d:	57                   	push   %edi
c0024a8e:	e8 6d eb ff ff       	call   c0023600 <free>
c0024a93:	83 c4 10             	add    $0x10,%esp
}
c0024a96:	81 c4 bc 00 00 00    	add    $0xbc,%esp
c0024a9c:	5b                   	pop    %ebx
c0024a9d:	5e                   	pop    %esi
c0024a9e:	5f                   	pop    %edi
c0024a9f:	5d                   	pop    %ebp
c0024aa0:	c3                   	ret    

c0024aa1 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0024aa1:	83 ec 10             	sub    $0x10,%esp
c0024aa4:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write (p->block, p->start + sector, buffer);
c0024aa8:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024aac:	8b 42 04             	mov    0x4(%edx),%eax
c0024aaf:	03 44 24 1c          	add    0x1c(%esp),%eax
c0024ab3:	50                   	push   %eax
c0024ab4:	ff 32                	pushl  (%edx)
c0024ab6:	e8 de fa ff ff       	call   c0024599 <block_write>
}
c0024abb:	83 c4 1c             	add    $0x1c,%esp
c0024abe:	c3                   	ret    

c0024abf <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0024abf:	53                   	push   %ebx
c0024ac0:	83 ec 24             	sub    $0x24,%esp
c0024ac3:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  int part_nr = 0;
c0024ac7:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0024ace:	00 
  read_partition_table (block, 0, 0, &part_nr);
c0024acf:	8d 44 24 18          	lea    0x18(%esp),%eax
c0024ad3:	50                   	push   %eax
c0024ad4:	b9 00 00 00 00       	mov    $0x0,%ecx
c0024ad9:	ba 00 00 00 00       	mov    $0x0,%edx
c0024ade:	89 d8                	mov    %ebx,%eax
c0024ae0:	e8 7c fc ff ff       	call   c0024761 <read_partition_table>
  if (part_nr == 0)
c0024ae5:	83 c4 10             	add    $0x10,%esp
c0024ae8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0024aed:	75 1a                	jne    c0024b09 <partition_scan+0x4a>
    printf ("%s: Device contains no partitions\n", block_name (block));
c0024aef:	83 ec 0c             	sub    $0xc,%esp
c0024af2:	53                   	push   %ebx
c0024af3:	e8 05 fb ff ff       	call   c00245fd <block_name>
c0024af8:	83 c4 08             	add    $0x8,%esp
c0024afb:	50                   	push   %eax
c0024afc:	68 3c e6 02 c0       	push   $0xc002e63c
c0024b01:	e8 4f 15 00 00       	call   c0026055 <printf>
c0024b06:	83 c4 10             	add    $0x10,%esp
}
c0024b09:	83 c4 18             	add    $0x18,%esp
c0024b0c:	5b                   	pop    %ebx
c0024b0d:	c3                   	ret    

c0024b0e <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0024b0e:	57                   	push   %edi
c0024b0f:	56                   	push   %esi
c0024b10:	53                   	push   %ebx
c0024b11:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0024b13:	83 fa 01             	cmp    $0x1,%edx
c0024b16:	7e 20                	jle    c0024b38 <descramble_ata_string+0x2a>
c0024b18:	8d 48 01             	lea    0x1(%eax),%ecx
c0024b1b:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0024b1e:	83 e3 fe             	and    $0xfffffffe,%ebx
c0024b21:	8d 74 18 03          	lea    0x3(%eax,%ebx,1),%esi
    {
      char tmp = string[i];
c0024b25:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
      string[i] = string[i + 1];
c0024b29:	0f b6 11             	movzbl (%ecx),%edx
c0024b2c:	88 51 ff             	mov    %dl,-0x1(%ecx)
      string[i + 1] = tmp;
c0024b2f:	88 19                	mov    %bl,(%ecx)
c0024b31:	83 c1 02             	add    $0x2,%ecx
descramble_ata_string (char *string, int size) 
{
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0024b34:	39 f1                	cmp    %esi,%ecx
c0024b36:	75 ed                	jne    c0024b25 <descramble_ata_string+0x17>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0024b38:	8d 57 ff             	lea    -0x1(%edi),%edx
c0024b3b:	85 d2                	test   %edx,%edx
c0024b3d:	7e 24                	jle    c0024b63 <descramble_ata_string+0x55>
    {
      int c = string[size - 1];
c0024b3f:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
      if (c != '\0' && !isspace (c))
c0024b44:	f6 c1 df             	test   $0xdf,%cl
c0024b47:	74 15                	je     c0024b5e <descramble_ata_string+0x50>
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c0024b49:	8d 59 f4             	lea    -0xc(%ecx),%ebx
c0024b4c:	80 fb 01             	cmp    $0x1,%bl
c0024b4f:	76 0d                	jbe    c0024b5e <descramble_ata_string+0x50>
c0024b51:	80 f9 0a             	cmp    $0xa,%cl
c0024b54:	74 08                	je     c0024b5e <descramble_ata_string+0x50>
c0024b56:	83 e1 fd             	and    $0xfffffffd,%ecx
c0024b59:	80 f9 09             	cmp    $0x9,%cl
c0024b5c:	75 05                	jne    c0024b63 <descramble_ata_string+0x55>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0024b5e:	83 ea 01             	sub    $0x1,%edx
c0024b61:	75 dc                	jne    c0024b3f <descramble_ata_string+0x31>
    {
      int c = string[size - 1];
      if (c != '\0' && !isspace (c))
        break; 
    }
  string[size] = '\0';
c0024b63:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c0024b67:	5b                   	pop    %ebx
c0024b68:	5e                   	pop    %esi
c0024b69:	5f                   	pop    %edi
c0024b6a:	c3                   	ret    

c0024b6b <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0024b6b:	83 ec 0c             	sub    $0xc,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0024b6e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024b72:	8b 40 30             	mov    0x30(%eax),%eax
c0024b75:	0f b6 15 6a 93 03 c0 	movzbl 0xc003936a,%edx
static void
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0024b7c:	b9 60 93 03 c0       	mov    $0xc0039360,%ecx
    if (f->vec_no == c->irq)
c0024b81:	39 d0                	cmp    %edx,%eax
c0024b83:	74 07                	je     c0024b8c <interrupt_handler+0x21>
c0024b85:	eb 37                	jmp    c0024bbe <interrupt_handler+0x53>
static void
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0024b87:	b9 cc 93 03 c0       	mov    $0xc00393cc,%ecx
    if (f->vec_no == c->irq)
      {
        if (c->expecting_interrupt) 
c0024b8c:	80 79 2c 00          	cmpb   $0x0,0x2c(%ecx)
c0024b90:	74 19                	je     c0024bab <interrupt_handler+0x40>
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024b92:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c0024b96:	8d 50 07             	lea    0x7(%eax),%edx
c0024b99:	ec                   	in     (%dx),%al
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0024b9a:	83 ec 0c             	sub    $0xc,%esp
c0024b9d:	83 c1 30             	add    $0x30,%ecx
c0024ba0:	51                   	push   %ecx
c0024ba1:	e8 6b dc ff ff       	call   c0022811 <sema_up>
c0024ba6:	83 c4 10             	add    $0x10,%esp
c0024ba9:	eb 37                	jmp    c0024be2 <interrupt_handler+0x77>
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
c0024bab:	83 ec 08             	sub    $0x8,%esp
c0024bae:	51                   	push   %ecx
c0024baf:	68 5f e6 02 c0       	push   $0xc002e65f
c0024bb4:	e8 9c 14 00 00       	call   c0026055 <printf>
c0024bb9:	83 c4 10             	add    $0x10,%esp
c0024bbc:	eb 24                	jmp    c0024be2 <interrupt_handler+0x77>
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0024bbe:	0f b6 15 d6 93 03 c0 	movzbl 0xc00393d6,%edx
c0024bc5:	39 d0                	cmp    %edx,%eax
c0024bc7:	74 be                	je     c0024b87 <interrupt_handler+0x1c>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c0024bc9:	68 c0 d6 02 c0       	push   $0xc002d6c0
c0024bce:	68 78 c4 02 c0       	push   $0xc002c478
c0024bd3:	68 0c 02 00 00       	push   $0x20c
c0024bd8:	68 79 e6 02 c0       	push   $0xc002e679
c0024bdd:	e8 eb 30 00 00       	call   c0027ccd <debug_panic>
}
c0024be2:	83 c4 0c             	add    $0xc,%esp
c0024be5:	c3                   	ret    

c0024be6 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c0024be6:	56                   	push   %esi
c0024be7:	53                   	push   %ebx
c0024be8:	83 ec 04             	sub    $0x4,%esp
c0024beb:	89 c6                	mov    %eax,%esi
  int i;

  for (i = 0; i < 1000; i++) 
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0024bed:	8b 40 08             	mov    0x8(%eax),%eax
c0024bf0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0024bf4:	8d 50 07             	lea    0x7(%eax),%edx
c0024bf7:	ec                   	in     (%dx),%al
c0024bf8:	a8 88                	test   $0x88,%al
c0024bfa:	75 38                	jne    c0024c34 <wait_until_idle+0x4e>
c0024bfc:	eb 4c                	jmp    c0024c4a <wait_until_idle+0x64>
c0024bfe:	8b 46 08             	mov    0x8(%esi),%eax
c0024c01:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0024c05:	8d 50 07             	lea    0x7(%eax),%edx
c0024c08:	ec                   	in     (%dx),%al
c0024c09:	a8 88                	test   $0x88,%al
c0024c0b:	74 3d                	je     c0024c4a <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c0024c0d:	83 ec 08             	sub    $0x8,%esp
c0024c10:	6a 00                	push   $0x0
c0024c12:	6a 0a                	push   $0xa
c0024c14:	e8 89 ef ff ff       	call   c0023ba2 <timer_usleep>
static void
wait_until_idle (const struct ata_disk *d) 
{
  int i;

  for (i = 0; i < 1000; i++) 
c0024c19:	83 c4 10             	add    $0x10,%esp
c0024c1c:	83 eb 01             	sub    $0x1,%ebx
c0024c1f:	75 dd                	jne    c0024bfe <wait_until_idle+0x18>
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
c0024c21:	83 ec 08             	sub    $0x8,%esp
c0024c24:	56                   	push   %esi
c0024c25:	68 8d e6 02 c0       	push   $0xc002e68d
c0024c2a:	e8 26 14 00 00       	call   c0026055 <printf>
c0024c2f:	83 c4 10             	add    $0x10,%esp
c0024c32:	eb 16                	jmp    c0024c4a <wait_until_idle+0x64>

  for (i = 0; i < 1000; i++) 
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
      timer_usleep (10);
c0024c34:	83 ec 08             	sub    $0x8,%esp
c0024c37:	6a 00                	push   $0x0
c0024c39:	6a 0a                	push   $0xa
c0024c3b:	e8 62 ef ff ff       	call   c0023ba2 <timer_usleep>
c0024c40:	83 c4 10             	add    $0x10,%esp
c0024c43:	bb e7 03 00 00       	mov    $0x3e7,%ebx
c0024c48:	eb b4                	jmp    c0024bfe <wait_until_idle+0x18>
    }

  printf ("%s: idle timeout\n", d->name);
}
c0024c4a:	83 c4 04             	add    $0x4,%esp
c0024c4d:	5b                   	pop    %ebx
c0024c4e:	5e                   	pop    %esi
c0024c4f:	c3                   	ret    

c0024c50 <select_device>:
}

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c0024c50:	83 ec 14             	sub    $0x14,%esp
  struct channel *c = d->channel;
c0024c53:	8b 50 08             	mov    0x8(%eax),%edx
  uint8_t dev = DEV_MBS;
  if (d->dev_no == 1)
c0024c56:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    dev |= DEV_DEV;
c0024c5a:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c0024c5f:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c0024c64:	0f 44 c1             	cmove  %ecx,%eax
  outb (reg_device (c), dev);
c0024c67:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024c6b:	8d 51 06             	lea    0x6(%ecx),%edx
c0024c6e:	ee                   	out    %al,(%dx)
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024c6f:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
c0024c75:	ec                   	in     (%dx),%al
  inb (reg_alt_status (c));
  timer_nsleep (400);
c0024c76:	6a 00                	push   $0x0
c0024c78:	68 90 01 00 00       	push   $0x190
c0024c7d:	e8 39 ef ff ff       	call   c0023bbb <timer_nsleep>
}
c0024c82:	83 c4 1c             	add    $0x1c,%esp
c0024c85:	c3                   	ret    

c0024c86 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0024c86:	55                   	push   %ebp
c0024c87:	57                   	push   %edi
c0024c88:	56                   	push   %esi
c0024c89:	53                   	push   %ebx
c0024c8a:	83 ec 0c             	sub    $0xc,%esp
c0024c8d:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c0024c8f:	8b 58 08             	mov    0x8(%eax),%ebx
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0024c92:	e8 b9 ff ff ff       	call   c0024c50 <select_device>

  error = inb (reg_error (c));
c0024c97:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0024c9b:	8d 51 01             	lea    0x1(%ecx),%edx
c0024c9e:	ec                   	in     (%dx),%al
c0024c9f:	89 c3                	mov    %eax,%ebx
c0024ca1:	8d 51 04             	lea    0x4(%ecx),%edx
c0024ca4:	ec                   	in     (%dx),%al
c0024ca5:	89 c5                	mov    %eax,%ebp
c0024ca7:	8d 51 05             	lea    0x5(%ecx),%edx
c0024caa:	ec                   	in     (%dx),%al
c0024cab:	89 c7                	mov    %eax,%edi
c0024cad:	8d 51 07             	lea    0x7(%ecx),%edx
c0024cb0:	ec                   	in     (%dx),%al
  lbam = inb (reg_lbam (c));
  lbah = inb (reg_lbah (c));
  status = inb (reg_status (c));

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0024cb1:	80 fb 01             	cmp    $0x1,%bl
c0024cb4:	74 0b                	je     c0024cc1 <check_device_type+0x3b>
c0024cb6:	80 fb 81             	cmp    $0x81,%bl
c0024cb9:	75 0e                	jne    c0024cc9 <check_device_type+0x43>
c0024cbb:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0024cbf:	74 08                	je     c0024cc9 <check_device_type+0x43>
      || (status & STA_DRDY) == 0
c0024cc1:	a8 40                	test   $0x40,%al
c0024cc3:	74 04                	je     c0024cc9 <check_device_type+0x43>
      || (status & STA_BSY) != 0)
c0024cc5:	84 c0                	test   %al,%al
c0024cc7:	79 0c                	jns    c0024cd5 <check_device_type+0x4f>
    {
      d->is_ata = false;
c0024cc9:	c6 46 10 00          	movb   $0x0,0x10(%esi)
      return error != 0x81;      
c0024ccd:	80 fb 81             	cmp    $0x81,%bl
c0024cd0:	0f 95 c0             	setne  %al
c0024cd3:	eb 2c                	jmp    c0024d01 <check_device_type+0x7b>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0024cd5:	b8 01 00 00 00       	mov    $0x1,%eax
c0024cda:	89 f9                	mov    %edi,%ecx
c0024cdc:	89 eb                	mov    %ebp,%ebx
c0024cde:	08 d9                	or     %bl,%cl
c0024ce0:	74 13                	je     c0024cf5 <check_device_type+0x6f>
c0024ce2:	80 fb 3c             	cmp    $0x3c,%bl
c0024ce5:	0f 94 c0             	sete   %al
c0024ce8:	89 f9                	mov    %edi,%ecx
c0024cea:	80 f9 c3             	cmp    $0xc3,%cl
c0024ced:	0f 94 c2             	sete   %dl
c0024cf0:	0f b6 d2             	movzbl %dl,%edx
c0024cf3:	21 d0                	and    %edx,%eax
c0024cf5:	88 46 10             	mov    %al,0x10(%esi)
c0024cf8:	80 66 10 01          	andb   $0x1,0x10(%esi)
      return true; 
c0024cfc:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c0024d01:	83 c4 0c             	add    $0xc,%esp
c0024d04:	5b                   	pop    %ebx
c0024d05:	5e                   	pop    %esi
c0024d06:	5f                   	pop    %edi
c0024d07:	5d                   	pop    %ebp
c0024d08:	c3                   	ret    

c0024d09 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0024d09:	57                   	push   %edi
c0024d0a:	56                   	push   %esi
c0024d0b:	53                   	push   %ebx
  struct channel *c = d->channel;
c0024d0c:	8b 78 08             	mov    0x8(%eax),%edi

  ASSERT (sec_no < (1UL << 28));
c0024d0f:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0024d15:	76 21                	jbe    c0024d38 <select_sector+0x2f>
c0024d17:	83 ec 0c             	sub    $0xc,%esp
c0024d1a:	68 9f e6 02 c0       	push   $0xc002e69f
c0024d1f:	68 3f d2 02 c0       	push   $0xc002d23f
c0024d24:	68 48 c4 02 c0       	push   $0xc002c448
c0024d29:	68 89 01 00 00       	push   $0x189
c0024d2e:	68 79 e6 02 c0       	push   $0xc002e679
c0024d33:	e8 95 2f 00 00       	call   c0027ccd <debug_panic>
c0024d38:	89 c6                	mov    %eax,%esi
c0024d3a:	89 d3                	mov    %edx,%ebx
/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
  wait_until_idle (d);
c0024d3c:	e8 a5 fe ff ff       	call   c0024be6 <wait_until_idle>
  select_device (d);
c0024d41:	89 f0                	mov    %esi,%eax
c0024d43:	e8 08 ff ff ff       	call   c0024c50 <select_device>
  wait_until_idle (d);
c0024d48:	89 f0                	mov    %esi,%eax
c0024d4a:	e8 97 fe ff ff       	call   c0024be6 <wait_until_idle>
  struct channel *c = d->channel;

  ASSERT (sec_no < (1UL << 28));
  
  select_device_wait (d);
  outb (reg_nsect (c), 1);
c0024d4f:	0f b7 4f 08          	movzwl 0x8(%edi),%ecx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024d53:	8d 51 02             	lea    0x2(%ecx),%edx
c0024d56:	b8 01 00 00 00       	mov    $0x1,%eax
c0024d5b:	ee                   	out    %al,(%dx)
c0024d5c:	8d 51 03             	lea    0x3(%ecx),%edx
c0024d5f:	89 d8                	mov    %ebx,%eax
c0024d61:	ee                   	out    %al,(%dx)
c0024d62:	89 d8                	mov    %ebx,%eax
c0024d64:	c1 e8 08             	shr    $0x8,%eax
c0024d67:	8d 51 04             	lea    0x4(%ecx),%edx
c0024d6a:	ee                   	out    %al,(%dx)
c0024d6b:	89 d8                	mov    %ebx,%eax
c0024d6d:	c1 e8 10             	shr    $0x10,%eax
c0024d70:	8d 51 05             	lea    0x5(%ecx),%edx
c0024d73:	ee                   	out    %al,(%dx)
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c0024d74:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0024d78:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0024d7d:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c0024d82:	0f 45 c2             	cmovne %edx,%eax
c0024d85:	c1 eb 18             	shr    $0x18,%ebx
c0024d88:	09 d8                	or     %ebx,%eax
c0024d8a:	8d 51 06             	lea    0x6(%ecx),%edx
c0024d8d:	ee                   	out    %al,(%dx)
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
}
c0024d8e:	5b                   	pop    %ebx
c0024d8f:	5e                   	pop    %esi
c0024d90:	5f                   	pop    %edi
c0024d91:	c3                   	ret    

c0024d92 <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c0024d92:	57                   	push   %edi
c0024d93:	56                   	push   %esi
c0024d94:	53                   	push   %ebx
c0024d95:	89 c7                	mov    %eax,%edi
  struct channel *c = d->channel;
c0024d97:	8b 70 08             	mov    0x8(%eax),%esi
  int i;
  
  for (i = 0; i < 3000; i++)
c0024d9a:	bb 00 00 00 00       	mov    $0x0,%ebx
c0024d9f:	eb 19                	jmp    c0024dba <wait_while_busy+0x28>
    {
      if (i == 700)
c0024da1:	81 fb bc 02 00 00    	cmp    $0x2bc,%ebx
c0024da7:	75 11                	jne    c0024dba <wait_while_busy+0x28>
        printf ("%s: busy, waiting...", d->name);
c0024da9:	83 ec 08             	sub    $0x8,%esp
c0024dac:	57                   	push   %edi
c0024dad:	68 b4 e6 02 c0       	push   $0xc002e6b4
c0024db2:	e8 9e 12 00 00       	call   c0026055 <printf>
c0024db7:	83 c4 10             	add    $0x10,%esp
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024dba:	0f b7 46 08          	movzwl 0x8(%esi),%eax
c0024dbe:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0024dc4:	ec                   	in     (%dx),%al
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0024dc5:	84 c0                	test   %al,%al
c0024dc7:	78 2b                	js     c0024df4 <wait_while_busy+0x62>
        {
          if (i >= 700)
c0024dc9:	81 fb bb 02 00 00    	cmp    $0x2bb,%ebx
c0024dcf:	7e 10                	jle    c0024de1 <wait_while_busy+0x4f>
            printf ("ok\n");
c0024dd1:	83 ec 0c             	sub    $0xc,%esp
c0024dd4:	68 c9 e6 02 c0       	push   $0xc002e6c9
c0024dd9:	e8 26 49 00 00       	call   c0029704 <puts>
c0024dde:	83 c4 10             	add    $0x10,%esp
c0024de1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
c0024de5:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0024deb:	ec                   	in     (%dx),%al
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0024dec:	c0 e8 03             	shr    $0x3,%al
c0024def:	83 e0 01             	and    $0x1,%eax
c0024df2:	eb 2f                	jmp    c0024e23 <wait_while_busy+0x91>
        }
      timer_msleep (10);
c0024df4:	83 ec 08             	sub    $0x8,%esp
c0024df7:	6a 00                	push   $0x0
c0024df9:	6a 0a                	push   $0xa
c0024dfb:	e8 89 ed ff ff       	call   c0023b89 <timer_msleep>
wait_while_busy (const struct ata_disk *d) 
{
  struct channel *c = d->channel;
  int i;
  
  for (i = 0; i < 3000; i++)
c0024e00:	83 c3 01             	add    $0x1,%ebx
c0024e03:	83 c4 10             	add    $0x10,%esp
c0024e06:	81 fb b8 0b 00 00    	cmp    $0xbb8,%ebx
c0024e0c:	75 93                	jne    c0024da1 <wait_while_busy+0xf>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
        }
      timer_msleep (10);
    }

  printf ("failed\n");
c0024e0e:	83 ec 0c             	sub    $0xc,%esp
c0024e11:	68 e4 ef 02 c0       	push   $0xc002efe4
c0024e16:	e8 e9 48 00 00       	call   c0029704 <puts>
  return false;
c0024e1b:	83 c4 10             	add    $0x10,%esp
c0024e1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024e23:	5b                   	pop    %ebx
c0024e24:	5e                   	pop    %esi
c0024e25:	5f                   	pop    %edi
c0024e26:	c3                   	ret    

c0024e27 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0024e27:	56                   	push   %esi
c0024e28:	53                   	push   %ebx
c0024e29:	83 ec 04             	sub    $0x4,%esp
c0024e2c:	89 c3                	mov    %eax,%ebx
c0024e2e:	89 d6                	mov    %edx,%esi
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0024e30:	e8 1e c8 ff ff       	call   c0021653 <intr_get_level>
c0024e35:	83 f8 01             	cmp    $0x1,%eax
c0024e38:	74 21                	je     c0024e5b <issue_pio_command+0x34>
c0024e3a:	83 ec 0c             	sub    $0xc,%esp
c0024e3d:	68 aa dd 02 c0       	push   $0xc002ddaa
c0024e42:	68 3f d2 02 c0       	push   $0xc002d23f
c0024e47:	68 28 c4 02 c0       	push   $0xc002c428
c0024e4c:	68 9b 01 00 00       	push   $0x19b
c0024e51:	68 79 e6 02 c0       	push   $0xc002e679
c0024e56:	e8 72 2e 00 00       	call   c0027ccd <debug_panic>

  c->expecting_interrupt = true;
c0024e5b:	c6 43 2c 01          	movb   $0x1,0x2c(%ebx)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024e5f:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
c0024e63:	83 c2 07             	add    $0x7,%edx
c0024e66:	89 f0                	mov    %esi,%eax
c0024e68:	ee                   	out    %al,(%dx)
  outb (reg_command (c), command);
}
c0024e69:	83 c4 04             	add    $0x4,%esp
c0024e6c:	5b                   	pop    %ebx
c0024e6d:	5e                   	pop    %esi
c0024e6e:	c3                   	ret    

c0024e6f <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0024e6f:	57                   	push   %edi
c0024e70:	56                   	push   %esi
c0024e71:	53                   	push   %ebx
c0024e72:	8b 74 24 10          	mov    0x10(%esp),%esi
  struct ata_disk *d = d_;
  struct channel *c = d->channel;
c0024e76:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c0024e79:	8d 7b 0c             	lea    0xc(%ebx),%edi
c0024e7c:	83 ec 0c             	sub    $0xc,%esp
c0024e7f:	57                   	push   %edi
c0024e80:	e8 3a db ff ff       	call   c00229bf <lock_acquire>
  select_sector (d, sec_no);
c0024e85:	8b 54 24 24          	mov    0x24(%esp),%edx
c0024e89:	89 f0                	mov    %esi,%eax
c0024e8b:	e8 79 fe ff ff       	call   c0024d09 <select_sector>
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0024e90:	ba 30 00 00 00       	mov    $0x30,%edx
c0024e95:	89 d8                	mov    %ebx,%eax
c0024e97:	e8 8b ff ff ff       	call   c0024e27 <issue_pio_command>
  if (!wait_while_busy (d))
c0024e9c:	89 f0                	mov    %esi,%eax
c0024e9e:	e8 ef fe ff ff       	call   c0024d92 <wait_while_busy>
c0024ea3:	83 c4 10             	add    $0x10,%esp
c0024ea6:	84 c0                	test   %al,%al
c0024ea8:	75 21                	jne    c0024ecb <ide_write+0x5c>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0024eaa:	83 ec 08             	sub    $0x8,%esp
c0024ead:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024eb1:	56                   	push   %esi
c0024eb2:	68 18 e7 02 c0       	push   $0xc002e718
c0024eb7:	68 58 c4 02 c0       	push   $0xc002c458
c0024ebc:	68 75 01 00 00       	push   $0x175
c0024ec1:	68 79 e6 02 c0       	push   $0xc002e679
c0024ec6:	e8 02 2e 00 00       	call   c0027ccd <debug_panic>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0024ecb:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
c0024ecf:	8b 74 24 18          	mov    0x18(%esp),%esi
c0024ed3:	b9 00 01 00 00       	mov    $0x100,%ecx
c0024ed8:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  output_sector (c, buffer);
  sema_down (&c->completion_wait);
c0024edb:	83 ec 0c             	sub    $0xc,%esp
c0024ede:	83 c3 30             	add    $0x30,%ebx
c0024ee1:	53                   	push   %ebx
c0024ee2:	e8 3f d8 ff ff       	call   c0022726 <sema_down>
  lock_release (&c->lock);
c0024ee7:	89 3c 24             	mov    %edi,(%esp)
c0024eea:	e8 60 dc ff ff       	call   c0022b4f <lock_release>
}
c0024eef:	83 c4 10             	add    $0x10,%esp
c0024ef2:	5b                   	pop    %ebx
c0024ef3:	5e                   	pop    %esi
c0024ef4:	5f                   	pop    %edi
c0024ef5:	c3                   	ret    

c0024ef6 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0024ef6:	57                   	push   %edi
c0024ef7:	56                   	push   %esi
c0024ef8:	53                   	push   %ebx
c0024ef9:	81 ec 80 02 00 00    	sub    $0x280,%esp
  struct channel *c = d->channel;
c0024eff:	8b 70 08             	mov    0x8(%eax),%esi
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0024f02:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c0024f06:	75 21                	jne    c0024f29 <identify_ata_device+0x33>
c0024f08:	83 ec 0c             	sub    $0xc,%esp
c0024f0b:	68 cc e6 02 c0       	push   $0xc002e6cc
c0024f10:	68 3f d2 02 c0       	push   $0xc002d23f
c0024f15:	68 64 c4 02 c0       	push   $0xc002c464
c0024f1a:	68 0d 01 00 00       	push   $0x10d
c0024f1f:	68 79 e6 02 c0       	push   $0xc002e679
c0024f24:	e8 a4 2d 00 00       	call   c0027ccd <debug_panic>
c0024f29:	89 c3                	mov    %eax,%ebx
/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
  wait_until_idle (d);
c0024f2b:	e8 b6 fc ff ff       	call   c0024be6 <wait_until_idle>
  select_device (d);
c0024f30:	89 d8                	mov    %ebx,%eax
c0024f32:	e8 19 fd ff ff       	call   c0024c50 <select_device>
  wait_until_idle (d);
c0024f37:	89 d8                	mov    %ebx,%eax
c0024f39:	e8 a8 fc ff ff       	call   c0024be6 <wait_until_idle>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0024f3e:	ba ec 00 00 00       	mov    $0xec,%edx
c0024f43:	89 f0                	mov    %esi,%eax
c0024f45:	e8 dd fe ff ff       	call   c0024e27 <issue_pio_command>
  sema_down (&c->completion_wait);
c0024f4a:	83 ec 0c             	sub    $0xc,%esp
c0024f4d:	8d 46 30             	lea    0x30(%esi),%eax
c0024f50:	50                   	push   %eax
c0024f51:	e8 d0 d7 ff ff       	call   c0022726 <sema_down>
  if (!wait_while_busy (d))
c0024f56:	89 d8                	mov    %ebx,%eax
c0024f58:	e8 35 fe ff ff       	call   c0024d92 <wait_while_busy>
c0024f5d:	83 c4 10             	add    $0x10,%esp
c0024f60:	84 c0                	test   %al,%al
c0024f62:	75 09                	jne    c0024f6d <identify_ata_device+0x77>
    {
      d->is_ata = false;
c0024f64:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
      return;
c0024f68:	e9 bc 00 00 00       	jmp    c0025029 <identify_ata_device+0x133>
   another, and stores them into the buffer starting at ADDR. */
static inline void
insw (uint16_t port, void *addr, size_t cnt)
{
  /* See [IA32-v2a] "INS". */
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0024f6d:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0024f71:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0024f78:	b9 00 01 00 00       	mov    $0x100,%ecx
c0024f7d:	66 f3 6d             	rep insw (%dx),%es:(%edi)
    }
  input_sector (c, id);

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0024f80:	8b b4 24 f8 00 00 00 	mov    0xf8(%esp),%esi
  model = descramble_ata_string (&id[10 * 2], 20);
c0024f87:	ba 14 00 00 00       	mov    $0x14,%edx
c0024f8c:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0024f93:	e8 76 fb ff ff       	call   c0024b0e <descramble_ata_string>
c0024f98:	89 c7                	mov    %eax,%edi
  serial = descramble_ata_string (&id[27 * 2], 40);
c0024f9a:	ba 28 00 00 00       	mov    $0x28,%edx
c0024f9f:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c0024fa6:	e8 63 fb ff ff       	call   c0024b0e <descramble_ata_string>
  snprintf (extra_info, sizeof extra_info,
c0024fab:	83 ec 0c             	sub    $0xc,%esp
c0024fae:	50                   	push   %eax
c0024faf:	57                   	push   %edi
c0024fb0:	68 d6 e6 02 c0       	push   $0xc002e6d6
c0024fb5:	68 80 00 00 00       	push   $0x80
c0024fba:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0024fbe:	50                   	push   %eax
c0024fbf:	e8 9e 17 00 00       	call   c0026762 <snprintf>
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0024fc4:	83 c4 20             	add    $0x20,%esp
c0024fc7:	81 fe ff ff 1f 00    	cmp    $0x1fffff,%esi
c0024fcd:	76 37                	jbe    c0025006 <identify_ata_device+0x110>
    {
      printf ("%s: ignoring ", d->name);
c0024fcf:	83 ec 08             	sub    $0x8,%esp
c0024fd2:	53                   	push   %ebx
c0024fd3:	68 ee e6 02 c0       	push   $0xc002e6ee
c0024fd8:	e8 78 10 00 00       	call   c0026055 <printf>
      print_human_readable_size (capacity * 512);
c0024fdd:	83 c4 08             	add    $0x8,%esp
c0024fe0:	89 f0                	mov    %esi,%eax
c0024fe2:	c1 e0 09             	shl    $0x9,%eax
c0024fe5:	ba 00 00 00 00       	mov    $0x0,%edx
c0024fea:	52                   	push   %edx
c0024feb:	50                   	push   %eax
c0024fec:	e8 7c 19 00 00       	call   c002696d <print_human_readable_size>
      printf ("disk for safety\n");
c0024ff1:	c7 04 24 fc e6 02 c0 	movl   $0xc002e6fc,(%esp)
c0024ff8:	e8 07 47 00 00       	call   c0029704 <puts>
      d->is_ata = false;
c0024ffd:	c6 43 10 00          	movb   $0x0,0x10(%ebx)
      return;
c0025001:	83 c4 10             	add    $0x10,%esp
c0025004:	eb 23                	jmp    c0025029 <identify_ata_device+0x133>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025006:	83 ec 08             	sub    $0x8,%esp
c0025009:	53                   	push   %ebx
c002500a:	68 d8 79 03 c0       	push   $0xc00379d8
c002500f:	56                   	push   %esi
c0025010:	8d 44 24 14          	lea    0x14(%esp),%eax
c0025014:	50                   	push   %eax
c0025015:	6a 04                	push   $0x4
c0025017:	53                   	push   %ebx
c0025018:	e8 3a f6 ff ff       	call   c0024657 <block_register>
                          &ide_operations, d);
  partition_scan (block);
c002501d:	83 c4 14             	add    $0x14,%esp
c0025020:	50                   	push   %eax
c0025021:	e8 99 fa ff ff       	call   c0024abf <partition_scan>
c0025026:	83 c4 10             	add    $0x10,%esp
}
c0025029:	81 c4 80 02 00 00    	add    $0x280,%esp
c002502f:	5b                   	pop    %ebx
c0025030:	5e                   	pop    %esi
c0025031:	5f                   	pop    %edi
c0025032:	c3                   	ret    

c0025033 <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c0025033:	55                   	push   %ebp
c0025034:	57                   	push   %edi
c0025035:	56                   	push   %esi
c0025036:	53                   	push   %ebx
c0025037:	83 ec 18             	sub    $0x18,%esp
c002503a:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct ata_disk *d = d_;
  struct channel *c = d->channel;
c002503e:	8b 5e 08             	mov    0x8(%esi),%ebx
  lock_acquire (&c->lock);
c0025041:	8d 6b 0c             	lea    0xc(%ebx),%ebp
c0025044:	55                   	push   %ebp
c0025045:	e8 75 d9 ff ff       	call   c00229bf <lock_acquire>
  select_sector (d, sec_no);
c002504a:	8b 54 24 34          	mov    0x34(%esp),%edx
c002504e:	89 f0                	mov    %esi,%eax
c0025050:	e8 b4 fc ff ff       	call   c0024d09 <select_sector>
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025055:	ba 20 00 00 00       	mov    $0x20,%edx
c002505a:	89 d8                	mov    %ebx,%eax
c002505c:	e8 c6 fd ff ff       	call   c0024e27 <issue_pio_command>
  sema_down (&c->completion_wait);
c0025061:	8d 43 30             	lea    0x30(%ebx),%eax
c0025064:	89 04 24             	mov    %eax,(%esp)
c0025067:	e8 ba d6 ff ff       	call   c0022726 <sema_down>
  if (!wait_while_busy (d))
c002506c:	89 f0                	mov    %esi,%eax
c002506e:	e8 1f fd ff ff       	call   c0024d92 <wait_while_busy>
c0025073:	83 c4 10             	add    $0x10,%esp
c0025076:	84 c0                	test   %al,%al
c0025078:	75 21                	jne    c002509b <ide_read+0x68>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c002507a:	83 ec 08             	sub    $0x8,%esp
c002507d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025081:	56                   	push   %esi
c0025082:	68 3c e7 02 c0       	push   $0xc002e73c
c0025087:	68 3c c4 02 c0       	push   $0xc002c43c
c002508c:	68 62 01 00 00       	push   $0x162
c0025091:	68 79 e6 02 c0       	push   $0xc002e679
c0025096:	e8 32 2c 00 00       	call   c0027ccd <debug_panic>
c002509b:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
c002509f:	8b 7c 24 28          	mov    0x28(%esp),%edi
c00250a3:	b9 00 01 00 00       	mov    $0x100,%ecx
c00250a8:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  input_sector (c, buffer);
  lock_release (&c->lock);
c00250ab:	83 ec 0c             	sub    $0xc,%esp
c00250ae:	55                   	push   %ebp
c00250af:	e8 9b da ff ff       	call   c0022b4f <lock_release>
}
c00250b4:	83 c4 1c             	add    $0x1c,%esp
c00250b7:	5b                   	pop    %ebx
c00250b8:	5e                   	pop    %esi
c00250b9:	5f                   	pop    %edi
c00250ba:	5d                   	pop    %ebp
c00250bb:	c3                   	ret    

c00250bc <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c00250bc:	55                   	push   %ebp
c00250bd:	57                   	push   %edi
c00250be:	56                   	push   %esi
c00250bf:	53                   	push   %ebx
c00250c0:	83 ec 3c             	sub    $0x3c,%esp
c00250c3:	c7 44 24 14 b8 93 03 	movl   $0xc00393b8,0x14(%esp)
c00250ca:	c0 
c00250cb:	bf a4 93 03 c0       	mov    $0xc00393a4,%edi
c00250d0:	c7 44 24 10 61 00 00 	movl   $0x61,0x10(%esp)
c00250d7:	00 
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00250d8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00250df:	00 
c00250e0:	8d 77 bc             	lea    -0x44(%edi),%esi
    {
      struct channel *c = &channels[chan_no];
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c00250e3:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c00250e7:	53                   	push   %ebx
c00250e8:	68 0c e7 02 c0       	push   $0xc002e70c
c00250ed:	6a 08                	push   $0x8
c00250ef:	56                   	push   %esi
c00250f0:	e8 6d 16 00 00       	call   c0026762 <snprintf>
      switch (chan_no) 
c00250f5:	83 c4 10             	add    $0x10,%esp
c00250f8:	85 db                	test   %ebx,%ebx
c00250fa:	74 07                	je     c0025103 <ide_init+0x47>
c00250fc:	83 fb 01             	cmp    $0x1,%ebx
c00250ff:	74 14                	je     c0025115 <ide_init+0x59>
c0025101:	eb 24                	jmp    c0025127 <ide_init+0x6b>
        {
        case 0:
          c->reg_base = 0x1f0;
c0025103:	66 c7 05 68 93 03 c0 	movw   $0x1f0,0xc0039368
c002510a:	f0 01 
          c->irq = 14 + 0x20;
c002510c:	c6 05 6a 93 03 c0 2e 	movb   $0x2e,0xc003936a
          break;
c0025113:	eb 28                	jmp    c002513d <ide_init+0x81>
        case 1:
          c->reg_base = 0x170;
c0025115:	66 c7 05 d4 93 03 c0 	movw   $0x170,0xc00393d4
c002511c:	70 01 
          c->irq = 15 + 0x20;
c002511e:	c6 05 d6 93 03 c0 2f 	movb   $0x2f,0xc00393d6
          break;
c0025125:	eb 16                	jmp    c002513d <ide_init+0x81>
        default:
          NOT_REACHED ();
c0025127:	68 c0 d6 02 c0       	push   $0xc002d6c0
c002512c:	68 8c c4 02 c0       	push   $0xc002c48c
c0025131:	6a 7c                	push   $0x7c
c0025133:	68 79 e6 02 c0       	push   $0xc002e679
c0025138:	e8 90 2b 00 00       	call   c0027ccd <debug_panic>
        }
      lock_init (&c->lock);
c002513d:	83 ec 0c             	sub    $0xc,%esp
c0025140:	8d 47 c8             	lea    -0x38(%edi),%eax
c0025143:	50                   	push   %eax
c0025144:	e8 f4 d7 ff ff       	call   c002293d <lock_init>
c0025149:	89 fb                	mov    %edi,%ebx
      c->expecting_interrupt = false;
c002514b:	c6 47 e8 00          	movb   $0x0,-0x18(%edi)
      sema_init (&c->completion_wait, 0);
c002514f:	83 c4 08             	add    $0x8,%esp
c0025152:	6a 00                	push   $0x0
c0025154:	8d 47 ec             	lea    -0x14(%edi),%eax
c0025157:	50                   	push   %eax
c0025158:	e8 8a d5 ff ff       	call   c00226e7 <sema_init>
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        {
          struct ata_disk *d = &c->devices[dev_no];
          snprintf (d->name, sizeof d->name,
c002515d:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025161:	55                   	push   %ebp
c0025162:	68 13 e7 02 c0       	push   $0xc002e713
c0025167:	6a 08                	push   $0x8
c0025169:	57                   	push   %edi
c002516a:	e8 f3 15 00 00       	call   c0026762 <snprintf>
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
          d->channel = c;
c002516f:	89 77 08             	mov    %esi,0x8(%edi)
          d->dev_no = dev_no;
c0025172:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
          d->is_ata = false;
c0025179:	c6 47 10 00          	movb   $0x0,0x10(%edi)
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        {
          struct ata_disk *d = &c->devices[dev_no];
          snprintf (d->name, sizeof d->name,
c002517d:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c0025181:	89 4c 24 38          	mov    %ecx,0x38(%esp)
c0025185:	83 c4 20             	add    $0x20,%esp
c0025188:	89 e8                	mov    %ebp,%eax
c002518a:	83 c0 01             	add    $0x1,%eax
c002518d:	50                   	push   %eax
c002518e:	68 13 e7 02 c0       	push   $0xc002e713
c0025193:	6a 08                	push   $0x8
c0025195:	51                   	push   %ecx
c0025196:	e8 c7 15 00 00       	call   c0026762 <snprintf>
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
          d->channel = c;
c002519b:	89 77 1c             	mov    %esi,0x1c(%edi)
          d->dev_no = dev_no;
c002519e:	c7 47 20 01 00 00 00 	movl   $0x1,0x20(%edi)
          d->is_ata = false;
c00251a5:	c6 47 24 00          	movb   $0x0,0x24(%edi)
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c00251a9:	83 c4 0c             	add    $0xc,%esp
c00251ac:	56                   	push   %esi
c00251ad:	68 6b 4b 02 c0       	push   $0xc0024b6b
c00251b2:	0f b6 47 c6          	movzbl -0x3a(%edi),%eax
c00251b6:	50                   	push   %eax
c00251b7:	e8 73 c6 ff ff       	call   c002182f <intr_register_ext>
c00251bc:	8d 74 24 3e          	lea    0x3e(%esp),%esi
c00251c0:	83 c4 10             	add    $0x10,%esp
c00251c3:	89 7c 24 0c          	mov    %edi,0xc(%esp)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00251c7:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
    {
      struct ata_disk *d = &c->devices[dev_no];

      select_device (d);
c00251cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00251cf:	e8 7c fa ff ff       	call   c0024c50 <select_device>

      outb (reg_nsect (c), 0x55);
c00251d4:	0f b7 6b c4          	movzwl -0x3c(%ebx),%ebp
c00251d8:	8d 4d 02             	lea    0x2(%ebp),%ecx
c00251db:	b8 55 00 00 00       	mov    $0x55,%eax
c00251e0:	89 ca                	mov    %ecx,%edx
c00251e2:	ee                   	out    %al,(%dx)
      outb (reg_lbal (c), 0xaa);
c00251e3:	8d 7d 03             	lea    0x3(%ebp),%edi
c00251e6:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00251eb:	89 fa                	mov    %edi,%edx
c00251ed:	ee                   	out    %al,(%dx)
c00251ee:	89 ca                	mov    %ecx,%edx
c00251f0:	ee                   	out    %al,(%dx)
c00251f1:	b8 55 00 00 00       	mov    $0x55,%eax
c00251f6:	89 fa                	mov    %edi,%edx
c00251f8:	ee                   	out    %al,(%dx)
c00251f9:	89 ca                	mov    %ecx,%edx
c00251fb:	ee                   	out    %al,(%dx)
c00251fc:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0025201:	89 fa                	mov    %edi,%edx
c0025203:	ee                   	out    %al,(%dx)
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025204:	89 ca                	mov    %ecx,%edx
c0025206:	ec                   	in     (%dx),%al

      outb (reg_nsect (c), 0x55);
      outb (reg_lbal (c), 0xaa);

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
                         && inb (reg_lbal (c)) == 0xaa);
c0025207:	ba 00 00 00 00       	mov    $0x0,%edx
c002520c:	3c 55                	cmp    $0x55,%al
c002520e:	75 0b                	jne    c002521b <ide_init+0x15f>
c0025210:	89 fa                	mov    %edi,%edx
c0025212:	ec                   	in     (%dx),%al
c0025213:	3c aa                	cmp    $0xaa,%al
c0025215:	0f 94 c2             	sete   %dl
c0025218:	0f b6 d2             	movzbl %dl,%edx
      outb (reg_lbal (c), 0x55);

      outb (reg_nsect (c), 0x55);
      outb (reg_lbal (c), 0xaa);

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c002521b:	88 16                	mov    %dl,(%esi)
c002521d:	80 26 01             	andb   $0x1,(%esi)
c0025220:	83 44 24 0c 14       	addl   $0x14,0xc(%esp)
c0025225:	83 c6 01             	add    $0x1,%esi
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025228:	8d 44 24 30          	lea    0x30(%esp),%eax
c002522c:	39 c6                	cmp    %eax,%esi
c002522e:	75 9b                	jne    c00251cb <ide_init+0x10f>
c0025230:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025234:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c002523a:	b8 00 00 00 00       	mov    $0x0,%eax
c002523f:	ee                   	out    %al,(%dx)
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
  timer_usleep (10);
c0025240:	83 ec 08             	sub    $0x8,%esp
c0025243:	6a 00                	push   $0x0
c0025245:	6a 0a                	push   $0xa
c0025247:	e8 56 e9 ff ff       	call   c0023ba2 <timer_usleep>
c002524c:	0f b7 43 c4          	movzwl -0x3c(%ebx),%eax
c0025250:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025256:	b8 04 00 00 00       	mov    $0x4,%eax
c002525b:	ee                   	out    %al,(%dx)
  outb (reg_ctl (c), CTL_SRST);
  timer_usleep (10);
c002525c:	83 c4 08             	add    $0x8,%esp
c002525f:	6a 00                	push   $0x0
c0025261:	6a 0a                	push   $0xa
c0025263:	e8 3a e9 ff ff       	call   c0023ba2 <timer_usleep>
c0025268:	0f b7 43 c4          	movzwl -0x3c(%ebx),%eax
c002526c:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c0025272:	b8 00 00 00 00       	mov    $0x0,%eax
c0025277:	ee                   	out    %al,(%dx)
  outb (reg_ctl (c), 0);

  timer_msleep (150);
c0025278:	83 c4 08             	add    $0x8,%esp
c002527b:	6a 00                	push   $0x0
c002527d:	68 96 00 00 00       	push   $0x96
c0025282:	e8 02 e9 ff ff       	call   c0023b89 <timer_msleep>

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025287:	83 c4 10             	add    $0x10,%esp
c002528a:	80 7c 24 2e 00       	cmpb   $0x0,0x2e(%esp)
c002528f:	74 0e                	je     c002529f <ide_init+0x1e3>
    {
      select_device (&c->devices[0]);
c0025291:	89 d8                	mov    %ebx,%eax
c0025293:	e8 b8 f9 ff ff       	call   c0024c50 <select_device>
      wait_while_busy (&c->devices[0]); 
c0025298:	89 d8                	mov    %ebx,%eax
c002529a:	e8 f3 fa ff ff       	call   c0024d92 <wait_while_busy>
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c002529f:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
c00252a4:	74 3f                	je     c00252e5 <ide_init+0x229>
    {
      int i;

      select_device (&c->devices[1]);
c00252a6:	8b 44 24 18          	mov    0x18(%esp),%eax
c00252aa:	e8 a1 f9 ff ff       	call   c0024c50 <select_device>
c00252af:	be b8 0b 00 00       	mov    $0xbb8,%esi
      for (i = 0; i < 3000; i++) 
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c00252b4:	0f b7 4b c4          	movzwl -0x3c(%ebx),%ecx
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00252b8:	8d 51 02             	lea    0x2(%ecx),%edx
c00252bb:	ec                   	in     (%dx),%al
c00252bc:	3c 01                	cmp    $0x1,%al
c00252be:	75 08                	jne    c00252c8 <ide_init+0x20c>
c00252c0:	8d 51 03             	lea    0x3(%ecx),%edx
c00252c3:	ec                   	in     (%dx),%al
c00252c4:	3c 01                	cmp    $0x1,%al
c00252c6:	74 14                	je     c00252dc <ide_init+0x220>
            break;
          timer_msleep (10);
c00252c8:	83 ec 08             	sub    $0x8,%esp
c00252cb:	6a 00                	push   $0x0
c00252cd:	6a 0a                	push   $0xa
c00252cf:	e8 b5 e8 ff ff       	call   c0023b89 <timer_msleep>
  if (present[1])
    {
      int i;

      select_device (&c->devices[1]);
      for (i = 0; i < 3000; i++) 
c00252d4:	83 c4 10             	add    $0x10,%esp
c00252d7:	83 ee 01             	sub    $0x1,%esi
c00252da:	75 d8                	jne    c00252b4 <ide_init+0x1f8>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
            break;
          timer_msleep (10);
        }
      wait_while_busy (&c->devices[1]);
c00252dc:	8b 44 24 18          	mov    0x18(%esp),%eax
c00252e0:	e8 ad fa ff ff       	call   c0024d92 <wait_while_busy>

      /* Reset hardware. */
      reset_channel (c);

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c00252e5:	89 d8                	mov    %ebx,%eax
c00252e7:	e8 9a f9 ff ff       	call   c0024c86 <check_device_type>
c00252ec:	84 c0                	test   %al,%al
c00252ee:	74 09                	je     c00252f9 <ide_init+0x23d>
        check_device_type (&c->devices[1]);
c00252f0:	8b 44 24 18          	mov    0x18(%esp),%eax
c00252f4:	e8 8d f9 ff ff       	call   c0024c86 <check_device_type>

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
c00252f9:	80 7b 10 00          	cmpb   $0x0,0x10(%ebx)
c00252fd:	74 07                	je     c0025306 <ide_init+0x24a>
          identify_ata_device (&c->devices[dev_no]);
c00252ff:	89 d8                	mov    %ebx,%eax
c0025301:	e8 f0 fb ff ff       	call   c0024ef6 <identify_ata_device>
      if (check_device_type (&c->devices[0]))
        check_device_type (&c->devices[1]);

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
c0025306:	80 7b 24 00          	cmpb   $0x0,0x24(%ebx)
c002530a:	74 09                	je     c0025315 <ide_init+0x259>
          identify_ata_device (&c->devices[dev_no]);
c002530c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0025310:	e8 e1 fb ff ff       	call   c0024ef6 <identify_ata_device>
void
ide_init (void) 
{
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025315:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
c002531a:	8b 44 24 08          	mov    0x8(%esp),%eax
c002531e:	83 44 24 14 6c       	addl   $0x6c,0x14(%esp)
c0025323:	83 c7 6c             	add    $0x6c,%edi
c0025326:	83 44 24 10 02       	addl   $0x2,0x10(%esp)
c002532b:	83 f8 02             	cmp    $0x2,%eax
c002532e:	0f 85 ac fd ff ff    	jne    c00250e0 <ide_init+0x24>
      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
          identify_ata_device (&c->devices[dev_no]);
    }
}
c0025334:	83 c4 3c             	add    $0x3c,%esp
c0025337:	5b                   	pop    %ebx
c0025338:	5e                   	pop    %esi
c0025339:	5f                   	pop    %edi
c002533a:	5d                   	pop    %ebp
c002533b:	c3                   	ret    

c002533c <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c002533c:	83 ec 18             	sub    $0x18,%esp
  intq_init (&buffer);
c002533f:	68 40 94 03 c0       	push   $0xc0039440
c0025344:	e8 eb 00 00 00       	call   c0025434 <intq_init>
}
c0025349:	83 c4 1c             	add    $0x1c,%esp
c002534c:	c3                   	ret    

c002534d <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c002534d:	53                   	push   %ebx
c002534e:	83 ec 08             	sub    $0x8,%esp
c0025351:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c0025355:	e8 f9 c2 ff ff       	call   c0021653 <intr_get_level>
c002535a:	85 c0                	test   %eax,%eax
c002535c:	74 1e                	je     c002537c <input_putc+0x2f>
c002535e:	83 ec 0c             	sub    $0xc,%esp
c0025361:	68 94 d5 02 c0       	push   $0xc002d594
c0025366:	68 3f d2 02 c0       	push   $0xc002d23f
c002536b:	68 a4 c4 02 c0       	push   $0xc002c4a4
c0025370:	6a 15                	push   $0x15
c0025372:	68 5c e7 02 c0       	push   $0xc002e75c
c0025377:	e8 51 29 00 00       	call   c0027ccd <debug_panic>
  ASSERT (!intq_full (&buffer));
c002537c:	83 ec 0c             	sub    $0xc,%esp
c002537f:	68 40 94 03 c0       	push   $0xc0039440
c0025384:	e8 17 01 00 00       	call   c00254a0 <intq_full>
c0025389:	83 c4 10             	add    $0x10,%esp
c002538c:	84 c0                	test   %al,%al
c002538e:	74 1e                	je     c00253ae <input_putc+0x61>
c0025390:	83 ec 0c             	sub    $0xc,%esp
c0025393:	68 72 e7 02 c0       	push   $0xc002e772
c0025398:	68 3f d2 02 c0       	push   $0xc002d23f
c002539d:	68 a4 c4 02 c0       	push   $0xc002c4a4
c00253a2:	6a 16                	push   $0x16
c00253a4:	68 5c e7 02 c0       	push   $0xc002e75c
c00253a9:	e8 1f 29 00 00       	call   c0027ccd <debug_panic>

  intq_putc (&buffer, key);
c00253ae:	83 ec 08             	sub    $0x8,%esp
c00253b1:	0f b6 db             	movzbl %bl,%ebx
c00253b4:	53                   	push   %ebx
c00253b5:	68 40 94 03 c0       	push   $0xc0039440
c00253ba:	e8 2f 03 00 00       	call   c00256ee <intq_putc>
  serial_notify ();
c00253bf:	e8 e3 ef ff ff       	call   c00243a7 <serial_notify>
}
c00253c4:	83 c4 18             	add    $0x18,%esp
c00253c7:	5b                   	pop    %ebx
c00253c8:	c3                   	ret    

c00253c9 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c00253c9:	56                   	push   %esi
c00253ca:	53                   	push   %ebx
c00253cb:	83 ec 04             	sub    $0x4,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c00253ce:	e8 bd c2 ff ff       	call   c0021690 <intr_disable>
c00253d3:	89 c6                	mov    %eax,%esi
  key = intq_getc (&buffer);
c00253d5:	83 ec 0c             	sub    $0xc,%esp
c00253d8:	68 40 94 03 c0       	push   $0xc0039440
c00253dd:	e8 58 02 00 00       	call   c002563a <intq_getc>
c00253e2:	89 c3                	mov    %eax,%ebx
  serial_notify ();
c00253e4:	e8 be ef ff ff       	call   c00243a7 <serial_notify>
  intr_set_level (old_level);
c00253e9:	89 34 24             	mov    %esi,(%esp)
c00253ec:	e8 a6 c2 ff ff       	call   c0021697 <intr_set_level>
  
  return key;
}
c00253f1:	89 d8                	mov    %ebx,%eax
c00253f3:	83 c4 14             	add    $0x14,%esp
c00253f6:	5b                   	pop    %ebx
c00253f7:	5e                   	pop    %esi
c00253f8:	c3                   	ret    

c00253f9 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00253f9:	83 ec 0c             	sub    $0xc,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00253fc:	e8 52 c2 ff ff       	call   c0021653 <intr_get_level>
c0025401:	85 c0                	test   %eax,%eax
c0025403:	74 1e                	je     c0025423 <input_full+0x2a>
c0025405:	83 ec 0c             	sub    $0xc,%esp
c0025408:	68 94 d5 02 c0       	push   $0xc002d594
c002540d:	68 3f d2 02 c0       	push   $0xc002d23f
c0025412:	68 98 c4 02 c0       	push   $0xc002c498
c0025417:	6a 32                	push   $0x32
c0025419:	68 5c e7 02 c0       	push   $0xc002e75c
c002541e:	e8 aa 28 00 00       	call   c0027ccd <debug_panic>
  return intq_full (&buffer);
c0025423:	83 ec 0c             	sub    $0xc,%esp
c0025426:	68 40 94 03 c0       	push   $0xc0039440
c002542b:	e8 70 00 00 00       	call   c00254a0 <intq_full>
}
c0025430:	83 c4 1c             	add    $0x1c,%esp
c0025433:	c3                   	ret    

c0025434 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0025434:	53                   	push   %ebx
c0025435:	83 ec 14             	sub    $0x14,%esp
c0025438:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  lock_init (&q->lock);
c002543c:	53                   	push   %ebx
c002543d:	e8 fb d4 ff ff       	call   c002293d <lock_init>
  q->not_full = q->not_empty = NULL;
c0025442:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
c0025449:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  q->head = q->tail = 0;
c0025450:	c7 43 6c 00 00 00 00 	movl   $0x0,0x6c(%ebx)
c0025457:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
}
c002545e:	83 c4 18             	add    $0x18,%esp
c0025461:	5b                   	pop    %ebx
c0025462:	c3                   	ret    

c0025463 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0025463:	53                   	push   %ebx
c0025464:	83 ec 08             	sub    $0x8,%esp
c0025467:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c002546b:	e8 e3 c1 ff ff       	call   c0021653 <intr_get_level>
c0025470:	85 c0                	test   %eax,%eax
c0025472:	74 1e                	je     c0025492 <intq_empty+0x2f>
c0025474:	83 ec 0c             	sub    $0xc,%esp
c0025477:	68 94 d5 02 c0       	push   $0xc002d594
c002547c:	68 3f d2 02 c0       	push   $0xc002d23f
c0025481:	68 e4 c4 02 c0       	push   $0xc002c4e4
c0025486:	6a 16                	push   $0x16
c0025488:	68 87 e7 02 c0       	push   $0xc002e787
c002548d:	e8 3b 28 00 00       	call   c0027ccd <debug_panic>
  return q->head == q->tail;
c0025492:	8b 43 6c             	mov    0x6c(%ebx),%eax
c0025495:	39 43 68             	cmp    %eax,0x68(%ebx)
c0025498:	0f 94 c0             	sete   %al
}
c002549b:	83 c4 08             	add    $0x8,%esp
c002549e:	5b                   	pop    %ebx
c002549f:	c3                   	ret    

c00254a0 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c00254a0:	53                   	push   %ebx
c00254a1:	83 ec 08             	sub    $0x8,%esp
c00254a4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00254a8:	e8 a6 c1 ff ff       	call   c0021653 <intr_get_level>
c00254ad:	85 c0                	test   %eax,%eax
c00254af:	74 1e                	je     c00254cf <intq_full+0x2f>
c00254b1:	83 ec 0c             	sub    $0xc,%esp
c00254b4:	68 94 d5 02 c0       	push   $0xc002d594
c00254b9:	68 3f d2 02 c0       	push   $0xc002d23f
c00254be:	68 d8 c4 02 c0       	push   $0xc002c4d8
c00254c3:	6a 1e                	push   $0x1e
c00254c5:	68 87 e7 02 c0       	push   $0xc002e787
c00254ca:	e8 fe 27 00 00       	call   c0027ccd <debug_panic>
  return next (q->head) == q->tail;
c00254cf:	8b 43 68             	mov    0x68(%ebx),%eax
c00254d2:	83 c0 01             	add    $0x1,%eax
c00254d5:	99                   	cltd   
c00254d6:	c1 ea 1a             	shr    $0x1a,%edx
c00254d9:	01 d0                	add    %edx,%eax
c00254db:	83 e0 3f             	and    $0x3f,%eax
c00254de:	29 d0                	sub    %edx,%eax
c00254e0:	3b 43 6c             	cmp    0x6c(%ebx),%eax
c00254e3:	0f 94 c0             	sete   %al
}
c00254e6:	83 c4 08             	add    $0x8,%esp
c00254e9:	5b                   	pop    %ebx
c00254ea:	c3                   	ret    

c00254eb <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c00254eb:	56                   	push   %esi
c00254ec:	53                   	push   %ebx
c00254ed:	83 ec 04             	sub    $0x4,%esp
c00254f0:	89 c3                	mov    %eax,%ebx
c00254f2:	89 d6                	mov    %edx,%esi
  ASSERT (!intr_context ());
c00254f4:	e8 d6 c3 ff ff       	call   c00218cf <intr_context>
c00254f9:	84 c0                	test   %al,%al
c00254fb:	74 1e                	je     c002551b <wait+0x30>
c00254fd:	83 ec 0c             	sub    $0xc,%esp
c0025500:	68 2a d6 02 c0       	push   $0xc002d62a
c0025505:	68 3f d2 02 c0       	push   $0xc002d23f
c002550a:	68 c4 c4 02 c0       	push   $0xc002c4c4
c002550f:	6a 59                	push   $0x59
c0025511:	68 87 e7 02 c0       	push   $0xc002e787
c0025516:	e8 b2 27 00 00       	call   c0027ccd <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c002551b:	e8 33 c1 ff ff       	call   c0021653 <intr_get_level>
c0025520:	85 c0                	test   %eax,%eax
c0025522:	74 1e                	je     c0025542 <wait+0x57>
c0025524:	83 ec 0c             	sub    $0xc,%esp
c0025527:	68 94 d5 02 c0       	push   $0xc002d594
c002552c:	68 3f d2 02 c0       	push   $0xc002d23f
c0025531:	68 c4 c4 02 c0       	push   $0xc002c4c4
c0025536:	6a 5a                	push   $0x5a
c0025538:	68 87 e7 02 c0       	push   $0xc002e787
c002553d:	e8 8b 27 00 00       	call   c0027ccd <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0025542:	8d 43 24             	lea    0x24(%ebx),%eax
c0025545:	39 c6                	cmp    %eax,%esi
c0025547:	75 10                	jne    c0025559 <wait+0x6e>
c0025549:	83 ec 0c             	sub    $0xc,%esp
c002554c:	53                   	push   %ebx
c002554d:	e8 11 ff ff ff       	call   c0025463 <intq_empty>
c0025552:	83 c4 10             	add    $0x10,%esp
c0025555:	84 c0                	test   %al,%al
c0025557:	75 35                	jne    c002558e <wait+0xa3>
c0025559:	8d 43 20             	lea    0x20(%ebx),%eax
c002555c:	39 c6                	cmp    %eax,%esi
c002555e:	75 10                	jne    c0025570 <wait+0x85>
c0025560:	83 ec 0c             	sub    $0xc,%esp
c0025563:	53                   	push   %ebx
c0025564:	e8 37 ff ff ff       	call   c00254a0 <intq_full>
c0025569:	83 c4 10             	add    $0x10,%esp
c002556c:	84 c0                	test   %al,%al
c002556e:	75 1e                	jne    c002558e <wait+0xa3>
c0025570:	83 ec 0c             	sub    $0xc,%esp
c0025573:	68 9c e7 02 c0       	push   $0xc002e79c
c0025578:	68 3f d2 02 c0       	push   $0xc002d23f
c002557d:	68 c4 c4 02 c0       	push   $0xc002c4c4
c0025582:	6a 5c                	push   $0x5c
c0025584:	68 87 e7 02 c0       	push   $0xc002e787
c0025589:	e8 3f 27 00 00       	call   c0027ccd <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c002558e:	e8 47 b4 ff ff       	call   c00209da <thread_current>
c0025593:	89 06                	mov    %eax,(%esi)
  thread_block ();
c0025595:	e8 6c ba ff ff       	call   c0021006 <thread_block>
}
c002559a:	83 c4 04             	add    $0x4,%esp
c002559d:	5b                   	pop    %ebx
c002559e:	5e                   	pop    %esi
c002559f:	c3                   	ret    

c00255a0 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c00255a0:	56                   	push   %esi
c00255a1:	53                   	push   %ebx
c00255a2:	83 ec 04             	sub    $0x4,%esp
c00255a5:	89 c6                	mov    %eax,%esi
c00255a7:	89 d3                	mov    %edx,%ebx
  ASSERT (intr_get_level () == INTR_OFF);
c00255a9:	e8 a5 c0 ff ff       	call   c0021653 <intr_get_level>
c00255ae:	85 c0                	test   %eax,%eax
c00255b0:	74 1e                	je     c00255d0 <signal+0x30>
c00255b2:	83 ec 0c             	sub    $0xc,%esp
c00255b5:	68 94 d5 02 c0       	push   $0xc002d594
c00255ba:	68 3f d2 02 c0       	push   $0xc002d23f
c00255bf:	68 bc c4 02 c0       	push   $0xc002c4bc
c00255c4:	6a 69                	push   $0x69
c00255c6:	68 87 e7 02 c0       	push   $0xc002e787
c00255cb:	e8 fd 26 00 00       	call   c0027ccd <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c00255d0:	8d 46 24             	lea    0x24(%esi),%eax
c00255d3:	39 c3                	cmp    %eax,%ebx
c00255d5:	75 10                	jne    c00255e7 <signal+0x47>
c00255d7:	83 ec 0c             	sub    $0xc,%esp
c00255da:	56                   	push   %esi
c00255db:	e8 83 fe ff ff       	call   c0025463 <intq_empty>
c00255e0:	83 c4 10             	add    $0x10,%esp
c00255e3:	84 c0                	test   %al,%al
c00255e5:	74 35                	je     c002561c <signal+0x7c>
c00255e7:	8d 46 20             	lea    0x20(%esi),%eax
c00255ea:	39 c3                	cmp    %eax,%ebx
c00255ec:	75 10                	jne    c00255fe <signal+0x5e>
c00255ee:	83 ec 0c             	sub    $0xc,%esp
c00255f1:	56                   	push   %esi
c00255f2:	e8 a9 fe ff ff       	call   c00254a0 <intq_full>
c00255f7:	83 c4 10             	add    $0x10,%esp
c00255fa:	84 c0                	test   %al,%al
c00255fc:	74 1e                	je     c002561c <signal+0x7c>
c00255fe:	83 ec 0c             	sub    $0xc,%esp
c0025601:	68 f8 e7 02 c0       	push   $0xc002e7f8
c0025606:	68 3f d2 02 c0       	push   $0xc002d23f
c002560b:	68 bc c4 02 c0       	push   $0xc002c4bc
c0025610:	6a 6b                	push   $0x6b
c0025612:	68 87 e7 02 c0       	push   $0xc002e787
c0025617:	e8 b1 26 00 00       	call   c0027ccd <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c002561c:	8b 03                	mov    (%ebx),%eax
c002561e:	85 c0                	test   %eax,%eax
c0025620:	74 12                	je     c0025634 <signal+0x94>
    {
      thread_unblock (*waiter);
c0025622:	83 ec 0c             	sub    $0xc,%esp
c0025625:	50                   	push   %eax
c0025626:	e8 17 b3 ff ff       	call   c0020942 <thread_unblock>
      *waiter = NULL;
c002562b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
c0025631:	83 c4 10             	add    $0x10,%esp
    }
}
c0025634:	83 c4 04             	add    $0x4,%esp
c0025637:	5b                   	pop    %ebx
c0025638:	5e                   	pop    %esi
c0025639:	c3                   	ret    

c002563a <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c002563a:	56                   	push   %esi
c002563b:	53                   	push   %ebx
c002563c:	83 ec 04             	sub    $0x4,%esp
c002563f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c0025643:	e8 0b c0 ff ff       	call   c0021653 <intr_get_level>
c0025648:	85 c0                	test   %eax,%eax
c002564a:	74 64                	je     c00256b0 <intq_getc+0x76>
c002564c:	83 ec 0c             	sub    $0xc,%esp
c002564f:	68 94 d5 02 c0       	push   $0xc002d594
c0025654:	68 3f d2 02 c0       	push   $0xc002d23f
c0025659:	68 cc c4 02 c0       	push   $0xc002c4cc
c002565e:	6a 2a                	push   $0x2a
c0025660:	68 87 e7 02 c0       	push   $0xc002e787
c0025665:	e8 63 26 00 00       	call   c0027ccd <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c002566a:	e8 60 c2 ff ff       	call   c00218cf <intr_context>
c002566f:	84 c0                	test   %al,%al
c0025671:	74 1e                	je     c0025691 <intq_getc+0x57>
c0025673:	83 ec 0c             	sub    $0xc,%esp
c0025676:	68 2a d6 02 c0       	push   $0xc002d62a
c002567b:	68 3f d2 02 c0       	push   $0xc002d23f
c0025680:	68 cc c4 02 c0       	push   $0xc002c4cc
c0025685:	6a 2d                	push   $0x2d
c0025687:	68 87 e7 02 c0       	push   $0xc002e787
c002568c:	e8 3c 26 00 00       	call   c0027ccd <debug_panic>
      lock_acquire (&q->lock);
c0025691:	83 ec 0c             	sub    $0xc,%esp
c0025694:	53                   	push   %ebx
c0025695:	e8 25 d3 ff ff       	call   c00229bf <lock_acquire>
      wait (q, &q->not_empty);
c002569a:	89 f2                	mov    %esi,%edx
c002569c:	89 d8                	mov    %ebx,%eax
c002569e:	e8 48 fe ff ff       	call   c00254eb <wait>
      lock_release (&q->lock);
c00256a3:	89 1c 24             	mov    %ebx,(%esp)
c00256a6:	e8 a4 d4 ff ff       	call   c0022b4f <lock_release>
c00256ab:	83 c4 10             	add    $0x10,%esp
c00256ae:	eb 03                	jmp    c00256b3 <intq_getc+0x79>
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
      lock_acquire (&q->lock);
      wait (q, &q->not_empty);
c00256b0:	8d 73 24             	lea    0x24(%ebx),%esi
intq_getc (struct intq *q) 
{
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_empty (q)) 
c00256b3:	83 ec 0c             	sub    $0xc,%esp
c00256b6:	53                   	push   %ebx
c00256b7:	e8 a7 fd ff ff       	call   c0025463 <intq_empty>
c00256bc:	83 c4 10             	add    $0x10,%esp
c00256bf:	84 c0                	test   %al,%al
c00256c1:	75 a7                	jne    c002566a <intq_getc+0x30>
      lock_acquire (&q->lock);
      wait (q, &q->not_empty);
      lock_release (&q->lock);
    }
  
  byte = q->buf[q->tail];
c00256c3:	8b 43 6c             	mov    0x6c(%ebx),%eax
c00256c6:	0f b6 74 03 28       	movzbl 0x28(%ebx,%eax,1),%esi
  q->tail = next (q->tail);
c00256cb:	83 c0 01             	add    $0x1,%eax
c00256ce:	99                   	cltd   
c00256cf:	c1 ea 1a             	shr    $0x1a,%edx
c00256d2:	01 d0                	add    %edx,%eax
c00256d4:	83 e0 3f             	and    $0x3f,%eax
c00256d7:	29 d0                	sub    %edx,%eax
c00256d9:	89 43 6c             	mov    %eax,0x6c(%ebx)
  signal (q, &q->not_full);
c00256dc:	8d 53 20             	lea    0x20(%ebx),%edx
c00256df:	89 d8                	mov    %ebx,%eax
c00256e1:	e8 ba fe ff ff       	call   c00255a0 <signal>
  return byte;
}
c00256e6:	89 f0                	mov    %esi,%eax
c00256e8:	83 c4 04             	add    $0x4,%esp
c00256eb:	5b                   	pop    %ebx
c00256ec:	5e                   	pop    %esi
c00256ed:	c3                   	ret    

c00256ee <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c00256ee:	57                   	push   %edi
c00256ef:	56                   	push   %esi
c00256f0:	53                   	push   %ebx
c00256f1:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00256f5:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT (intr_get_level () == INTR_OFF);
c00256f9:	e8 55 bf ff ff       	call   c0021653 <intr_get_level>
c00256fe:	85 c0                	test   %eax,%eax
c0025700:	74 64                	je     c0025766 <intq_putc+0x78>
c0025702:	83 ec 0c             	sub    $0xc,%esp
c0025705:	68 94 d5 02 c0       	push   $0xc002d594
c002570a:	68 3f d2 02 c0       	push   $0xc002d23f
c002570f:	68 b0 c4 02 c0       	push   $0xc002c4b0
c0025714:	6a 3f                	push   $0x3f
c0025716:	68 87 e7 02 c0       	push   $0xc002e787
c002571b:	e8 ad 25 00 00       	call   c0027ccd <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c0025720:	e8 aa c1 ff ff       	call   c00218cf <intr_context>
c0025725:	84 c0                	test   %al,%al
c0025727:	74 1e                	je     c0025747 <intq_putc+0x59>
c0025729:	83 ec 0c             	sub    $0xc,%esp
c002572c:	68 2a d6 02 c0       	push   $0xc002d62a
c0025731:	68 3f d2 02 c0       	push   $0xc002d23f
c0025736:	68 b0 c4 02 c0       	push   $0xc002c4b0
c002573b:	6a 42                	push   $0x42
c002573d:	68 87 e7 02 c0       	push   $0xc002e787
c0025742:	e8 86 25 00 00       	call   c0027ccd <debug_panic>
      lock_acquire (&q->lock);
c0025747:	83 ec 0c             	sub    $0xc,%esp
c002574a:	53                   	push   %ebx
c002574b:	e8 6f d2 ff ff       	call   c00229bf <lock_acquire>
      wait (q, &q->not_full);
c0025750:	89 f2                	mov    %esi,%edx
c0025752:	89 d8                	mov    %ebx,%eax
c0025754:	e8 92 fd ff ff       	call   c00254eb <wait>
      lock_release (&q->lock);
c0025759:	89 1c 24             	mov    %ebx,(%esp)
c002575c:	e8 ee d3 ff ff       	call   c0022b4f <lock_release>
c0025761:	83 c4 10             	add    $0x10,%esp
c0025764:	eb 03                	jmp    c0025769 <intq_putc+0x7b>
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
      lock_acquire (&q->lock);
      wait (q, &q->not_full);
c0025766:	8d 73 20             	lea    0x20(%ebx),%esi
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_full (q))
c0025769:	83 ec 0c             	sub    $0xc,%esp
c002576c:	53                   	push   %ebx
c002576d:	e8 2e fd ff ff       	call   c00254a0 <intq_full>
c0025772:	83 c4 10             	add    $0x10,%esp
c0025775:	84 c0                	test   %al,%al
c0025777:	75 a7                	jne    c0025720 <intq_putc+0x32>
      lock_acquire (&q->lock);
      wait (q, &q->not_full);
      lock_release (&q->lock);
    }

  q->buf[q->head] = byte;
c0025779:	8b 43 68             	mov    0x68(%ebx),%eax
c002577c:	89 f9                	mov    %edi,%ecx
c002577e:	88 4c 03 28          	mov    %cl,0x28(%ebx,%eax,1)
  q->head = next (q->head);
c0025782:	83 c0 01             	add    $0x1,%eax
c0025785:	99                   	cltd   
c0025786:	c1 ea 1a             	shr    $0x1a,%edx
c0025789:	01 d0                	add    %edx,%eax
c002578b:	83 e0 3f             	and    $0x3f,%eax
c002578e:	29 d0                	sub    %edx,%eax
c0025790:	89 43 68             	mov    %eax,0x68(%ebx)
  signal (q, &q->not_empty);
c0025793:	8d 53 24             	lea    0x24(%ebx),%edx
c0025796:	89 d8                	mov    %ebx,%eax
c0025798:	e8 03 fe ff ff       	call   c00255a0 <signal>
}
c002579d:	5b                   	pop    %ebx
c002579e:	5e                   	pop    %esi
c002579f:	5f                   	pop    %edi
c00257a0:	c3                   	ret    

c00257a1 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c00257a1:	55                   	push   %ebp
c00257a2:	57                   	push   %edi
c00257a3:	56                   	push   %esi
c00257a4:	53                   	push   %ebx
c00257a5:	83 ec 24             	sub    $0x24,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257a8:	be 00 00 00 00       	mov    $0x0,%esi
c00257ad:	bf 02 00 00 00       	mov    $0x2,%edi
c00257b2:	89 f0                	mov    %esi,%eax
c00257b4:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00257b6:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c00257b8:	89 c2                	mov    %eax,%edx
c00257ba:	c0 ea 04             	shr    $0x4,%dl
c00257bd:	0f b6 d2             	movzbl %dl,%edx
c00257c0:	8d 14 92             	lea    (%edx,%edx,4),%edx
c00257c3:	83 e0 0f             	and    $0xf,%eax
c00257c6:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257c9:	89 f8                	mov    %edi,%eax
c00257cb:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00257cd:	e4 71                	in     $0x71,%al
c00257cf:	88 44 24 10          	mov    %al,0x10(%esp)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257d3:	b8 04 00 00 00       	mov    $0x4,%eax
c00257d8:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00257da:	e4 71                	in     $0x71,%al
c00257dc:	88 04 24             	mov    %al,(%esp)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257df:	b8 07 00 00 00       	mov    $0x7,%eax
c00257e4:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00257e6:	e4 71                	in     $0x71,%al
c00257e8:	88 44 24 23          	mov    %al,0x23(%esp)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257ec:	b8 08 00 00 00       	mov    $0x8,%eax
c00257f1:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00257f3:	e4 71                	in     $0x71,%al
c00257f5:	88 44 24 22          	mov    %al,0x22(%esp)
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00257f9:	b8 09 00 00 00       	mov    $0x9,%eax
c00257fe:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025800:	e4 71                	in     $0x71,%al
c0025802:	89 c1                	mov    %eax,%ecx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025804:	89 f0                	mov    %esi,%eax
c0025806:	e6 70                	out    %al,$0x70
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025808:	e4 71                	in     $0x71,%al
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c002580a:	89 c2                	mov    %eax,%edx
c002580c:	c0 ea 04             	shr    $0x4,%dl
c002580f:	0f b6 ea             	movzbl %dl,%ebp
c0025812:	8d 6c ad 00          	lea    0x0(%ebp,%ebp,4),%ebp
c0025816:	83 e0 0f             	and    $0xf,%eax
c0025819:	8d 04 68             	lea    (%eax,%ebp,2),%eax
c002581c:	39 d8                	cmp    %ebx,%eax
c002581e:	75 92                	jne    c00257b2 <rtc_get_time+0x11>

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c0025820:	89 c8                	mov    %ecx,%eax
c0025822:	c0 e8 04             	shr    $0x4,%al
c0025825:	0f b6 c0             	movzbl %al,%eax
c0025828:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002582b:	83 e1 0f             	and    $0xf,%ecx
c002582e:	8d 04 41             	lea    (%ecx,%eax,2),%eax
  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
    year += 100;
c0025831:	8d 48 64             	lea    0x64(%eax),%ecx
c0025834:	83 f8 45             	cmp    $0x45,%eax
c0025837:	0f 4e c1             	cmovle %ecx,%eax

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c002583a:	0f b6 54 24 22       	movzbl 0x22(%esp),%edx
c002583f:	89 d1                	mov    %edx,%ecx
c0025841:	c0 e9 04             	shr    $0x4,%cl
c0025844:	0f b6 c9             	movzbl %cl,%ecx
c0025847:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c002584a:	83 e2 0f             	and    $0xf,%edx
c002584d:	8d 34 4a             	lea    (%edx,%ecx,2),%esi
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
    year += 100;
  year -= 70;
c0025850:	8d 78 ba             	lea    -0x46(%eax),%edi

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0025853:	8d 50 bc             	lea    -0x44(%eax),%edx
c0025856:	83 e8 47             	sub    $0x47,%eax
c0025859:	0f 48 c2             	cmovs  %edx,%eax
c002585c:	c1 f8 02             	sar    $0x2,%eax
c002585f:	69 cf 6d 01 00 00    	imul   $0x16d,%edi,%ecx
c0025865:	01 c1                	add    %eax,%ecx
c0025867:	69 c9 80 51 01 00    	imul   $0x15180,%ecx,%ecx
  for (i = 1; i <= mon; i++)
c002586d:	85 f6                	test   %esi,%esi
c002586f:	7e 19                	jle    c002588a <rtc_get_time+0xe9>
c0025871:	ba 01 00 00 00       	mov    $0x1,%edx
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0025876:	69 04 95 fc c4 02 c0 	imul   $0x15180,-0x3ffd3b04(,%edx,4),%eax
c002587d:	80 51 01 00 
c0025881:	01 c1                	add    %eax,%ecx
    year += 100;
  year -= 70;

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
  for (i = 1; i <= mon; i++)
c0025883:	83 c2 01             	add    $0x1,%edx
c0025886:	39 f2                	cmp    %esi,%edx
c0025888:	7e ec                	jle    c0025876 <rtc_get_time+0xd5>
    time += days_per_month[i - 1] * 24 * 60 * 60;
  if (mon > 2 && year % 4 == 0)
c002588a:	83 fe 02             	cmp    $0x2,%esi
c002588d:	7e 0e                	jle    c002589d <rtc_get_time+0xfc>
c002588f:	83 e7 03             	and    $0x3,%edi
    time += 24 * 60 * 60;
c0025892:	8d 81 80 51 01 00    	lea    0x15180(%ecx),%eax
c0025898:	85 ff                	test   %edi,%edi
c002589a:	0f 44 c8             	cmove  %eax,%ecx
  time += (mday - 1) * 24 * 60 * 60;
  time += hour * 60 * 60;
  time += min * 60;
  time += sec;

  return time;
c002589d:	0f b6 04 24          	movzbl (%esp),%eax
c00258a1:	c0 e8 04             	shr    $0x4,%al
c00258a4:	0f b6 c0             	movzbl %al,%eax
c00258a7:	8d 14 80             	lea    (%eax,%eax,4),%edx
c00258aa:	8b 04 24             	mov    (%esp),%eax
c00258ad:	83 e0 0f             	and    $0xf,%eax
c00258b0:	8d 04 50             	lea    (%eax,%edx,2),%eax
c00258b3:	69 d0 10 0e 00 00    	imul   $0xe10,%eax,%edx
c00258b9:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c00258be:	c0 e8 04             	shr    $0x4,%al
c00258c1:	0f b6 c0             	movzbl %al,%eax
c00258c4:	8d 34 80             	lea    (%eax,%eax,4),%esi
c00258c7:	8b 44 24 10          	mov    0x10(%esp),%eax
c00258cb:	83 e0 0f             	and    $0xf,%eax
c00258ce:	8d 04 70             	lea    (%eax,%esi,2),%eax
c00258d1:	6b c0 3c             	imul   $0x3c,%eax,%eax
c00258d4:	01 d0                	add    %edx,%eax
c00258d6:	01 c3                	add    %eax,%ebx
c00258d8:	0f b6 54 24 23       	movzbl 0x23(%esp),%edx
c00258dd:	89 d0                	mov    %edx,%eax
c00258df:	c0 e8 04             	shr    $0x4,%al
c00258e2:	0f b6 c0             	movzbl %al,%eax
c00258e5:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00258e8:	83 e2 0f             	and    $0xf,%edx
c00258eb:	8d 44 42 ff          	lea    -0x1(%edx,%eax,2),%eax
c00258ef:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c00258f5:	01 c3                	add    %eax,%ebx
c00258f7:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
}
c00258fa:	83 c4 24             	add    $0x24,%esp
c00258fd:	5b                   	pop    %ebx
c00258fe:	5e                   	pop    %esi
c00258ff:	5f                   	pop    %edi
c0025900:	5d                   	pop    %ebp
c0025901:	c3                   	ret    

c0025902 <shutdown_configure>:
/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
  how = type;
c0025902:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025906:	a3 b0 94 03 c0       	mov    %eax,0xc00394b0
c002590b:	c3                   	ret    

c002590c <shutdown_reboot>:
}

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c002590c:	56                   	push   %esi
c002590d:	53                   	push   %ebx
c002590e:	83 ec 10             	sub    $0x10,%esp
  printf ("Rebooting...\n");
c0025911:	68 53 e8 02 c0       	push   $0xc002e853
c0025916:	e8 e9 3d 00 00       	call   c0029704 <puts>
c002591b:	83 c4 10             	add    $0x10,%esp
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002591e:	be fe ff ff ff       	mov    $0xfffffffe,%esi
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025923:	e4 64                	in     $0x64,%al

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0025925:	a8 02                	test   $0x2,%al
c0025927:	75 3d                	jne    c0025966 <shutdown_reboot+0x5a>
c0025929:	eb 1a                	jmp    c0025945 <shutdown_reboot+0x39>
c002592b:	e4 64                	in     $0x64,%al
c002592d:	a8 02                	test   $0x2,%al
c002592f:	74 14                	je     c0025945 <shutdown_reboot+0x39>
            break;
          timer_udelay (2);
c0025931:	83 ec 08             	sub    $0x8,%esp
c0025934:	6a 00                	push   $0x0
c0025936:	6a 02                	push   $0x2
c0025938:	e8 b0 e2 ff ff       	call   c0023bed <timer_udelay>
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c002593d:	83 c4 10             	add    $0x10,%esp
c0025940:	83 eb 01             	sub    $0x1,%ebx
c0025943:	75 e6                	jne    c002592b <shutdown_reboot+0x1f>
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
        }

      timer_udelay (50);
c0025945:	83 ec 08             	sub    $0x8,%esp
c0025948:	6a 00                	push   $0x0
c002594a:	6a 32                	push   $0x32
c002594c:	e8 9c e2 ff ff       	call   c0023bed <timer_udelay>
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025951:	89 f0                	mov    %esi,%eax
c0025953:	e6 64                	out    %al,$0x64

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
      timer_udelay (50);
c0025955:	83 c4 08             	add    $0x8,%esp
c0025958:	6a 00                	push   $0x0
c002595a:	6a 32                	push   $0x32
c002595c:	e8 8c e2 ff ff       	call   c0023bed <timer_udelay>
    }
c0025961:	83 c4 10             	add    $0x10,%esp
c0025964:	eb bd                	jmp    c0025923 <shutdown_reboot+0x17>
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
          timer_udelay (2);
c0025966:	83 ec 08             	sub    $0x8,%esp
c0025969:	6a 00                	push   $0x0
c002596b:	6a 02                	push   $0x2
c002596d:	e8 7b e2 ff ff       	call   c0023bed <timer_udelay>
c0025972:	83 c4 10             	add    $0x10,%esp
c0025975:	bb ff ff 00 00       	mov    $0xffff,%ebx
c002597a:	eb af                	jmp    c002592b <shutdown_reboot+0x1f>

c002597c <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c002597c:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c002597f:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0025986:	74 
c0025987:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c002598e:	6e 
c002598f:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
  timer_print_stats ();
c0025994:	e8 86 e2 ff ff       	call   c0023c1f <timer_print_stats>
  thread_print_stats ();
c0025999:	e8 77 af ff ff       	call   c0020915 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c002599e:	e8 10 3d 00 00       	call   c00296b3 <console_print_stats>
  kbd_print_stats ();
c00259a3:	e8 c6 e4 ff ff       	call   c0023e6e <kbd_print_stats>
  filesys_done ();
#endif

  print_stats ();

  printf ("Powering off...\n");
c00259a8:	83 ec 0c             	sub    $0xc,%esp
c00259ab:	68 60 e8 02 c0       	push   $0xc002e860
c00259b0:	e8 4f 3d 00 00       	call   c0029704 <puts>
  serial_flush ();
c00259b5:	e8 a6 e9 ff ff       	call   c0024360 <serial_flush>
/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00259ba:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c00259bf:	b8 00 20 00 00       	mov    $0x2000,%eax
c00259c4:	66 ef                	out    %ax,(%dx)
  /* ACPI power-off */
  outw (0xB004, 0x2000);

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c00259c6:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c00259cb:	83 c4 10             	add    $0x10,%esp
c00259ce:	84 c0                	test   %al,%al
c00259d0:	74 14                	je     c00259e6 <shutdown_power_off+0x6a>
c00259d2:	8d 4c 24 07          	lea    0x7(%esp),%ecx
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00259d6:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c00259db:	ee                   	out    %al,(%dx)
c00259dc:	83 c1 01             	add    $0x1,%ecx
c00259df:	0f b6 01             	movzbl (%ecx),%eax
c00259e2:	84 c0                	test   %al,%al
c00259e4:	75 f5                	jne    c00259db <shutdown_power_off+0x5f>
c00259e6:	ba 01 05 00 00       	mov    $0x501,%edx
c00259eb:	b8 31 00 00 00       	mov    $0x31,%eax
c00259f0:	ee                   	out    %al,(%dx)
  outb (0x501, 0x31);

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c00259f1:	fa                   	cli    
c00259f2:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c00259f3:	83 ec 0c             	sub    $0xc,%esp
c00259f6:	68 70 e8 02 c0       	push   $0xc002e870
c00259fb:	e8 04 3d 00 00       	call   c0029704 <puts>
c0025a00:	83 c4 10             	add    $0x10,%esp
c0025a03:	eb fe                	jmp    c0025a03 <shutdown_power_off+0x87>

c0025a05 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0025a05:	83 ec 0c             	sub    $0xc,%esp
  switch (how)
c0025a08:	a1 b0 94 03 c0       	mov    0xc00394b0,%eax
c0025a0d:	83 f8 01             	cmp    $0x1,%eax
c0025a10:	74 07                	je     c0025a19 <shutdown+0x14>
c0025a12:	83 f8 02             	cmp    $0x2,%eax
c0025a15:	74 07                	je     c0025a1e <shutdown+0x19>
c0025a17:	eb 0a                	jmp    c0025a23 <shutdown+0x1e>
    {
    case SHUTDOWN_POWER_OFF:
      shutdown_power_off ();
c0025a19:	e8 5e ff ff ff       	call   c002597c <shutdown_power_off>
      break;

    case SHUTDOWN_REBOOT:
      shutdown_reboot ();
c0025a1e:	e8 e9 fe ff ff       	call   c002590c <shutdown_reboot>

    default:
      /* Nothing to do. */
      break;
    }
}
c0025a23:	83 c4 0c             	add    $0xc,%esp
c0025a26:	c3                   	ret    

c0025a27 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0025a27:	83 ec 0c             	sub    $0xc,%esp
  enum intr_level old_level = intr_disable ();
c0025a2a:	e8 61 bc ff ff       	call   c0021690 <intr_disable>
c0025a2f:	89 c2                	mov    %eax,%edx
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a31:	e4 61                	in     $0x61,%al
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025a33:	83 e0 fc             	and    $0xfffffffc,%eax
c0025a36:	e6 61                	out    %al,$0x61
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level (old_level);
c0025a38:	83 ec 0c             	sub    $0xc,%esp
c0025a3b:	52                   	push   %edx
c0025a3c:	e8 56 bc ff ff       	call   c0021697 <intr_set_level>
}
c0025a41:	83 c4 1c             	add    $0x1c,%esp
c0025a44:	c3                   	ret    

c0025a45 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0025a45:	56                   	push   %esi
c0025a46:	53                   	push   %ebx
c0025a47:	83 ec 04             	sub    $0x4,%esp
c0025a4a:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (frequency >= 20 && frequency <= 20000)
c0025a4e:	8d 43 ec             	lea    -0x14(%ebx),%eax
c0025a51:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c0025a56:	77 28                	ja     c0025a80 <speaker_on+0x3b>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0025a58:	e8 33 bc ff ff       	call   c0021690 <intr_disable>
c0025a5d:	89 c6                	mov    %eax,%esi
      pit_configure_channel (2, 3, frequency);
c0025a5f:	83 ec 04             	sub    $0x4,%esp
c0025a62:	53                   	push   %ebx
c0025a63:	6a 03                	push   $0x3
c0025a65:	6a 02                	push   $0x2
c0025a67:	e8 f3 dc ff ff       	call   c002375f <pit_configure_channel>
static inline uint8_t
inb (uint16_t port)
{
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025a6c:	e4 61                	in     $0x61,%al
/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025a6e:	83 c8 03             	or     $0x3,%eax
c0025a71:	e6 61                	out    %al,$0x61
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
      intr_set_level (old_level);
c0025a73:	89 34 24             	mov    %esi,(%esp)
c0025a76:	e8 1c bc ff ff       	call   c0021697 <intr_set_level>
c0025a7b:	83 c4 10             	add    $0x10,%esp
c0025a7e:	eb 05                	jmp    c0025a85 <speaker_on+0x40>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0025a80:	e8 a2 ff ff ff       	call   c0025a27 <speaker_off>
    }
}
c0025a85:	83 c4 04             	add    $0x4,%esp
c0025a88:	5b                   	pop    %ebx
c0025a89:	5e                   	pop    %esi
c0025a8a:	c3                   	ret    

c0025a8b <speaker_beep>:
}

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0025a8b:	83 ec 0c             	sub    $0xc,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0025a8e:	e8 c0 bb ff ff       	call   c0021653 <intr_get_level>
c0025a93:	83 f8 01             	cmp    $0x1,%eax
c0025a96:	75 24                	jne    c0025abc <speaker_beep+0x31>
    {
      speaker_on (440);
c0025a98:	83 ec 0c             	sub    $0xc,%esp
c0025a9b:	68 b8 01 00 00       	push   $0x1b8
c0025aa0:	e8 a0 ff ff ff       	call   c0025a45 <speaker_on>
      timer_msleep (250);
c0025aa5:	83 c4 08             	add    $0x8,%esp
c0025aa8:	6a 00                	push   $0x0
c0025aaa:	68 fa 00 00 00       	push   $0xfa
c0025aaf:	e8 d5 e0 ff ff       	call   c0023b89 <timer_msleep>
      speaker_off ();
c0025ab4:	e8 6e ff ff ff       	call   c0025a27 <speaker_off>
c0025ab9:	83 c4 10             	add    $0x10,%esp
    }
}
c0025abc:	83 c4 0c             	add    $0xc,%esp
c0025abf:	c3                   	ret    

c0025ac0 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0025ac0:	55                   	push   %ebp
c0025ac1:	89 e5                	mov    %esp,%ebp
c0025ac3:	53                   	push   %ebx
c0025ac4:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0025ac7:	ff 75 04             	pushl  0x4(%ebp)
c0025aca:	68 81 e8 02 c0       	push   $0xc002e881
c0025acf:	e8 81 05 00 00       	call   c0026055 <printf>
  for (frame = __builtin_frame_address (1);
c0025ad4:	8b 5d 00             	mov    0x0(%ebp),%ebx
c0025ad7:	83 c4 10             	add    $0x10,%esp
c0025ada:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0025ae0:	76 27                	jbe    c0025b09 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0025ae2:	83 3b 00             	cmpl   $0x0,(%ebx)
c0025ae5:	74 22                	je     c0025b09 <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0025ae7:	83 ec 08             	sub    $0x8,%esp
c0025aea:	ff 73 04             	pushl  0x4(%ebx)
c0025aed:	68 8c e8 02 c0       	push   $0xc002e88c
c0025af2:	e8 5e 05 00 00       	call   c0026055 <printf>
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
c0025af7:	8b 1b                	mov    (%ebx),%ebx
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
c0025af9:	83 c4 10             	add    $0x10,%esp
c0025afc:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0025b02:	76 05                	jbe    c0025b09 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0025b04:	83 3b 00             	cmpl   $0x0,(%ebx)
c0025b07:	75 de                	jne    c0025ae7 <debug_backtrace+0x27>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
c0025b09:	83 ec 0c             	sub    $0xc,%esp
c0025b0c:	68 23 e4 02 c0       	push   $0xc002e423
c0025b11:	e8 ee 3b 00 00       	call   c0029704 <puts>

  if (!explained) 
c0025b16:	83 c4 10             	add    $0x10,%esp
c0025b19:	80 3d b4 94 03 c0 00 	cmpb   $0x0,0xc00394b4
c0025b20:	75 17                	jne    c0025b39 <debug_backtrace+0x79>
    {
      explained = true;
c0025b22:	c6 05 b4 94 03 c0 01 	movb   $0x1,0xc00394b4
      printf ("The `backtrace' program can make call stacks useful.\n"
c0025b29:	83 ec 0c             	sub    $0xc,%esp
c0025b2c:	68 90 e8 02 c0       	push   $0xc002e890
c0025b31:	e8 ce 3b 00 00       	call   c0029704 <puts>
c0025b36:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0025b39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025b3c:	c9                   	leave  
c0025b3d:	c3                   	ret    

c0025b3e <random_init>:
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0025b3e:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c0025b43:	88 80 e0 94 03 c0    	mov    %al,-0x3ffc6b20(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0025b49:	83 c0 01             	add    $0x1,%eax
c0025b4c:	3d 00 01 00 00       	cmp    $0x100,%eax
c0025b51:	75 f0                	jne    c0025b43 <random_init+0x5>
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0025b53:	56                   	push   %esi
c0025b54:	53                   	push   %ebx
c0025b55:	be 00 00 00 00       	mov    $0x0,%esi
c0025b5a:	b8 00 00 00 00       	mov    $0x0,%eax

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
c0025b5f:	89 c1                	mov    %eax,%ecx
c0025b61:	83 e1 03             	and    $0x3,%ecx
c0025b64:	0f b6 98 e0 94 03 c0 	movzbl -0x3ffc6b20(%eax),%ebx
c0025b6b:	89 da                	mov    %ebx,%edx
c0025b6d:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
c0025b71:	89 d1                	mov    %edx,%ecx
c0025b73:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
c0025b75:	89 f2                	mov    %esi,%edx
c0025b77:	0f b6 ca             	movzbl %dl,%ecx
/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
  *a = *b;
c0025b7a:	0f b6 91 e0 94 03 c0 	movzbl -0x3ffc6b20(%ecx),%edx
c0025b81:	88 90 e0 94 03 c0    	mov    %dl,-0x3ffc6b20(%eax)
  *b = t;
c0025b87:	88 99 e0 94 03 c0    	mov    %bl,-0x3ffc6b20(%ecx)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c0025b8d:	83 c0 01             	add    $0x1,%eax
c0025b90:	3d 00 01 00 00       	cmp    $0x100,%eax
c0025b95:	75 c8                	jne    c0025b5f <random_init+0x21>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
c0025b97:	c6 05 c1 94 03 c0 00 	movb   $0x0,0xc00394c1
c0025b9e:	c6 05 c2 94 03 c0 00 	movb   $0x0,0xc00394c2
  inited = true;
c0025ba5:	c6 05 c0 94 03 c0 01 	movb   $0x1,0xc00394c0
}
c0025bac:	5b                   	pop    %ebx
c0025bad:	5e                   	pop    %esi
c0025bae:	c3                   	ret    

c0025baf <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0025baf:	55                   	push   %ebp
c0025bb0:	57                   	push   %edi
c0025bb1:	56                   	push   %esi
c0025bb2:	53                   	push   %ebx
c0025bb3:	83 ec 08             	sub    $0x8,%esp
c0025bb6:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
c0025bba:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  uint8_t *buf;

  if (!inited)
c0025bbe:	80 3d c0 94 03 c0 00 	cmpb   $0x0,0xc00394c0
c0025bc5:	75 0a                	jne    c0025bd1 <random_bytes+0x22>
    random_init (0);
c0025bc7:	6a 00                	push   $0x0
c0025bc9:	e8 70 ff ff ff       	call   c0025b3e <random_init>
c0025bce:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0025bd1:	8d 45 ff             	lea    -0x1(%ebp),%eax
c0025bd4:	89 04 24             	mov    %eax,(%esp)
c0025bd7:	85 ed                	test   %ebp,%ebp
c0025bd9:	0f 84 82 00 00 00    	je     c0025c61 <random_bytes+0xb2>
c0025bdf:	0f b6 05 c2 94 03 c0 	movzbl 0xc00394c2,%eax
c0025be6:	88 44 24 07          	mov    %al,0x7(%esp)
c0025bea:	0f b6 35 c1 94 03 c0 	movzbl 0xc00394c1,%esi
c0025bf1:	01 dd                	add    %ebx,%ebp
c0025bf3:	88 44 24 06          	mov    %al,0x6(%esp)
    {
      uint8_t s_k;
      
      s_i++;
c0025bf7:	80 44 24 06 01       	addb   $0x1,0x6(%esp)
c0025bfc:	0f b6 44 24 06       	movzbl 0x6(%esp),%eax
      s_j += s[s_i];
c0025c01:	0f b6 d0             	movzbl %al,%edx
c0025c04:	89 f0                	mov    %esi,%eax
c0025c06:	02 82 e0 94 03 c0    	add    -0x3ffc6b20(%edx),%al
c0025c0c:	89 c6                	mov    %eax,%esi
      swap_byte (s + s_i, s + s_j);
c0025c0e:	0f b6 c0             	movzbl %al,%eax

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
c0025c11:	0f b6 ba e0 94 03 c0 	movzbl -0x3ffc6b20(%edx),%edi
  *a = *b;
c0025c18:	0f b6 88 e0 94 03 c0 	movzbl -0x3ffc6b20(%eax),%ecx
c0025c1f:	88 8a e0 94 03 c0    	mov    %cl,-0x3ffc6b20(%edx)
  *b = t;
c0025c25:	89 f9                	mov    %edi,%ecx
c0025c27:	88 88 e0 94 03 c0    	mov    %cl,-0x3ffc6b20(%eax)
      s_i++;
      s_j += s[s_i];
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
c0025c2d:	89 f8                	mov    %edi,%eax
c0025c2f:	02 82 e0 94 03 c0    	add    -0x3ffc6b20(%edx),%al
c0025c35:	0f b6 c0             	movzbl %al,%eax
c0025c38:	0f b6 80 e0 94 03 c0 	movzbl -0x3ffc6b20(%eax),%eax
c0025c3f:	88 03                	mov    %al,(%ebx)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c0025c41:	83 c3 01             	add    $0x1,%ebx
c0025c44:	39 dd                	cmp    %ebx,%ebp
c0025c46:	75 af                	jne    c0025bf7 <random_bytes+0x48>
c0025c48:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c0025c4d:	0f b6 3c 24          	movzbl (%esp),%edi
c0025c51:	8d 44 38 01          	lea    0x1(%eax,%edi,1),%eax
c0025c55:	a2 c2 94 03 c0       	mov    %al,0xc00394c2
c0025c5a:	89 f0                	mov    %esi,%eax
c0025c5c:	a2 c1 94 03 c0       	mov    %al,0xc00394c1
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
c0025c61:	83 c4 08             	add    $0x8,%esp
c0025c64:	5b                   	pop    %ebx
c0025c65:	5e                   	pop    %esi
c0025c66:	5f                   	pop    %edi
c0025c67:	5d                   	pop    %ebp
c0025c68:	c3                   	ret    

c0025c69 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0025c69:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0025c6c:	6a 04                	push   $0x4
c0025c6e:	8d 44 24 10          	lea    0x10(%esp),%eax
c0025c72:	50                   	push   %eax
c0025c73:	e8 37 ff ff ff       	call   c0025baf <random_bytes>
  return ul;
}
c0025c78:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025c7c:	83 c4 18             	add    $0x18,%esp
c0025c7f:	c3                   	ret    

c0025c80 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0025c80:	53                   	push   %ebx
c0025c81:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0025c85:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c0025c89:	8b 50 04             	mov    0x4(%eax),%edx
c0025c8c:	8d 4a 01             	lea    0x1(%edx),%ecx
c0025c8f:	89 48 04             	mov    %ecx,0x4(%eax)
c0025c92:	3b 50 08             	cmp    0x8(%eax),%edx
c0025c95:	7d 09                	jge    c0025ca0 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c0025c97:	8b 10                	mov    (%eax),%edx
c0025c99:	8d 4a 01             	lea    0x1(%edx),%ecx
c0025c9c:	89 08                	mov    %ecx,(%eax)
c0025c9e:	88 1a                	mov    %bl,(%edx)
}
c0025ca0:	5b                   	pop    %ebx
c0025ca1:	c3                   	ret    

c0025ca2 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0025ca2:	55                   	push   %ebp
c0025ca3:	57                   	push   %edi
c0025ca4:	56                   	push   %esi
c0025ca5:	53                   	push   %ebx
c0025ca6:	83 ec 0c             	sub    $0xc,%esp
c0025ca9:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0025cad:	85 d2                	test   %edx,%edx
c0025caf:	74 16                	je     c0025cc7 <output_dup+0x25>
c0025cb1:	89 cd                	mov    %ecx,%ebp
c0025cb3:	89 d3                	mov    %edx,%ebx
    output (ch, aux);
c0025cb5:	0f be f0             	movsbl %al,%esi
c0025cb8:	83 ec 08             	sub    $0x8,%esp
c0025cbb:	57                   	push   %edi
c0025cbc:	56                   	push   %esi
c0025cbd:	ff d5                	call   *%ebp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
c0025cbf:	83 c4 10             	add    $0x10,%esp
c0025cc2:	83 eb 01             	sub    $0x1,%ebx
c0025cc5:	75 f1                	jne    c0025cb8 <output_dup+0x16>
    output (ch, aux);
}
c0025cc7:	83 c4 0c             	add    $0xc,%esp
c0025cca:	5b                   	pop    %ebx
c0025ccb:	5e                   	pop    %esi
c0025ccc:	5f                   	pop    %edi
c0025ccd:	5d                   	pop    %ebp
c0025cce:	c3                   	ret    

c0025ccf <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0025ccf:	55                   	push   %ebp
c0025cd0:	57                   	push   %edi
c0025cd1:	56                   	push   %esi
c0025cd2:	53                   	push   %ebx
c0025cd3:	83 ec 7c             	sub    $0x7c,%esp
c0025cd6:	89 c6                	mov    %eax,%esi
c0025cd8:	89 d7                	mov    %edx,%edi
c0025cda:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0025ce1:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0025ce8:	00 
  if (is_signed) 
c0025ce9:	84 c9                	test   %cl,%cl
c0025ceb:	74 40                	je     c0025d2d <format_integer+0x5e>
    {
      if (c->flags & PLUS)
c0025ced:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
c0025cf4:	8b 12                	mov    (%edx),%edx
c0025cf6:	f6 c2 02             	test   $0x2,%dl
c0025cf9:	74 10                	je     c0025d0b <format_integer+0x3c>
        sign = negative ? '-' : '+';
c0025cfb:	3c 01                	cmp    $0x1,%al
c0025cfd:	19 c0                	sbb    %eax,%eax
c0025cff:	83 e0 fe             	and    $0xfffffffe,%eax
c0025d02:	83 c0 2d             	add    $0x2d,%eax
c0025d05:	89 44 24 20          	mov    %eax,0x20(%esp)
c0025d09:	eb 22                	jmp    c0025d2d <format_integer+0x5e>
      else if (c->flags & SPACE)
c0025d0b:	f6 c2 04             	test   $0x4,%dl
c0025d0e:	74 10                	je     c0025d20 <format_integer+0x51>
        sign = negative ? '-' : ' ';
c0025d10:	3c 01                	cmp    $0x1,%al
c0025d12:	19 c0                	sbb    %eax,%eax
c0025d14:	83 e0 f3             	and    $0xfffffff3,%eax
c0025d17:	83 c0 2d             	add    $0x2d,%eax
c0025d1a:	89 44 24 20          	mov    %eax,0x20(%esp)
c0025d1e:	eb 0d                	jmp    c0025d2d <format_integer+0x5e>
      else if (negative)
        sign = '-';
c0025d20:	3c 01                	cmp    $0x1,%al
c0025d22:	19 c0                	sbb    %eax,%eax
c0025d24:	f7 d0                	not    %eax
c0025d26:	83 e0 2d             	and    $0x2d,%eax
c0025d29:	89 44 24 20          	mov    %eax,0x20(%esp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0025d2d:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0025d34:	8b 00                	mov    (%eax),%eax
c0025d36:	89 44 24 28          	mov    %eax,0x28(%esp)
c0025d3a:	83 e0 08             	and    $0x8,%eax
c0025d3d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0025d41:	89 f2                	mov    %esi,%edx
c0025d43:	09 fa                	or     %edi,%edx
c0025d45:	74 14                	je     c0025d5b <format_integer+0x8c>
c0025d47:	85 c0                	test   %eax,%eax
c0025d49:	74 10                	je     c0025d5b <format_integer+0x8c>
c0025d4b:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0025d52:	8b 40 08             	mov    0x8(%eax),%eax
c0025d55:	89 44 24 24          	mov    %eax,0x24(%esp)
c0025d59:	eb 08                	jmp    c0025d63 <format_integer+0x94>
c0025d5b:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0025d62:	00 
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
c0025d63:	89 f8                	mov    %edi,%eax
c0025d65:	09 f0                	or     %esi,%eax
c0025d67:	0f 84 ad 00 00 00    	je     c0025e1a <format_integer+0x14b>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
c0025d6d:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0025d74:	8b 40 04             	mov    0x4(%eax),%eax
c0025d77:	89 44 24 18          	mov    %eax,0x18(%esp)
c0025d7b:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0025d82:	8b 00                	mov    (%eax),%eax
c0025d84:	89 44 24 08          	mov    %eax,0x8(%esp)
c0025d88:	99                   	cltd   
c0025d89:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0025d8d:	bb 00 00 00 00       	mov    $0x0,%ebx
c0025d92:	8d 6c 24 30          	lea    0x30(%esp),%ebp
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0025d96:	8b 44 24 28          	mov    0x28(%esp),%eax
c0025d9a:	c1 e8 05             	shr    $0x5,%eax
c0025d9d:	83 e0 01             	and    $0x1,%eax
c0025da0:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0025da4:	eb 2b                	jmp    c0025dd1 <format_integer+0x102>
c0025da6:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0025dab:	74 20                	je     c0025dcd <format_integer+0xfe>
c0025dad:	85 db                	test   %ebx,%ebx
c0025daf:	7e 1c                	jle    c0025dcd <format_integer+0xfe>
c0025db1:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c0025db8:	89 d8                	mov    %ebx,%eax
c0025dba:	99                   	cltd   
c0025dbb:	f7 79 0c             	idivl  0xc(%ecx)
c0025dbe:	85 d2                	test   %edx,%edx
c0025dc0:	75 0b                	jne    c0025dcd <format_integer+0xfe>
        *cp++ = ',';
c0025dc2:	8d 45 02             	lea    0x2(%ebp),%eax
c0025dc5:	89 44 24 14          	mov    %eax,0x14(%esp)
c0025dc9:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0025dcd:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
c0025dd1:	8d 45 01             	lea    0x1(%ebp),%eax
c0025dd4:	89 44 24 14          	mov    %eax,0x14(%esp)
c0025dd8:	ff 74 24 0c          	pushl  0xc(%esp)
c0025ddc:	ff 74 24 0c          	pushl  0xc(%esp)
c0025de0:	57                   	push   %edi
c0025de1:	56                   	push   %esi
c0025de2:	e8 7d 19 00 00       	call   c0027764 <__umoddi3>
c0025de7:	83 c4 10             	add    $0x10,%esp
c0025dea:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0025dee:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
c0025df2:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
c0025df5:	ff 74 24 0c          	pushl  0xc(%esp)
c0025df9:	ff 74 24 0c          	pushl  0xc(%esp)
c0025dfd:	57                   	push   %edi
c0025dfe:	56                   	push   %esi
c0025dff:	e8 44 19 00 00       	call   c0027748 <__udivdi3>
c0025e04:	83 c4 10             	add    $0x10,%esp
c0025e07:	89 c6                	mov    %eax,%esi
c0025e09:	89 d7                	mov    %edx,%edi
      digit_cnt++;
c0025e0b:	83 c3 01             	add    $0x1,%ebx
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
c0025e0e:	89 d0                	mov    %edx,%eax
c0025e10:	09 f0                	or     %esi,%eax
c0025e12:	75 92                	jne    c0025da6 <format_integer+0xd7>
c0025e14:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0025e18:	eb 04                	jmp    c0025e1e <format_integer+0x14f>
  x = (c->flags & POUND) && value ? b->x : 0;

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0025e1a:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0025e1e:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0025e25:	8b 50 08             	mov    0x8(%eax),%edx
c0025e28:	85 d2                	test   %edx,%edx
c0025e2a:	b8 01 00 00 00       	mov    $0x1,%eax
c0025e2f:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0025e32:	8d 7c 24 30          	lea    0x30(%esp),%edi
c0025e36:	89 d8                	mov    %ebx,%eax
c0025e38:	29 f8                	sub    %edi,%eax
c0025e3a:	39 c2                	cmp    %eax,%edx
c0025e3c:	7e 1f                	jle    c0025e5d <format_integer+0x18e>
c0025e3e:	8d 44 24 6f          	lea    0x6f(%esp),%eax
c0025e42:	39 c3                	cmp    %eax,%ebx
c0025e44:	73 17                	jae    c0025e5d <format_integer+0x18e>
c0025e46:	89 f9                	mov    %edi,%ecx
c0025e48:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
c0025e4a:	83 c3 01             	add    $0x1,%ebx
c0025e4d:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0025e51:	89 d8                	mov    %ebx,%eax
c0025e53:	29 c8                	sub    %ecx,%eax
c0025e55:	39 c2                	cmp    %eax,%edx
c0025e57:	7e 04                	jle    c0025e5d <format_integer+0x18e>
c0025e59:	39 f3                	cmp    %esi,%ebx
c0025e5b:	72 ed                	jb     c0025e4a <format_integer+0x17b>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0025e5d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0025e62:	74 20                	je     c0025e84 <format_integer+0x1b5>
c0025e64:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0025e6b:	83 38 08             	cmpl   $0x8,(%eax)
c0025e6e:	75 14                	jne    c0025e84 <format_integer+0x1b5>
c0025e70:	8d 44 24 30          	lea    0x30(%esp),%eax
c0025e74:	39 c3                	cmp    %eax,%ebx
c0025e76:	74 06                	je     c0025e7e <format_integer+0x1af>
c0025e78:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
c0025e7c:	74 06                	je     c0025e84 <format_integer+0x1b5>
    *cp++ = '0';
c0025e7e:	c6 03 30             	movb   $0x30,(%ebx)
c0025e81:	8d 5b 01             	lea    0x1(%ebx),%ebx

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0025e84:	29 df                	sub    %ebx,%edi
c0025e86:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0025e8d:	03 78 04             	add    0x4(%eax),%edi
c0025e90:	89 fe                	mov    %edi,%esi
c0025e92:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
c0025e97:	19 c0                	sbb    %eax,%eax
c0025e99:	f7 d0                	not    %eax
c0025e9b:	83 e0 02             	and    $0x2,%eax
c0025e9e:	29 c6                	sub    %eax,%esi
c0025ea0:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0025ea5:	0f 95 c0             	setne  %al
c0025ea8:	0f b6 c0             	movzbl %al,%eax
c0025eab:	29 c6                	sub    %eax,%esi
c0025ead:	b8 00 00 00 00       	mov    $0x0,%eax
c0025eb2:	0f 48 f0             	cmovs  %eax,%esi
  if (pad_cnt < 0)
    pad_cnt = 0;

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0025eb5:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0025eba:	75 20                	jne    c0025edc <format_integer+0x20d>
    output_dup (' ', pad_cnt, output, aux);
c0025ebc:	83 ec 0c             	sub    $0xc,%esp
c0025ebf:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0025ec6:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0025ecd:	89 f2                	mov    %esi,%edx
c0025ecf:	b8 20 00 00 00       	mov    $0x20,%eax
c0025ed4:	e8 c9 fd ff ff       	call   c0025ca2 <output_dup>
c0025ed9:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0025edc:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0025ee1:	74 18                	je     c0025efb <format_integer+0x22c>
    output (sign, aux);
c0025ee3:	83 ec 08             	sub    $0x8,%esp
c0025ee6:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0025eed:	ff 74 24 2c          	pushl  0x2c(%esp)
c0025ef1:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0025ef8:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0025efb:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0025f00:	74 2d                	je     c0025f2f <format_integer+0x260>
    {
      output ('0', aux);
c0025f02:	83 ec 08             	sub    $0x8,%esp
c0025f05:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0025f0c:	6a 30                	push   $0x30
c0025f0e:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
c0025f15:	83 c4 08             	add    $0x8,%esp
c0025f18:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c0025f1f:	0f be 44 24 30       	movsbl 0x30(%esp),%eax
c0025f24:	50                   	push   %eax
c0025f25:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0025f2c:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0025f2f:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0025f36:	f6 00 10             	testb  $0x10,(%eax)
c0025f39:	74 20                	je     c0025f5b <format_integer+0x28c>
    output_dup ('0', pad_cnt, output, aux);
c0025f3b:	83 ec 0c             	sub    $0xc,%esp
c0025f3e:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0025f45:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0025f4c:	89 f2                	mov    %esi,%edx
c0025f4e:	b8 30 00 00 00       	mov    $0x30,%eax
c0025f53:	e8 4a fd ff ff       	call   c0025ca2 <output_dup>
c0025f58:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0025f5b:	8d 44 24 30          	lea    0x30(%esp),%eax
c0025f5f:	39 c3                	cmp    %eax,%ebx
c0025f61:	76 2c                	jbe    c0025f8f <format_integer+0x2c0>
c0025f63:	89 c7                	mov    %eax,%edi
c0025f65:	89 74 24 08          	mov    %esi,0x8(%esp)
c0025f69:	8b b4 24 9c 00 00 00 	mov    0x9c(%esp),%esi
c0025f70:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
c0025f77:	83 eb 01             	sub    $0x1,%ebx
c0025f7a:	83 ec 08             	sub    $0x8,%esp
c0025f7d:	55                   	push   %ebp
c0025f7e:	0f be 03             	movsbl (%ebx),%eax
c0025f81:	50                   	push   %eax
c0025f82:	ff d6                	call   *%esi
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
c0025f84:	83 c4 10             	add    $0x10,%esp
c0025f87:	39 fb                	cmp    %edi,%ebx
c0025f89:	75 ec                	jne    c0025f77 <format_integer+0x2a8>
c0025f8b:	8b 74 24 08          	mov    0x8(%esp),%esi
    output (*--cp, aux);
  if (c->flags & MINUS)
c0025f8f:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0025f96:	f6 00 01             	testb  $0x1,(%eax)
c0025f99:	74 20                	je     c0025fbb <format_integer+0x2ec>
    output_dup (' ', pad_cnt, output, aux);
c0025f9b:	83 ec 0c             	sub    $0xc,%esp
c0025f9e:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0025fa5:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0025fac:	89 f2                	mov    %esi,%edx
c0025fae:	b8 20 00 00 00       	mov    $0x20,%eax
c0025fb3:	e8 ea fc ff ff       	call   c0025ca2 <output_dup>
c0025fb8:	83 c4 10             	add    $0x10,%esp
}
c0025fbb:	83 c4 7c             	add    $0x7c,%esp
c0025fbe:	5b                   	pop    %ebx
c0025fbf:	5e                   	pop    %esi
c0025fc0:	5f                   	pop    %edi
c0025fc1:	5d                   	pop    %ebp
c0025fc2:	c3                   	ret    

c0025fc3 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0025fc3:	55                   	push   %ebp
c0025fc4:	57                   	push   %edi
c0025fc5:	56                   	push   %esi
c0025fc6:	53                   	push   %ebx
c0025fc7:	83 ec 1c             	sub    $0x1c,%esp
c0025fca:	89 c5                	mov    %eax,%ebp
c0025fcc:	89 d6                	mov    %edx,%esi
c0025fce:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0025fd2:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0025fd6:	8b 51 04             	mov    0x4(%ecx),%edx
c0025fd9:	39 f2                	cmp    %esi,%edx
c0025fdb:	7e 6c                	jle    c0026049 <format_string+0x86>
c0025fdd:	f6 01 01             	testb  $0x1,(%ecx)
c0025fe0:	75 61                	jne    c0026043 <format_string+0x80>
    output_dup (' ', c->width - length, output, aux);
c0025fe2:	29 f2                	sub    %esi,%edx
c0025fe4:	83 ec 0c             	sub    $0xc,%esp
c0025fe7:	57                   	push   %edi
c0025fe8:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0025fec:	b8 20 00 00 00       	mov    $0x20,%eax
c0025ff1:	e8 ac fc ff ff       	call   c0025ca2 <output_dup>
  for (i = 0; i < length; i++)
c0025ff6:	83 c4 10             	add    $0x10,%esp
c0025ff9:	85 f6                	test   %esi,%esi
c0025ffb:	7e 1d                	jle    c002601a <format_string+0x57>
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0025ffd:	bb 00 00 00 00       	mov    $0x0,%ebx
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
    output (string[i], aux);
c0026002:	83 ec 08             	sub    $0x8,%esp
c0026005:	57                   	push   %edi
c0026006:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c002600b:	50                   	push   %eax
c002600c:	ff 54 24 40          	call   *0x40(%esp)
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0026010:	83 c3 01             	add    $0x1,%ebx
c0026013:	83 c4 10             	add    $0x10,%esp
c0026016:	39 de                	cmp    %ebx,%esi
c0026018:	7f e8                	jg     c0026002 <format_string+0x3f>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
c002601a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002601e:	8b 50 04             	mov    0x4(%eax),%edx
c0026021:	39 d6                	cmp    %edx,%esi
c0026023:	7d 28                	jge    c002604d <format_string+0x8a>
c0026025:	f6 00 01             	testb  $0x1,(%eax)
c0026028:	74 23                	je     c002604d <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
c002602a:	29 f2                	sub    %esi,%edx
c002602c:	83 ec 0c             	sub    $0xc,%esp
c002602f:	57                   	push   %edi
c0026030:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0026034:	b8 20 00 00 00       	mov    $0x20,%eax
c0026039:	e8 64 fc ff ff       	call   c0025ca2 <output_dup>
c002603e:	83 c4 10             	add    $0x10,%esp
}
c0026041:	eb 0a                	jmp    c002604d <format_string+0x8a>
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0026043:	85 f6                	test   %esi,%esi
c0026045:	7f b6                	jg     c0025ffd <format_string+0x3a>
c0026047:	eb e1                	jmp    c002602a <format_string+0x67>
c0026049:	85 f6                	test   %esi,%esi
c002604b:	7f b0                	jg     c0025ffd <format_string+0x3a>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
}
c002604d:	83 c4 1c             	add    $0x1c,%esp
c0026050:	5b                   	pop    %ebx
c0026051:	5e                   	pop    %esi
c0026052:	5f                   	pop    %edi
c0026053:	5d                   	pop    %ebp
c0026054:	c3                   	ret    

c0026055 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c0026055:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0026058:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
c002605c:	83 ec 08             	sub    $0x8,%esp
c002605f:	50                   	push   %eax
c0026060:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026064:	e8 67 36 00 00       	call   c00296d0 <vprintf>
  va_end (args);

  return retval;
}
c0026069:	83 c4 1c             	add    $0x1c,%esp
c002606c:	c3                   	ret    

c002606d <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c002606d:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
c0026070:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
c0026074:	ff 74 24 18          	pushl  0x18(%esp)
c0026078:	ff 74 24 18          	pushl  0x18(%esp)
c002607c:	50                   	push   %eax
c002607d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026081:	e8 04 00 00 00       	call   c002608a <__vprintf>
  va_end (args);
}
c0026086:	83 c4 1c             	add    $0x1c,%esp
c0026089:	c3                   	ret    

c002608a <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c002608a:	55                   	push   %ebp
c002608b:	57                   	push   %edi
c002608c:	56                   	push   %esi
c002608d:	53                   	push   %ebx
c002608e:	83 ec 4c             	sub    $0x4c,%esp
c0026091:	8b 74 24 60          	mov    0x60(%esp),%esi
c0026095:	8b 6c 24 64          	mov    0x64(%esp),%ebp
  for (; *format != '\0'; format++)
c0026099:	0f b6 06             	movzbl (%esi),%eax
c002609c:	84 c0                	test   %al,%al
c002609e:	0f 84 49 06 00 00    	je     c00266ed <__vprintf+0x663>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c00260a4:	3c 25                	cmp    $0x25,%al
c00260a6:	74 19                	je     c00260c1 <__vprintf+0x37>
        {
          output (*format, aux);
c00260a8:	83 ec 08             	sub    $0x8,%esp
c00260ab:	ff 74 24 74          	pushl  0x74(%esp)
c00260af:	0f be c0             	movsbl %al,%eax
c00260b2:	50                   	push   %eax
c00260b3:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c00260b7:	83 c4 10             	add    $0x10,%esp
c00260ba:	89 f3                	mov    %esi,%ebx
c00260bc:	e9 12 06 00 00       	jmp    c00266d3 <__vprintf+0x649>
        }
      format++;
c00260c1:	8d 5e 01             	lea    0x1(%esi),%ebx

      /* %% => %. */
      if (*format == '%') 
c00260c4:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c00260c8:	75 15                	jne    c00260df <__vprintf+0x55>
        {
          output ('%', aux);
c00260ca:	83 ec 08             	sub    $0x8,%esp
c00260cd:	ff 74 24 74          	pushl  0x74(%esp)
c00260d1:	6a 25                	push   $0x25
c00260d3:	ff 54 24 78          	call   *0x78(%esp)
          continue;
c00260d7:	83 c4 10             	add    $0x10,%esp
c00260da:	e9 f4 05 00 00       	jmp    c00266d3 <__vprintf+0x649>
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
  /* Parse flag characters. */
  c->flags = 0;
c00260df:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c00260e6:	00 
c00260e7:	bf 00 00 00 00       	mov    $0x0,%edi
c00260ec:	be 00 00 00 00       	mov    $0x0,%esi
c00260f1:	eb 07                	jmp    c00260fa <__vprintf+0x70>
  for (;;) 
    {
      switch (*format++) 
c00260f3:	89 cb                	mov    %ecx,%ebx
c00260f5:	bf 01 00 00 00       	mov    $0x1,%edi
c00260fa:	8d 4b 01             	lea    0x1(%ebx),%ecx
c00260fd:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
c0026101:	8d 50 e0             	lea    -0x20(%eax),%edx
c0026104:	80 fa 10             	cmp    $0x10,%dl
c0026107:	77 28                	ja     c0026131 <__vprintf+0xa7>
c0026109:	0f b6 d2             	movzbl %dl,%edx
c002610c:	ff 24 95 30 c5 02 c0 	jmp    *-0x3ffd3ad0(,%edx,4)
        {
        case '-':
          c->flags |= MINUS;
c0026113:	83 ce 01             	or     $0x1,%esi
c0026116:	eb db                	jmp    c00260f3 <__vprintf+0x69>
          break;
        case '+':
          c->flags |= PLUS;
c0026118:	83 ce 02             	or     $0x2,%esi
c002611b:	eb d6                	jmp    c00260f3 <__vprintf+0x69>
          break;
        case ' ':
          c->flags |= SPACE;
c002611d:	83 ce 04             	or     $0x4,%esi
c0026120:	eb d1                	jmp    c00260f3 <__vprintf+0x69>
          break;
        case '#':
          c->flags |= POUND;
c0026122:	83 ce 08             	or     $0x8,%esi
c0026125:	eb cc                	jmp    c00260f3 <__vprintf+0x69>
          break;
        case '0':
          c->flags |= ZERO;
c0026127:	83 ce 10             	or     $0x10,%esi
c002612a:	eb c7                	jmp    c00260f3 <__vprintf+0x69>
          break;
        case '\'':
          c->flags |= GROUP;
c002612c:	83 ce 20             	or     $0x20,%esi
c002612f:	eb c2                	jmp    c00260f3 <__vprintf+0x69>
c0026131:	89 fa                	mov    %edi,%edx
c0026133:	84 d2                	test   %dl,%dl
c0026135:	74 13                	je     c002614a <__vprintf+0xc0>
c0026137:	89 74 24 30          	mov    %esi,0x30(%esp)
          format--;
          goto not_a_flag;
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c002613b:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0026141:	74 07                	je     c002614a <__vprintf+0xc0>
    c->flags &= ~ZERO;
c0026143:	83 e6 ef             	and    $0xffffffef,%esi
c0026146:	89 74 24 30          	mov    %esi,0x30(%esp)
  if (c->flags & PLUS)
c002614a:	8b 54 24 30          	mov    0x30(%esp),%edx
c002614e:	f6 c2 02             	test   $0x2,%dl
c0026151:	74 07                	je     c002615a <__vprintf+0xd0>
    c->flags &= ~SPACE;
c0026153:	83 e2 fb             	and    $0xfffffffb,%edx
c0026156:	89 54 24 30          	mov    %edx,0x30(%esp)

  /* Parse field width. */
  c->width = 0;
c002615a:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
c0026161:	00 
  if (*format == '*')
c0026162:	3c 2a                	cmp    $0x2a,%al
c0026164:	74 12                	je     c0026178 <__vprintf+0xee>
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
c0026166:	0f be d0             	movsbl %al,%edx
c0026169:	83 ea 30             	sub    $0x30,%edx
c002616c:	b9 00 00 00 00       	mov    $0x0,%ecx
c0026171:	83 fa 09             	cmp    $0x9,%edx
c0026174:	76 10                	jbe    c0026186 <__vprintf+0xfc>
c0026176:	eb 40                	jmp    c00261b8 <__vprintf+0x12e>
  /* Parse field width. */
  c->width = 0;
  if (*format == '*')
    {
      format++;
      c->width = va_arg (*args, int);
c0026178:	8b 45 00             	mov    0x0(%ebp),%eax
c002617b:	89 44 24 34          	mov    %eax,0x34(%esp)
c002617f:	8d 6d 04             	lea    0x4(%ebp),%ebp
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
c0026182:	89 cb                	mov    %ecx,%ebx
c0026184:	eb 1f                	jmp    c00261a5 <__vprintf+0x11b>
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0026186:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c0026189:	0f be c0             	movsbl %al,%eax
c002618c:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
c0026190:	83 c3 01             	add    $0x1,%ebx
c0026193:	0f b6 03             	movzbl (%ebx),%eax
c0026196:	0f be d0             	movsbl %al,%edx
c0026199:	83 ea 30             	sub    $0x30,%edx
c002619c:	83 fa 09             	cmp    $0x9,%edx
c002619f:	76 e5                	jbe    c0026186 <__vprintf+0xfc>
c00261a1:	89 4c 24 34          	mov    %ecx,0x34(%esp)
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
c00261a5:	8b 44 24 34          	mov    0x34(%esp),%eax
c00261a9:	85 c0                	test   %eax,%eax
c00261ab:	79 0b                	jns    c00261b8 <__vprintf+0x12e>
    {
      c->width = -c->width;
c00261ad:	f7 d8                	neg    %eax
c00261af:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
c00261b3:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
    }
      
  /* Parse precision. */
  c->precision = -1;
c00261b8:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c00261bf:	ff 
  if (*format == '.') 
c00261c0:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c00261c3:	0f 85 1b 05 00 00    	jne    c00266e4 <__vprintf+0x65a>
    {
      format++;
      if (*format == '*') 
c00261c9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00261cd:	3c 2a                	cmp    $0x2a,%al
c00261cf:	75 0f                	jne    c00261e0 <__vprintf+0x156>
        {
          format++;
c00261d1:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
c00261d4:	8b 45 00             	mov    0x0(%ebp),%eax
c00261d7:	89 44 24 38          	mov    %eax,0x38(%esp)
c00261db:	8d 6d 04             	lea    0x4(%ebp),%ebp
c00261de:	eb 3a                	jmp    c002621a <__vprintf+0x190>
      
  /* Parse precision. */
  c->precision = -1;
  if (*format == '.') 
    {
      format++;
c00261e0:	83 c3 01             	add    $0x1,%ebx
          format++;
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
c00261e3:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c00261ea:	00 
          for (; isdigit (*format); format++)
c00261eb:	0f be d0             	movsbl %al,%edx
c00261ee:	83 ea 30             	sub    $0x30,%edx
c00261f1:	83 fa 09             	cmp    $0x9,%edx
c00261f4:	77 39                	ja     c002622f <__vprintf+0x1a5>
c00261f6:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
c00261fb:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
c00261fe:	0f be c0             	movsbl %al,%eax
c0026201:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
c0026205:	83 c3 01             	add    $0x1,%ebx
c0026208:	0f b6 03             	movzbl (%ebx),%eax
c002620b:	0f be d0             	movsbl %al,%edx
c002620e:	83 ea 30             	sub    $0x30,%edx
c0026211:	83 fa 09             	cmp    $0x9,%edx
c0026214:	76 e5                	jbe    c00261fb <__vprintf+0x171>
c0026216:	89 4c 24 38          	mov    %ecx,0x38(%esp)
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
c002621a:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c002621e:	85 c9                	test   %ecx,%ecx
c0026220:	79 12                	jns    c0026234 <__vprintf+0x1aa>
        c->precision = -1;
c0026222:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
c0026229:	ff 
c002622a:	e9 b5 04 00 00       	jmp    c00266e4 <__vprintf+0x65a>
    }
  if (c->precision >= 0)
c002622f:	b9 00 00 00 00       	mov    $0x0,%ecx
    c->flags &= ~ZERO;
c0026234:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)

  /* Parse type. */
  c->type = INT;
c0026239:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
c0026240:	00 
  switch (*format++) 
c0026241:	8d 73 01             	lea    0x1(%ebx),%esi
c0026244:	0f b6 03             	movzbl (%ebx),%eax
c0026247:	8d 50 98             	lea    -0x68(%eax),%edx
c002624a:	80 fa 12             	cmp    $0x12,%dl
c002624d:	0f 87 06 01 00 00    	ja     c0026359 <__vprintf+0x2cf>
c0026253:	0f b6 d2             	movzbl %dl,%edx
c0026256:	ff 24 95 74 c5 02 c0 	jmp    *-0x3ffd3a8c(,%edx,4)
    {
    case 'h':
      if (*format == 'h') 
c002625d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0026261:	3c 68                	cmp    $0x68,%al
c0026263:	75 25                	jne    c002628a <__vprintf+0x200>
        {
          format++;
c0026265:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
c0026268:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
c002626f:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c0026270:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0026274:	8d 50 bb             	lea    -0x45(%eax),%edx
c0026277:	80 fa 33             	cmp    $0x33,%dl
c002627a:	0f 87 38 04 00 00    	ja     c00266b8 <__vprintf+0x62e>
c0026280:	0f b6 d2             	movzbl %dl,%edx
c0026283:	ff 24 95 c0 c5 02 c0 	jmp    *-0x3ffd3a40(,%edx,4)
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
c002628a:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
c0026291:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c0026292:	8d 50 bb             	lea    -0x45(%eax),%edx
c0026295:	80 fa 33             	cmp    $0x33,%dl
c0026298:	0f 87 1a 04 00 00    	ja     c00266b8 <__vprintf+0x62e>
c002629e:	0f b6 d2             	movzbl %dl,%edx
c00262a1:	ff 24 95 90 c6 02 c0 	jmp    *-0x3ffd3970(,%edx,4)
      else
        c->type = SHORT;
      break;
      
    case 'j':
      c->type = INTMAX;
c00262a8:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
c00262af:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c00262b0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00262b4:	8d 50 bb             	lea    -0x45(%eax),%edx
c00262b7:	80 fa 33             	cmp    $0x33,%dl
c00262ba:	0f 87 f8 03 00 00    	ja     c00266b8 <__vprintf+0x62e>
c00262c0:	0f b6 d2             	movzbl %dl,%edx
c00262c3:	ff 24 95 60 c7 02 c0 	jmp    *-0x3ffd38a0(,%edx,4)
    case 'j':
      c->type = INTMAX;
      break;

    case 'l':
      if (*format == 'l')
c00262ca:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00262ce:	3c 6c                	cmp    $0x6c,%al
c00262d0:	75 25                	jne    c00262f7 <__vprintf+0x26d>
        {
          format++;
c00262d2:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
c00262d5:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
c00262dc:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c00262dd:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c00262e1:	8d 50 bb             	lea    -0x45(%eax),%edx
c00262e4:	80 fa 33             	cmp    $0x33,%dl
c00262e7:	0f 87 cb 03 00 00    	ja     c00266b8 <__vprintf+0x62e>
c00262ed:	0f b6 d2             	movzbl %dl,%edx
c00262f0:	ff 24 95 30 c8 02 c0 	jmp    *-0x3ffd37d0(,%edx,4)
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
c00262f7:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
c00262fe:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c00262ff:	8d 50 bb             	lea    -0x45(%eax),%edx
c0026302:	80 fa 33             	cmp    $0x33,%dl
c0026305:	0f 87 ad 03 00 00    	ja     c00266b8 <__vprintf+0x62e>
c002630b:	0f b6 d2             	movzbl %dl,%edx
c002630e:	ff 24 95 00 c9 02 c0 	jmp    *-0x3ffd3700(,%edx,4)
      else
        c->type = LONG;
      break;

    case 't':
      c->type = PTRDIFFT;
c0026315:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
c002631c:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c002631d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0026321:	8d 50 bb             	lea    -0x45(%eax),%edx
c0026324:	80 fa 33             	cmp    $0x33,%dl
c0026327:	0f 87 8b 03 00 00    	ja     c00266b8 <__vprintf+0x62e>
c002632d:	0f b6 d2             	movzbl %dl,%edx
c0026330:	ff 24 95 d0 c9 02 c0 	jmp    *-0x3ffd3630(,%edx,4)
    case 't':
      c->type = PTRDIFFT;
      break;

    case 'z':
      c->type = SIZET;
c0026337:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
c002633e:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c002633f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0026343:	8d 50 bb             	lea    -0x45(%eax),%edx
c0026346:	80 fa 33             	cmp    $0x33,%dl
c0026349:	0f 87 69 03 00 00    	ja     c00266b8 <__vprintf+0x62e>
c002634f:	0f b6 d2             	movzbl %dl,%edx
c0026352:	ff 24 95 a0 ca 02 c0 	jmp    *-0x3ffd3560(,%edx,4)
c0026359:	8d 50 bb             	lea    -0x45(%eax),%edx
c002635c:	80 fa 33             	cmp    $0x33,%dl
c002635f:	0f 87 51 03 00 00    	ja     c00266b6 <__vprintf+0x62c>
c0026365:	0f b6 d2             	movzbl %dl,%edx
c0026368:	ff 24 95 70 cb 02 c0 	jmp    *-0x3ffd3490(,%edx,4)
c002636f:	89 de                	mov    %ebx,%esi
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c0026371:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
c0026376:	0f 87 c4 00 00 00    	ja     c0026440 <__vprintf+0x3b6>
c002637c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0026380:	ff 24 85 40 cc 02 c0 	jmp    *-0x3ffd33c0(,%eax,4)
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c0026387:	0f be 4d 00          	movsbl 0x0(%ebp),%ecx
c002638b:	89 c8                	mov    %ecx,%eax
c002638d:	99                   	cltd   
c002638e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0026392:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0026396:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c0026399:	e9 bb 00 00 00       	jmp    c0026459 <__vprintf+0x3cf>
              case SHORT:
                value = (short) va_arg (args, int);
c002639e:	0f bf 4d 00          	movswl 0x0(%ebp),%ecx
c00263a2:	89 c8                	mov    %ecx,%eax
c00263a4:	99                   	cltd   
c00263a5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00263a9:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00263ad:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c00263b0:	e9 a4 00 00 00       	jmp    c0026459 <__vprintf+0x3cf>
              case INT:
                value = va_arg (args, int);
c00263b5:	8b 4d 00             	mov    0x0(%ebp),%ecx
c00263b8:	89 c8                	mov    %ecx,%eax
c00263ba:	99                   	cltd   
c00263bb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00263bf:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00263c3:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c00263c6:	e9 8e 00 00 00       	jmp    c0026459 <__vprintf+0x3cf>
              case INTMAX:
                value = va_arg (args, intmax_t);
c00263cb:	8b 45 00             	mov    0x0(%ebp),%eax
c00263ce:	8b 55 04             	mov    0x4(%ebp),%edx
c00263d1:	89 44 24 08          	mov    %eax,0x8(%esp)
c00263d5:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00263d9:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
c00263dc:	eb 7b                	jmp    c0026459 <__vprintf+0x3cf>
              case LONG:
                value = va_arg (args, long);
c00263de:	8b 4d 00             	mov    0x0(%ebp),%ecx
c00263e1:	89 c8                	mov    %ecx,%eax
c00263e3:	99                   	cltd   
c00263e4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00263e8:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00263ec:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c00263ef:	eb 68                	jmp    c0026459 <__vprintf+0x3cf>
              case LONGLONG:
                value = va_arg (args, long long);
c00263f1:	8b 45 00             	mov    0x0(%ebp),%eax
c00263f4:	8b 55 04             	mov    0x4(%ebp),%edx
c00263f7:	89 44 24 08          	mov    %eax,0x8(%esp)
c00263fb:	89 54 24 0c          	mov    %edx,0xc(%esp)
c00263ff:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
c0026402:	eb 55                	jmp    c0026459 <__vprintf+0x3cf>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0026404:	8b 4d 00             	mov    0x0(%ebp),%ecx
c0026407:	89 c8                	mov    %ecx,%eax
c0026409:	99                   	cltd   
c002640a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c002640e:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0026412:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c0026415:	eb 42                	jmp    c0026459 <__vprintf+0x3cf>
              case SIZET:
                value = va_arg (args, size_t);
c0026417:	8d 45 04             	lea    0x4(%ebp),%eax
c002641a:	8b 7d 00             	mov    0x0(%ebp),%edi
c002641d:	bd 00 00 00 00       	mov    $0x0,%ebp
c0026422:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0026426:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
c002642a:	89 c5                	mov    %eax,%ebp
                if (value > SIZE_MAX / 2)
c002642c:	81 ff ff ff ff 7f    	cmp    $0x7fffffff,%edi
c0026432:	76 25                	jbe    c0026459 <__vprintf+0x3cf>
                  value = value - SIZE_MAX - 1;
c0026434:	83 44 24 08 00       	addl   $0x0,0x8(%esp)
c0026439:	83 54 24 0c ff       	adcl   $0xffffffff,0xc(%esp)
c002643e:	eb 19                	jmp    c0026459 <__vprintf+0x3cf>
                break;
              default:
                NOT_REACHED ();
c0026440:	68 c0 d6 02 c0       	push   $0xc002d6c0
c0026445:	68 64 cc 02 c0       	push   $0xc002cc64
c002644a:	68 dc 00 00 00       	push   $0xdc
c002644f:	68 31 e9 02 c0       	push   $0xc002e931
c0026454:	e8 74 18 00 00       	call   c0027ccd <debug_panic>
              }

            format_integer (value < 0 ? -value : value,
c0026459:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002645d:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0026461:	89 da                	mov    %ebx,%edx
c0026463:	c1 fa 1f             	sar    $0x1f,%edx
c0026466:	89 d7                	mov    %edx,%edi
c0026468:	31 cf                	xor    %ecx,%edi
c002646a:	89 7c 24 10          	mov    %edi,0x10(%esp)
c002646e:	89 d7                	mov    %edx,%edi
c0026470:	33 7c 24 0c          	xor    0xc(%esp),%edi
c0026474:	89 7c 24 14          	mov    %edi,0x14(%esp)
c0026478:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002647c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0026480:	29 d1                	sub    %edx,%ecx
c0026482:	19 d3                	sbb    %edx,%ebx
c0026484:	89 c8                	mov    %ecx,%eax
c0026486:	89 da                	mov    %ebx,%edx
c0026488:	83 ec 0c             	sub    $0xc,%esp
c002648b:	ff 74 24 78          	pushl  0x78(%esp)
c002648f:	ff 74 24 78          	pushl  0x78(%esp)
c0026493:	8d 7c 24 44          	lea    0x44(%esp),%edi
c0026497:	57                   	push   %edi
c0026498:	68 a0 cc 02 c0       	push   $0xc002cca0
c002649d:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c00264a1:	c1 e9 1f             	shr    $0x1f,%ecx
c00264a4:	51                   	push   %ecx
c00264a5:	b9 01 00 00 00       	mov    $0x1,%ecx
c00264aa:	e8 20 f8 ff ff       	call   c0025ccf <format_integer>
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c00264af:	83 c4 20             	add    $0x20,%esp
c00264b2:	89 f3                	mov    %esi,%ebx
c00264b4:	e9 1a 02 00 00       	jmp    c00266d3 <__vprintf+0x649>
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
                break;
              case INT:
                value = va_arg (args, unsigned);
c00264b9:	8b 75 00             	mov    0x0(%ebp),%esi
c00264bc:	bf 00 00 00 00       	mov    $0x0,%edi
c00264c1:	89 74 24 18          	mov    %esi,0x18(%esp)
c00264c5:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
c00264c9:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c00264cc:	e9 9d 00 00 00       	jmp    c002656e <__vprintf+0x4e4>
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c00264d1:	0f b6 55 00          	movzbl 0x0(%ebp),%edx
c00264d5:	89 54 24 18          	mov    %edx,0x18(%esp)
c00264d9:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c00264e0:	00 
                break;
c00264e1:	89 f3                	mov    %esi,%ebx
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c00264e3:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c00264e6:	e9 83 00 00 00       	jmp    c002656e <__vprintf+0x4e4>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c00264eb:	0f b7 55 00          	movzwl 0x0(%ebp),%edx
c00264ef:	89 54 24 18          	mov    %edx,0x18(%esp)
c00264f3:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c00264fa:	00 
                break;
c00264fb:	89 f3                	mov    %esi,%ebx
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c00264fd:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c0026500:	eb 6c                	jmp    c002656e <__vprintf+0x4e4>
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0026502:	8b 4d 00             	mov    0x0(%ebp),%ecx
c0026505:	8b 5d 04             	mov    0x4(%ebp),%ebx
c0026508:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c002650c:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
c0026510:	89 f3                	mov    %esi,%ebx
                break;
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0026512:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
c0026515:	eb 57                	jmp    c002656e <__vprintf+0x4e4>
              case LONG:
                value = va_arg (args, unsigned long);
c0026517:	8b 4d 00             	mov    0x0(%ebp),%ecx
c002651a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002651f:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c0026523:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
c0026527:	89 f3                	mov    %esi,%ebx
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
                break;
              case LONG:
                value = va_arg (args, unsigned long);
c0026529:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
c002652c:	eb 40                	jmp    c002656e <__vprintf+0x4e4>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c002652e:	8b 4d 00             	mov    0x0(%ebp),%ecx
c0026531:	8b 5d 04             	mov    0x4(%ebp),%ebx
c0026534:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c0026538:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
c002653c:	89 f3                	mov    %esi,%ebx
                break;
              case LONG:
                value = va_arg (args, unsigned long);
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c002653e:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
c0026541:	eb 2b                	jmp    c002656e <__vprintf+0x4e4>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0026543:	8b 7d 00             	mov    0x0(%ebp),%edi
c0026546:	89 7c 24 18          	mov    %edi,0x18(%esp)
c002654a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0026551:	00 
#endif
                break;
c0026552:	89 f3                	mov    %esi,%ebx
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
                break;
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0026554:	8d 6d 04             	lea    0x4(%ebp),%ebp
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
c0026557:	eb 15                	jmp    c002656e <__vprintf+0x4e4>
              case SIZET:
                value = va_arg (args, size_t);
c0026559:	8b 4d 00             	mov    0x0(%ebp),%ecx
c002655c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0026561:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c0026565:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
c0026569:	89 f3                	mov    %esi,%ebx
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
              case SIZET:
                value = va_arg (args, size_t);
c002656b:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
              default:
                NOT_REACHED ();
              }

            switch (*format) 
c002656e:	3c 6f                	cmp    $0x6f,%al
c0026570:	74 3b                	je     c00265ad <__vprintf+0x523>
c0026572:	3c 6f                	cmp    $0x6f,%al
c0026574:	7f 06                	jg     c002657c <__vprintf+0x4f2>
c0026576:	3c 58                	cmp    $0x58,%al
c0026578:	74 13                	je     c002658d <__vprintf+0x503>
c002657a:	eb 18                	jmp    c0026594 <__vprintf+0x50a>
c002657c:	3c 75                	cmp    $0x75,%al
c002657e:	74 06                	je     c0026586 <__vprintf+0x4fc>
c0026580:	3c 78                	cmp    $0x78,%al
c0026582:	74 30                	je     c00265b4 <__vprintf+0x52a>
c0026584:	eb 0e                	jmp    c0026594 <__vprintf+0x50a>
              {
              case 'o': b = &base_o; break;
              case 'u': b = &base_d; break;
c0026586:	b8 a0 cc 02 c0       	mov    $0xc002cca0,%eax
c002658b:	eb 2c                	jmp    c00265b9 <__vprintf+0x52f>
              case 'x': b = &base_x; break;
              case 'X': b = &base_X; break;
c002658d:	b8 70 cc 02 c0       	mov    $0xc002cc70,%eax
c0026592:	eb 25                	jmp    c00265b9 <__vprintf+0x52f>
              default: NOT_REACHED ();
c0026594:	68 c0 d6 02 c0       	push   $0xc002d6c0
c0026599:	68 64 cc 02 c0       	push   $0xc002cc64
c002659e:	68 14 01 00 00       	push   $0x114
c00265a3:	68 31 e9 02 c0       	push   $0xc002e931
c00265a8:	e8 20 17 00 00       	call   c0027ccd <debug_panic>
                NOT_REACHED ();
              }

            switch (*format) 
              {
              case 'o': b = &base_o; break;
c00265ad:	b8 90 cc 02 c0       	mov    $0xc002cc90,%eax
c00265b2:	eb 05                	jmp    c00265b9 <__vprintf+0x52f>
              case 'u': b = &base_d; break;
              case 'x': b = &base_x; break;
c00265b4:	b8 80 cc 02 c0       	mov    $0xc002cc80,%eax
              case 'X': b = &base_X; break;
              default: NOT_REACHED ();
              }

            format_integer (value, false, false, b, &c, output, aux);
c00265b9:	83 ec 0c             	sub    $0xc,%esp
c00265bc:	ff 74 24 78          	pushl  0x78(%esp)
c00265c0:	ff 74 24 78          	pushl  0x78(%esp)
c00265c4:	8d 7c 24 44          	lea    0x44(%esp),%edi
c00265c8:	57                   	push   %edi
c00265c9:	50                   	push   %eax
c00265ca:	6a 00                	push   $0x0
c00265cc:	b9 00 00 00 00       	mov    $0x0,%ecx
c00265d1:	8b 44 24 38          	mov    0x38(%esp),%eax
c00265d5:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c00265d9:	e8 f1 f6 ff ff       	call   c0025ccf <format_integer>
          }
          break;
c00265de:	83 c4 20             	add    $0x20,%esp
c00265e1:	e9 ed 00 00 00       	jmp    c00266d3 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c00265e6:	89 de                	mov    %ebx,%esi
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c00265e8:	8d 7d 04             	lea    0x4(%ebp),%edi
c00265eb:	8b 45 00             	mov    0x0(%ebp),%eax
c00265ee:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
c00265f2:	83 ec 08             	sub    $0x8,%esp
c00265f5:	ff 74 24 74          	pushl  0x74(%esp)
c00265f9:	ff 74 24 74          	pushl  0x74(%esp)
c00265fd:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0026601:	ba 01 00 00 00       	mov    $0x1,%edx
c0026606:	8d 44 24 3f          	lea    0x3f(%esp),%eax
c002660a:	e8 b4 f9 ff ff       	call   c0025fc3 <format_string>
          }
          break;
c002660f:	83 c4 10             	add    $0x10,%esp
c0026612:	89 f3                	mov    %esi,%ebx
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0026614:	89 fd                	mov    %edi,%ebp
            format_string (&ch, 1, &c, output, aux);
          }
          break;
c0026616:	e9 b8 00 00 00       	jmp    c00266d3 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c002661b:	89 de                	mov    %ebx,%esi
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c002661d:	8d 7d 04             	lea    0x4(%ebp),%edi
c0026620:	8b 5d 00             	mov    0x0(%ebp),%ebx
            if (s == NULL)
              s = "(null)";
c0026623:	85 db                	test   %ebx,%ebx
c0026625:	b8 2a e9 02 c0       	mov    $0xc002e92a,%eax
c002662a:	0f 44 d8             	cmove  %eax,%ebx

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c002662d:	83 ec 08             	sub    $0x8,%esp
c0026630:	51                   	push   %ecx
c0026631:	53                   	push   %ebx
c0026632:	e8 7e 0d 00 00       	call   c00273b5 <strnlen>
c0026637:	83 c4 08             	add    $0x8,%esp
c002663a:	ff 74 24 74          	pushl  0x74(%esp)
c002663e:	ff 74 24 74          	pushl  0x74(%esp)
c0026642:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c0026646:	89 c2                	mov    %eax,%edx
c0026648:	89 d8                	mov    %ebx,%eax
c002664a:	e8 74 f9 ff ff       	call   c0025fc3 <format_string>
          }
          break;
c002664f:	83 c4 10             	add    $0x10,%esp
c0026652:	89 f3                	mov    %esi,%ebx
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c0026654:	89 fd                	mov    %edi,%ebp
            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
          }
          break;
c0026656:	eb 7b                	jmp    c00266d3 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c0026658:	89 de                	mov    %ebx,%esi
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c002665a:	8d 7d 04             	lea    0x4(%ebp),%edi
c002665d:	8b 45 00             	mov    0x0(%ebp),%eax

            c.flags = POUND;
c0026660:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
c0026667:	00 
            format_integer ((uintptr_t) p, false, false,
c0026668:	ba 00 00 00 00       	mov    $0x0,%edx
c002666d:	83 ec 0c             	sub    $0xc,%esp
c0026670:	ff 74 24 78          	pushl  0x78(%esp)
c0026674:	ff 74 24 78          	pushl  0x78(%esp)
c0026678:	8d 4c 24 44          	lea    0x44(%esp),%ecx
c002667c:	51                   	push   %ecx
c002667d:	68 80 cc 02 c0       	push   $0xc002cc80
c0026682:	6a 00                	push   $0x0
c0026684:	b9 00 00 00 00       	mov    $0x0,%ecx
c0026689:	e8 41 f6 ff ff       	call   c0025ccf <format_integer>
                            &base_x, &c, output, aux);
          }
          break;
c002668e:	83 c4 20             	add    $0x20,%esp
c0026691:	89 f3                	mov    %esi,%ebx
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0026693:	89 fd                	mov    %edi,%ebp

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
                            &base_x, &c, output, aux);
          }
          break;
c0026695:	eb 3c                	jmp    c00266d3 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c0026697:	89 de                	mov    %ebx,%esi
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0026699:	0f be c0             	movsbl %al,%eax
c002669c:	50                   	push   %eax
c002669d:	ff 74 24 70          	pushl  0x70(%esp)
c00266a1:	ff 74 24 70          	pushl  0x70(%esp)
c00266a5:	68 43 e9 02 c0       	push   $0xc002e943
c00266aa:	e8 be f9 ff ff       	call   c002606d <__printf>
          break;
c00266af:	83 c4 10             	add    $0x10,%esp
c00266b2:	89 f3                	mov    %esi,%ebx
c00266b4:	eb 1d                	jmp    c00266d3 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
c00266b6:	89 de                	mov    %ebx,%esi
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
          break;

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00266b8:	0f be c0             	movsbl %al,%eax
c00266bb:	50                   	push   %eax
c00266bc:	ff 74 24 70          	pushl  0x70(%esp)
c00266c0:	ff 74 24 70          	pushl  0x70(%esp)
c00266c4:	68 59 e9 02 c0       	push   $0xc002e959
c00266c9:	e8 9f f9 ff ff       	call   c002606d <__printf>
          break;
c00266ce:	83 c4 10             	add    $0x10,%esp
c00266d1:	89 f3                	mov    %esi,%ebx

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
c00266d3:	8d 73 01             	lea    0x1(%ebx),%esi
c00266d6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c00266da:	84 c0                	test   %al,%al
c00266dc:	0f 85 c2 f9 ff ff    	jne    c00260a4 <__vprintf+0x1a>
c00266e2:	eb 09                	jmp    c00266ed <__vprintf+0x663>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
        c->precision = -1;
    }
  if (c->precision >= 0)
c00266e4:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c00266e8:	e9 4c fb ff ff       	jmp    c0026239 <__vprintf+0x1af>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
c00266ed:	83 c4 4c             	add    $0x4c,%esp
c00266f0:	5b                   	pop    %ebx
c00266f1:	5e                   	pop    %esi
c00266f2:	5f                   	pop    %edi
c00266f3:	5d                   	pop    %ebp
c00266f4:	c3                   	ret    

c00266f5 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c00266f5:	53                   	push   %ebx
c00266f6:	83 ec 18             	sub    $0x18,%esp
c00266f9:	8b 44 24 24          	mov    0x24(%esp),%eax
c00266fd:	8b 54 24 28          	mov    0x28(%esp),%edx
c0026701:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0026705:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0026709:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
c002670d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0026714:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0026715:	85 c0                	test   %eax,%eax
c0026717:	74 24                	je     c002673d <vsnprintf+0x48>
c0026719:	83 e8 01             	sub    $0x1,%eax
c002671c:	89 44 24 0c          	mov    %eax,0xc(%esp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c0026720:	8d 44 24 04          	lea    0x4(%esp),%eax
c0026724:	50                   	push   %eax
c0026725:	68 80 5c 02 c0       	push   $0xc0025c80
c002672a:	51                   	push   %ecx
c002672b:	52                   	push   %edx
c002672c:	e8 59 f9 ff ff       	call   c002608a <__vprintf>

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';
c0026731:	8b 44 24 14          	mov    0x14(%esp),%eax
c0026735:	c6 00 00             	movb   $0x0,(%eax)
c0026738:	83 c4 10             	add    $0x10,%esp
c002673b:	eb 1c                	jmp    c0026759 <vsnprintf+0x64>
{
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
  aux.length = 0;
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c002673d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0026744:	00 

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c0026745:	8d 44 24 04          	lea    0x4(%esp),%eax
c0026749:	50                   	push   %eax
c002674a:	68 80 5c 02 c0       	push   $0xc0025c80
c002674f:	51                   	push   %ecx
c0026750:	52                   	push   %edx
c0026751:	e8 34 f9 ff ff       	call   c002608a <__vprintf>
c0026756:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';

  return aux.length;
c0026759:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c002675d:	83 c4 18             	add    $0x18,%esp
c0026760:	5b                   	pop    %ebx
c0026761:	c3                   	ret    

c0026762 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0026762:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0026765:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
c0026769:	50                   	push   %eax
c002676a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002676e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026772:	ff 74 24 1c          	pushl  0x1c(%esp)
c0026776:	e8 7a ff ff ff       	call   c00266f5 <vsnprintf>
  va_end (args);

  return retval;
}
c002677b:	83 c4 1c             	add    $0x1c,%esp
c002677e:	c3                   	ret    

c002677f <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c002677f:	55                   	push   %ebp
c0026780:	57                   	push   %edi
c0026781:	56                   	push   %esi
c0026782:	53                   	push   %ebx
c0026783:	83 ec 1c             	sub    $0x1c,%esp
c0026786:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
c002678b:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c002678f:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0026794:	0f 84 cb 01 00 00    	je     c0026965 <hex_dump+0x1e6>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c002679a:	8b 74 24 30          	mov    0x30(%esp),%esi
c002679e:	83 e6 0f             	and    $0xf,%esi
      end = per_line;
      if (end - start > size)
c00267a1:	b8 10 00 00 00       	mov    $0x10,%eax
c00267a6:	29 f0                	sub    %esi,%eax
c00267a8:	89 44 24 08          	mov    %eax,0x8(%esp)
c00267ac:	3b 44 24 38          	cmp    0x38(%esp),%eax
c00267b0:	0f 86 6e 01 00 00    	jbe    c0026924 <hex_dump+0x1a5>
        end = start + size;
c00267b6:	89 f7                	mov    %esi,%edi
c00267b8:	03 7c 24 38          	add    0x38(%esp),%edi
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c00267bc:	83 ec 04             	sub    $0x4,%esp
c00267bf:	8b 44 24 34          	mov    0x34(%esp),%eax
c00267c3:	83 e0 f0             	and    $0xfffffff0,%eax
c00267c6:	ba 00 00 00 00       	mov    $0x0,%edx
c00267cb:	52                   	push   %edx
c00267cc:	50                   	push   %eax
c00267cd:	68 70 e9 02 c0       	push   $0xc002e970
c00267d2:	e8 7e f8 ff ff       	call   c0026055 <printf>
      for (i = 0; i < start; i++)
c00267d7:	83 c4 10             	add    $0x10,%esp
c00267da:	85 f6                	test   %esi,%esi
c00267dc:	74 26                	je     c0026804 <hex_dump+0x85>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
c00267de:	8b 44 24 38          	mov    0x38(%esp),%eax
c00267e2:	89 44 24 08          	mov    %eax,0x8(%esp)
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
c00267e6:	bb 00 00 00 00       	mov    $0x0,%ebx
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
c00267eb:	83 ec 0c             	sub    $0xc,%esp
c00267ee:	68 78 e9 02 c0       	push   $0xc002e978
c00267f3:	e8 5d f8 ff ff       	call   c0026055 <printf>
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c00267f8:	83 c3 01             	add    $0x1,%ebx
c00267fb:	83 c4 10             	add    $0x10,%esp
c00267fe:	39 de                	cmp    %ebx,%esi
c0026800:	77 e9                	ja     c00267eb <hex_dump+0x6c>
c0026802:	eb 0a                	jmp    c002680e <hex_dump+0x8f>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
c0026804:	8b 44 24 38          	mov    0x38(%esp),%eax
c0026808:	89 44 24 08          	mov    %eax,0x8(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c002680c:	89 f3                	mov    %esi,%ebx
        printf ("   ");
      for (; i < end; i++) 
c002680e:	39 df                	cmp    %ebx,%edi
c0026810:	76 34                	jbe    c0026846 <hex_dump+0xc7>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0026812:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0026816:	29 f5                	sub    %esi,%ebp
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c0026818:	83 fb 07             	cmp    $0x7,%ebx
c002681b:	b8 20 00 00 00       	mov    $0x20,%eax
c0026820:	b9 2d 00 00 00       	mov    $0x2d,%ecx
c0026825:	0f 44 c1             	cmove  %ecx,%eax
c0026828:	83 ec 04             	sub    $0x4,%esp
c002682b:	50                   	push   %eax
c002682c:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
c0026831:	50                   	push   %eax
c0026832:	68 7c e9 02 c0       	push   $0xc002e97c
c0026837:	e8 19 f8 ff ff       	call   c0026055 <printf>

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
c002683c:	83 c3 01             	add    $0x1,%ebx
c002683f:	83 c4 10             	add    $0x10,%esp
c0026842:	39 fb                	cmp    %edi,%ebx
c0026844:	72 d2                	jb     c0026818 <hex_dump+0x99>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
c0026846:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c002684b:	0f 84 ae 00 00 00    	je     c00268ff <hex_dump+0x180>
        {
          for (; i < per_line; i++)
c0026851:	83 fb 0f             	cmp    $0xf,%ebx
c0026854:	77 18                	ja     c002686e <hex_dump+0xef>
            printf ("   ");
c0026856:	83 ec 0c             	sub    $0xc,%esp
c0026859:	68 78 e9 02 c0       	push   $0xc002e978
c002685e:	e8 f2 f7 ff ff       	call   c0026055 <printf>
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
c0026863:	83 c3 01             	add    $0x1,%ebx
c0026866:	83 c4 10             	add    $0x10,%esp
c0026869:	83 fb 10             	cmp    $0x10,%ebx
c002686c:	75 e8                	jne    c0026856 <hex_dump+0xd7>
            printf ("   ");
          printf ("|");
c002686e:	83 ec 0c             	sub    $0xc,%esp
c0026871:	6a 7c                	push   $0x7c
c0026873:	e8 fd 2e 00 00       	call   c0029775 <putchar>
          for (i = 0; i < start; i++)
c0026878:	83 c4 10             	add    $0x10,%esp
c002687b:	85 f6                	test   %esi,%esi
c002687d:	0f 84 d3 00 00 00    	je     c0026956 <hex_dump+0x1d7>
c0026883:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
c0026888:	83 ec 0c             	sub    $0xc,%esp
c002688b:	6a 20                	push   $0x20
c002688d:	e8 e3 2e 00 00       	call   c0029775 <putchar>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0026892:	83 c3 01             	add    $0x1,%ebx
c0026895:	83 c4 10             	add    $0x10,%esp
c0026898:	39 de                	cmp    %ebx,%esi
c002689a:	75 ec                	jne    c0026888 <hex_dump+0x109>
            printf (" ");
          for (; i < end; i++)
c002689c:	39 fe                	cmp    %edi,%esi
c002689e:	73 36                	jae    c00268d6 <hex_dump+0x157>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c00268a0:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00268a2:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c00268a6:	29 f5                	sub    %esi,%ebp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c00268a8:	be 2e 00 00 00       	mov    $0x2e,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c00268ad:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c00268b2:	0f b6 d0             	movzbl %al,%edx
c00268b5:	83 ea 20             	sub    $0x20,%edx
c00268b8:	0f b6 c0             	movzbl %al,%eax
c00268bb:	83 fa 5e             	cmp    $0x5e,%edx
c00268be:	0f 47 c6             	cmova  %esi,%eax
c00268c1:	83 ec 0c             	sub    $0xc,%esp
c00268c4:	50                   	push   %eax
c00268c5:	e8 ab 2e 00 00       	call   c0029775 <putchar>
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
c00268ca:	83 c3 01             	add    $0x1,%ebx
c00268cd:	83 c4 10             	add    $0x10,%esp
c00268d0:	39 fb                	cmp    %edi,%ebx
c00268d2:	72 d9                	jb     c00268ad <hex_dump+0x12e>
c00268d4:	eb 02                	jmp    c00268d8 <hex_dump+0x159>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c00268d6:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c00268d8:	83 fb 0f             	cmp    $0xf,%ebx
c00268db:	77 15                	ja     c00268f2 <hex_dump+0x173>
            printf (" ");
c00268dd:	83 ec 0c             	sub    $0xc,%esp
c00268e0:	6a 20                	push   $0x20
c00268e2:	e8 8e 2e 00 00       	call   c0029775 <putchar>
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c00268e7:	83 c3 01             	add    $0x1,%ebx
c00268ea:	83 c4 10             	add    $0x10,%esp
c00268ed:	83 fb 0f             	cmp    $0xf,%ebx
c00268f0:	76 eb                	jbe    c00268dd <hex_dump+0x15e>
            printf (" ");
          printf ("|");
c00268f2:	83 ec 0c             	sub    $0xc,%esp
c00268f5:	6a 7c                	push   $0x7c
c00268f7:	e8 79 2e 00 00       	call   c0029775 <putchar>
c00268fc:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c00268ff:	83 ec 0c             	sub    $0xc,%esp
c0026902:	6a 0a                	push   $0xa
c0026904:	e8 6c 2e 00 00       	call   c0029775 <putchar>

      ofs += n;
c0026909:	8b 44 24 18          	mov    0x18(%esp),%eax
c002690d:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
c0026911:	01 44 24 44          	add    %eax,0x44(%esp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0026915:	83 c4 10             	add    $0x10,%esp
c0026918:	29 44 24 38          	sub    %eax,0x38(%esp)
c002691c:	0f 85 78 fe ff ff    	jne    c002679a <hex_dump+0x1b>
c0026922:	eb 41                	jmp    c0026965 <hex_dump+0x1e6>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0026924:	83 ec 04             	sub    $0x4,%esp
c0026927:	8b 44 24 34          	mov    0x34(%esp),%eax
c002692b:	83 e0 f0             	and    $0xfffffff0,%eax
c002692e:	ba 00 00 00 00       	mov    $0x0,%edx
c0026933:	52                   	push   %edx
c0026934:	50                   	push   %eax
c0026935:	68 70 e9 02 c0       	push   $0xc002e970
c002693a:	e8 16 f7 ff ff       	call   c0026055 <printf>
      for (i = 0; i < start; i++)
c002693f:	83 c4 10             	add    $0x10,%esp
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
c0026942:	bf 10 00 00 00       	mov    $0x10,%edi
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c0026947:	89 f3                	mov    %esi,%ebx
c0026949:	85 f6                	test   %esi,%esi
c002694b:	0f 84 c1 fe ff ff    	je     c0026812 <hex_dump+0x93>
c0026951:	e9 90 fe ff ff       	jmp    c00267e6 <hex_dump+0x67>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0026956:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
c0026958:	85 ff                	test   %edi,%edi
c002695a:	0f 85 42 ff ff ff    	jne    c00268a2 <hex_dump+0x123>
c0026960:	e9 78 ff ff ff       	jmp    c00268dd <hex_dump+0x15e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
c0026965:	83 c4 1c             	add    $0x1c,%esp
c0026968:	5b                   	pop    %ebx
c0026969:	5e                   	pop    %esi
c002696a:	5f                   	pop    %edi
c002696b:	5d                   	pop    %ebp
c002696c:	c3                   	ret    

c002696d <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c002696d:	57                   	push   %edi
c002696e:	56                   	push   %esi
c002696f:	83 ec 04             	sub    $0x4,%esp
c0026972:	8b 74 24 10          	mov    0x10(%esp),%esi
c0026976:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c002697a:	89 f0                	mov    %esi,%eax
c002697c:	83 f0 01             	xor    $0x1,%eax
c002697f:	09 f8                	or     %edi,%eax
c0026981:	74 22                	je     c00269a5 <print_human_readable_size+0x38>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0026983:	83 ff 00             	cmp    $0x0,%edi
c0026986:	77 0d                	ja     c0026995 <print_human_readable_size+0x28>
c0026988:	b9 e0 79 03 c0       	mov    $0xc00379e0,%ecx
c002698d:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0026993:	76 46                	jbe    c00269db <print_human_readable_size+0x6e>
c0026995:	b9 e0 79 03 c0       	mov    $0xc00379e0,%ecx
c002699a:	83 3d e4 79 03 c0 00 	cmpl   $0x0,0xc00379e4
c00269a1:	75 14                	jne    c00269b7 <print_human_readable_size+0x4a>
c00269a3:	eb 36                	jmp    c00269db <print_human_readable_size+0x6e>
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
  if (size == 1)
    printf ("1 byte");
c00269a5:	83 ec 0c             	sub    $0xc,%esp
c00269a8:	68 85 e9 02 c0       	push   $0xc002e985
c00269ad:	e8 a3 f6 ff ff       	call   c0026055 <printf>
c00269b2:	83 c4 10             	add    $0x10,%esp
c00269b5:	eb 35                	jmp    c00269ec <print_human_readable_size+0x7f>
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
c00269b7:	89 f0                	mov    %esi,%eax
c00269b9:	89 fa                	mov    %edi,%edx
c00269bb:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
c00269bf:	c1 ea 0a             	shr    $0xa,%edx
c00269c2:	89 c6                	mov    %eax,%esi
c00269c4:	89 d7                	mov    %edx,%edi
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00269c6:	83 c1 04             	add    $0x4,%ecx
c00269c9:	83 fa 00             	cmp    $0x0,%edx
c00269cc:	77 07                	ja     c00269d5 <print_human_readable_size+0x68>
c00269ce:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c00269d3:	76 06                	jbe    c00269db <print_human_readable_size+0x6e>
c00269d5:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
c00269d9:	75 dc                	jne    c00269b7 <print_human_readable_size+0x4a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
c00269db:	ff 31                	pushl  (%ecx)
c00269dd:	57                   	push   %edi
c00269de:	56                   	push   %esi
c00269df:	68 8c e9 02 c0       	push   $0xc002e98c
c00269e4:	e8 6c f6 ff ff       	call   c0026055 <printf>
c00269e9:	83 c4 10             	add    $0x10,%esp
    }
}
c00269ec:	83 c4 04             	add    $0x4,%esp
c00269ef:	5e                   	pop    %esi
c00269f0:	5f                   	pop    %edi
c00269f1:	c3                   	ret    

c00269f2 <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00269f2:	83 ec 14             	sub    $0x14,%esp
  int (**compare) (const void *, const void *) = aux;
  return (*compare) (a, b);
c00269f5:	ff 74 24 1c          	pushl  0x1c(%esp)
c00269f9:	ff 74 24 1c          	pushl  0x1c(%esp)
c00269fd:	8b 44 24 28          	mov    0x28(%esp),%eax
c0026a01:	ff 10                	call   *(%eax)
}
c0026a03:	83 c4 1c             	add    $0x1c,%esp
c0026a06:	c3                   	ret    

c0026a07 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0026a07:	55                   	push   %ebp
c0026a08:	57                   	push   %edi
c0026a09:	56                   	push   %esi
c0026a0a:	53                   	push   %ebx
c0026a0b:	8b 74 24 14          	mov    0x14(%esp),%esi
  unsigned char *a = array + (a_idx - 1) * size;
c0026a0f:	83 ea 01             	sub    $0x1,%edx
c0026a12:	0f af d6             	imul   %esi,%edx
  unsigned char *b = array + (b_idx - 1) * size;
c0026a15:	83 e9 01             	sub    $0x1,%ecx
c0026a18:	0f af ce             	imul   %esi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c0026a1b:	85 f6                	test   %esi,%esi
c0026a1d:	74 21                	je     c0026a40 <do_swap+0x39>
c0026a1f:	89 d5                	mov    %edx,%ebp
c0026a21:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
c0026a24:	8d 3c 16             	lea    (%esi,%edx,1),%edi
c0026a27:	01 c7                	add    %eax,%edi
    {
      unsigned char t = a[i];
c0026a29:	0f b6 03             	movzbl (%ebx),%eax
c0026a2c:	89 de                	mov    %ebx,%esi
c0026a2e:	29 ee                	sub    %ebp,%esi
      a[i] = b[i];
c0026a30:	0f b6 14 0e          	movzbl (%esi,%ecx,1),%edx
c0026a34:	88 13                	mov    %dl,(%ebx)
      b[i] = t;
c0026a36:	88 04 0e             	mov    %al,(%esi,%ecx,1)
c0026a39:	83 c3 01             	add    $0x1,%ebx
{
  unsigned char *a = array + (a_idx - 1) * size;
  unsigned char *b = array + (b_idx - 1) * size;
  size_t i;

  for (i = 0; i < size; i++)
c0026a3c:	39 fb                	cmp    %edi,%ebx
c0026a3e:	75 e9                	jne    c0026a29 <do_swap+0x22>
    {
      unsigned char t = a[i];
      a[i] = b[i];
      b[i] = t;
    }
}
c0026a40:	5b                   	pop    %ebx
c0026a41:	5e                   	pop    %esi
c0026a42:	5f                   	pop    %edi
c0026a43:	5d                   	pop    %ebp
c0026a44:	c3                   	ret    

c0026a45 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0026a45:	55                   	push   %ebp
c0026a46:	57                   	push   %edi
c0026a47:	56                   	push   %esi
c0026a48:	53                   	push   %ebx
c0026a49:	83 ec 1c             	sub    $0x1c,%esp
c0026a4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0026a50:	89 d7                	mov    %edx,%edi
c0026a52:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0026a56:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c0026a5a:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
      size_t right = 2 * i + 1;
c0026a5d:	8d 73 01             	lea    0x1(%ebx),%esi
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0026a60:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c0026a64:	77 79                	ja     c0026adf <heapify+0x9a>
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0026a66:	83 ec 04             	sub    $0x4,%esp
c0026a69:	ff 74 24 3c          	pushl  0x3c(%esp)
c0026a6d:	8d 47 ff             	lea    -0x1(%edi),%eax
c0026a70:	0f af c5             	imul   %ebp,%eax
c0026a73:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0026a77:	01 c8                	add    %ecx,%eax
c0026a79:	50                   	push   %eax
c0026a7a:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0026a7d:	0f af c5             	imul   %ebp,%eax
c0026a80:	01 c8                	add    %ecx,%eax
c0026a82:	50                   	push   %eax
c0026a83:	ff 54 24 44          	call   *0x44(%esp)
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0026a87:	83 c4 10             	add    $0x10,%esp
c0026a8a:	85 c0                	test   %eax,%eax
c0026a8c:	7e 51                	jle    c0026adf <heapify+0x9a>
        max = left;
      if (right <= cnt
c0026a8e:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0026a92:	77 2a                	ja     c0026abe <heapify+0x79>
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0026a94:	83 ec 04             	sub    $0x4,%esp
c0026a97:	ff 74 24 3c          	pushl  0x3c(%esp)
c0026a9b:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0026a9e:	0f af c5             	imul   %ebp,%eax
c0026aa1:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0026aa5:	01 c8                	add    %ecx,%eax
c0026aa7:	50                   	push   %eax
c0026aa8:	89 d8                	mov    %ebx,%eax
c0026aaa:	0f af c5             	imul   %ebp,%eax
c0026aad:	01 c8                	add    %ecx,%eax
c0026aaf:	50                   	push   %eax
c0026ab0:	ff 54 24 44          	call   *0x44(%esp)
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
        max = left;
      if (right <= cnt
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0026ab4:	83 c4 10             	add    $0x10,%esp
c0026ab7:	85 c0                	test   %eax,%eax
         and its children (if any). */
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
        max = left;
c0026ab9:	0f 4e f3             	cmovle %ebx,%esi
c0026abc:	eb 02                	jmp    c0026ac0 <heapify+0x7b>
c0026abe:	89 de                	mov    %ebx,%esi
          && do_compare (array, right, max, size, compare, aux) > 0) 
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0026ac0:	39 f7                	cmp    %esi,%edi
c0026ac2:	74 46                	je     c0026b0a <heapify+0xc5>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0026ac4:	83 ec 0c             	sub    $0xc,%esp
c0026ac7:	55                   	push   %ebp
c0026ac8:	89 f1                	mov    %esi,%ecx
c0026aca:	89 fa                	mov    %edi,%edx
c0026acc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0026ad0:	e8 32 ff ff ff       	call   c0026a07 <do_swap>
      i = max;
    }
c0026ad5:	83 c4 10             	add    $0x10,%esp
c0026ad8:	89 f7                	mov    %esi,%edi
c0026ada:	e9 7b ff ff ff       	jmp    c0026a5a <heapify+0x15>
      size_t left = 2 * i;
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
        max = left;
      if (right <= cnt
c0026adf:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0026ae3:	77 25                	ja     c0026b0a <heapify+0xc5>
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0026ae5:	83 ec 04             	sub    $0x4,%esp
c0026ae8:	ff 74 24 3c          	pushl  0x3c(%esp)
c0026aec:	8d 47 ff             	lea    -0x1(%edi),%eax
c0026aef:	0f af c5             	imul   %ebp,%eax
c0026af2:	8b 54 24 14          	mov    0x14(%esp),%edx
c0026af6:	01 d0                	add    %edx,%eax
c0026af8:	50                   	push   %eax
c0026af9:	0f af dd             	imul   %ebp,%ebx
c0026afc:	01 d3                	add    %edx,%ebx
c0026afe:	53                   	push   %ebx
c0026aff:	ff 54 24 44          	call   *0x44(%esp)
      size_t right = 2 * i + 1;
      size_t max = i;
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
        max = left;
      if (right <= cnt
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0026b03:	83 c4 10             	add    $0x10,%esp
c0026b06:	85 c0                	test   %eax,%eax
c0026b08:	7f b6                	jg     c0026ac0 <heapify+0x7b>

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
      i = max;
    }
}
c0026b0a:	83 c4 1c             	add    $0x1c,%esp
c0026b0d:	5b                   	pop    %ebx
c0026b0e:	5e                   	pop    %esi
c0026b0f:	5f                   	pop    %edi
c0026b10:	5d                   	pop    %ebp
c0026b11:	c3                   	ret    

c0026b12 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0026b12:	56                   	push   %esi
c0026b13:	53                   	push   %ebx
c0026b14:	83 ec 04             	sub    $0x4,%esp
c0026b17:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  bool negative;
  int value;

  ASSERT (s != NULL);
c0026b1b:	85 c9                	test   %ecx,%ecx
c0026b1d:	75 23                	jne    c0026b42 <atoi+0x30>
c0026b1f:	83 ec 0c             	sub    $0xc,%esp
c0026b22:	68 d2 ea 02 c0       	push   $0xc002ead2
c0026b27:	68 3f d2 02 c0       	push   $0xc002d23f
c0026b2c:	68 b8 cc 02 c0       	push   $0xc002ccb8
c0026b31:	6a 0f                	push   $0xf
c0026b33:	68 dc e9 02 c0       	push   $0xc002e9dc
c0026b38:	e8 90 11 00 00       	call   c0027ccd <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0026b3d:	83 c1 01             	add    $0x1,%ecx
c0026b40:	eb 05                	jmp    c0026b47 <atoi+0x35>
c0026b42:	bb 0d 00 40 00       	mov    $0x40000d,%ebx
  int value;

  ASSERT (s != NULL);

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
c0026b47:	0f b6 11             	movzbl (%ecx),%edx
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c0026b4a:	8d 42 f6             	lea    -0xa(%edx),%eax
c0026b4d:	3c 16                	cmp    $0x16,%al
c0026b4f:	77 05                	ja     c0026b56 <atoi+0x44>
          || c == '\r' || c == '\t' || c == '\v');
c0026b51:	0f a3 c3             	bt     %eax,%ebx
c0026b54:	72 e7                	jb     c0026b3d <atoi+0x2b>
c0026b56:	89 d0                	mov    %edx,%eax
c0026b58:	83 e0 fd             	and    $0xfffffffd,%eax
c0026b5b:	3c 09                	cmp    $0x9,%al
c0026b5d:	74 de                	je     c0026b3d <atoi+0x2b>
    s++;

  /* Parse sign. */
  negative = false;
  if (*s == '+')
c0026b5f:	80 fa 2b             	cmp    $0x2b,%dl
c0026b62:	75 05                	jne    c0026b69 <atoi+0x57>
    s++;
c0026b64:	83 c1 01             	add    $0x1,%ecx
c0026b67:	eb 55                	jmp    c0026bbe <atoi+0xac>
  else if (*s == '-')
c0026b69:	80 fa 2d             	cmp    $0x2d,%dl
c0026b6c:	75 50                	jne    c0026bbe <atoi+0xac>

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0026b6e:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c0026b72:	0f be da             	movsbl %dl,%ebx
c0026b75:	83 eb 30             	sub    $0x30,%ebx
c0026b78:	b8 00 00 00 00       	mov    $0x0,%eax
c0026b7d:	83 fb 09             	cmp    $0x9,%ebx
c0026b80:	77 51                	ja     c0026bd3 <atoi+0xc1>
  if (*s == '+')
    s++;
  else if (*s == '-')
    {
      negative = true;
      s++;
c0026b82:	83 c1 01             	add    $0x1,%ecx
  negative = false;
  if (*s == '+')
    s++;
  else if (*s == '-')
    {
      negative = true;
c0026b85:	be 01 00 00 00       	mov    $0x1,%esi
c0026b8a:	eb 05                	jmp    c0026b91 <atoi+0x7f>

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0026b8c:	be 00 00 00 00       	mov    $0x0,%esi
c0026b91:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c0026b96:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0026b99:	01 c0                	add    %eax,%eax
c0026b9b:	0f be d2             	movsbl %dl,%edx
c0026b9e:	83 ea 30             	sub    $0x30,%edx
c0026ba1:	29 d0                	sub    %edx,%eax

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0026ba3:	83 c1 01             	add    $0x1,%ecx
c0026ba6:	0f b6 11             	movzbl (%ecx),%edx
c0026ba9:	0f be da             	movsbl %dl,%ebx
c0026bac:	83 eb 30             	sub    $0x30,%ebx
c0026baf:	83 fb 09             	cmp    $0x9,%ebx
c0026bb2:	76 e2                	jbe    c0026b96 <atoi+0x84>
    value = value * 10 - (*s - '0');
  if (!negative)
c0026bb4:	89 f1                	mov    %esi,%ecx
c0026bb6:	84 c9                	test   %cl,%cl
c0026bb8:	75 19                	jne    c0026bd3 <atoi+0xc1>
    value = -value;
c0026bba:	f7 d8                	neg    %eax
c0026bbc:	eb 15                	jmp    c0026bd3 <atoi+0xc1>

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0026bbe:	0f b6 11             	movzbl (%ecx),%edx
c0026bc1:	0f be c2             	movsbl %dl,%eax
c0026bc4:	83 e8 30             	sub    $0x30,%eax
c0026bc7:	83 f8 09             	cmp    $0x9,%eax
c0026bca:	76 c0                	jbe    c0026b8c <atoi+0x7a>
c0026bcc:	b8 00 00 00 00       	mov    $0x0,%eax
c0026bd1:	eb e7                	jmp    c0026bba <atoi+0xa8>
    value = value * 10 - (*s - '0');
  if (!negative)
    value = -value;

  return value;
}
c0026bd3:	83 c4 04             	add    $0x4,%esp
c0026bd6:	5b                   	pop    %ebx
c0026bd7:	5e                   	pop    %esi
c0026bd8:	c3                   	ret    

c0026bd9 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0026bd9:	55                   	push   %ebp
c0026bda:	57                   	push   %edi
c0026bdb:	56                   	push   %esi
c0026bdc:	53                   	push   %ebx
c0026bdd:	83 ec 0c             	sub    $0xc,%esp
c0026be0:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0026be4:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0026be8:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0026bec:	85 ff                	test   %edi,%edi
c0026bee:	75 25                	jne    c0026c15 <sort+0x3c>
c0026bf0:	85 db                	test   %ebx,%ebx
c0026bf2:	74 21                	je     c0026c15 <sort+0x3c>
c0026bf4:	83 ec 0c             	sub    $0xc,%esp
c0026bf7:	68 ef e9 02 c0       	push   $0xc002e9ef
c0026bfc:	68 3f d2 02 c0       	push   $0xc002d23f
c0026c01:	68 b0 cc 02 c0       	push   $0xc002ccb0
c0026c06:	68 8a 00 00 00       	push   $0x8a
c0026c0b:	68 dc e9 02 c0       	push   $0xc002e9dc
c0026c10:	e8 b8 10 00 00       	call   c0027ccd <debug_panic>
  ASSERT (compare != NULL);
c0026c15:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0026c1a:	75 21                	jne    c0026c3d <sort+0x64>
c0026c1c:	83 ec 0c             	sub    $0xc,%esp
c0026c1f:	68 09 ea 02 c0       	push   $0xc002ea09
c0026c24:	68 3f d2 02 c0       	push   $0xc002d23f
c0026c29:	68 b0 cc 02 c0       	push   $0xc002ccb0
c0026c2e:	68 8b 00 00 00       	push   $0x8b
c0026c33:	68 dc e9 02 c0       	push   $0xc002e9dc
c0026c38:	e8 90 10 00 00       	call   c0027ccd <debug_panic>
  ASSERT (size > 0);
c0026c3d:	85 ed                	test   %ebp,%ebp
c0026c3f:	75 21                	jne    c0026c62 <sort+0x89>
c0026c41:	83 ec 0c             	sub    $0xc,%esp
c0026c44:	68 19 ea 02 c0       	push   $0xc002ea19
c0026c49:	68 3f d2 02 c0       	push   $0xc002d23f
c0026c4e:	68 b0 cc 02 c0       	push   $0xc002ccb0
c0026c53:	68 8c 00 00 00       	push   $0x8c
c0026c58:	68 dc e9 02 c0       	push   $0xc002e9dc
c0026c5d:	e8 6b 10 00 00       	call   c0027ccd <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0026c62:	89 de                	mov    %ebx,%esi
c0026c64:	d1 ee                	shr    %esi
c0026c66:	74 33                	je     c0026c9b <sort+0xc2>
c0026c68:	89 5c 24 24          	mov    %ebx,0x24(%esp)
c0026c6c:	89 fb                	mov    %edi,%ebx
c0026c6e:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify (array, i, cnt, size, compare, aux);
c0026c72:	83 ec 04             	sub    $0x4,%esp
c0026c75:	ff 74 24 34          	pushl  0x34(%esp)
c0026c79:	ff 74 24 34          	pushl  0x34(%esp)
c0026c7d:	55                   	push   %ebp
c0026c7e:	89 f9                	mov    %edi,%ecx
c0026c80:	89 f2                	mov    %esi,%edx
c0026c82:	89 d8                	mov    %ebx,%eax
c0026c84:	e8 bc fd ff ff       	call   c0026a45 <heapify>
  ASSERT (array != NULL || cnt == 0);
  ASSERT (compare != NULL);
  ASSERT (size > 0);

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0026c89:	83 c4 10             	add    $0x10,%esp
c0026c8c:	83 ee 01             	sub    $0x1,%esi
c0026c8f:	75 e1                	jne    c0026c72 <sort+0x99>
c0026c91:	89 7c 24 24          	mov    %edi,0x24(%esp)
c0026c95:	89 df                	mov    %ebx,%edi
c0026c97:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0026c9b:	83 fb 01             	cmp    $0x1,%ebx
c0026c9e:	76 3a                	jbe    c0026cda <sort+0x101>
c0026ca0:	89 fe                	mov    %edi,%esi
c0026ca2:	8b 7c 24 30          	mov    0x30(%esp),%edi
    {
      do_swap (array, 1, i, size);
c0026ca6:	83 ec 0c             	sub    $0xc,%esp
c0026ca9:	55                   	push   %ebp
c0026caa:	89 d9                	mov    %ebx,%ecx
c0026cac:	ba 01 00 00 00       	mov    $0x1,%edx
c0026cb1:	89 f0                	mov    %esi,%eax
c0026cb3:	e8 4f fd ff ff       	call   c0026a07 <do_swap>
      heapify (array, 1, i - 1, size, compare, aux); 
c0026cb8:	83 eb 01             	sub    $0x1,%ebx
c0026cbb:	83 c4 0c             	add    $0xc,%esp
c0026cbe:	57                   	push   %edi
c0026cbf:	ff 74 24 34          	pushl  0x34(%esp)
c0026cc3:	55                   	push   %ebp
c0026cc4:	89 d9                	mov    %ebx,%ecx
c0026cc6:	ba 01 00 00 00       	mov    $0x1,%edx
c0026ccb:	89 f0                	mov    %esi,%eax
c0026ccd:	e8 73 fd ff ff       	call   c0026a45 <heapify>
  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0026cd2:	83 c4 10             	add    $0x10,%esp
c0026cd5:	83 fb 01             	cmp    $0x1,%ebx
c0026cd8:	75 cc                	jne    c0026ca6 <sort+0xcd>
    {
      do_swap (array, 1, i, size);
      heapify (array, 1, i - 1, size, compare, aux); 
    }
}
c0026cda:	83 c4 0c             	add    $0xc,%esp
c0026cdd:	5b                   	pop    %ebx
c0026cde:	5e                   	pop    %esi
c0026cdf:	5f                   	pop    %edi
c0026ce0:	5d                   	pop    %ebp
c0026ce1:	c3                   	ret    

c0026ce2 <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0026ce2:	83 ec 18             	sub    $0x18,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0026ce5:	8d 44 24 28          	lea    0x28(%esp),%eax
c0026ce9:	50                   	push   %eax
c0026cea:	68 f2 69 02 c0       	push   $0xc00269f2
c0026cef:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026cf3:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026cf7:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026cfb:	e8 d9 fe ff ff       	call   c0026bd9 <sort>
}
c0026d00:	83 c4 2c             	add    $0x2c,%esp
c0026d03:	c3                   	ret    

c0026d04 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0026d04:	55                   	push   %ebp
c0026d05:	57                   	push   %edi
c0026d06:	56                   	push   %esi
c0026d07:	53                   	push   %ebx
c0026d08:	83 ec 0c             	sub    $0xc,%esp
c0026d0b:	8b 74 24 24          	mov    0x24(%esp),%esi
c0026d0f:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c0026d13:	89 fd                	mov    %edi,%ebp
c0026d15:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0026d1a:	01 f5                	add    %esi,%ebp

  while (first < last) 
c0026d1c:	39 ee                	cmp    %ebp,%esi
c0026d1e:	73 40                	jae    c0026d60 <binary_search+0x5c>
    {
      size_t range = (last - first) / size;
      const unsigned char *middle = first + (range / 2) * size;
c0026d20:	89 e8                	mov    %ebp,%eax
c0026d22:	29 f0                	sub    %esi,%eax
c0026d24:	ba 00 00 00 00       	mov    $0x0,%edx
c0026d29:	f7 f7                	div    %edi
c0026d2b:	d1 e8                	shr    %eax
c0026d2d:	0f af c7             	imul   %edi,%eax
c0026d30:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      int cmp = compare (key, middle, aux);
c0026d33:	83 ec 04             	sub    $0x4,%esp
c0026d36:	ff 74 24 38          	pushl  0x38(%esp)
c0026d3a:	53                   	push   %ebx
c0026d3b:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026d3f:	ff 54 24 40          	call   *0x40(%esp)

      if (cmp < 0) 
c0026d43:	83 c4 10             	add    $0x10,%esp
c0026d46:	85 c0                	test   %eax,%eax
c0026d48:	78 09                	js     c0026d53 <binary_search+0x4f>
        last = middle;
      else if (cmp > 0) 
c0026d4a:	85 c0                	test   %eax,%eax
c0026d4c:	7e 19                	jle    c0026d67 <binary_search+0x63>
        first = middle + size;
c0026d4e:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0026d51:	eb 02                	jmp    c0026d55 <binary_search+0x51>
  const unsigned char *last = array + size * cnt;

  while (first < last) 
    {
      size_t range = (last - first) / size;
      const unsigned char *middle = first + (range / 2) * size;
c0026d53:	89 dd                	mov    %ebx,%ebp
               void *aux) 
{
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;

  while (first < last) 
c0026d55:	39 f5                	cmp    %esi,%ebp
c0026d57:	77 c7                	ja     c0026d20 <binary_search+0x1c>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c0026d59:	b8 00 00 00 00       	mov    $0x0,%eax
c0026d5e:	eb 09                	jmp    c0026d69 <binary_search+0x65>
c0026d60:	b8 00 00 00 00       	mov    $0x0,%eax
c0026d65:	eb 02                	jmp    c0026d69 <binary_search+0x65>
  const unsigned char *last = array + size * cnt;

  while (first < last) 
    {
      size_t range = (last - first) / size;
      const unsigned char *middle = first + (range / 2) * size;
c0026d67:	89 d8                	mov    %ebx,%eax
      else
        return (void *) middle;
    }
  
  return NULL;
}
c0026d69:	83 c4 0c             	add    $0xc,%esp
c0026d6c:	5b                   	pop    %ebx
c0026d6d:	5e                   	pop    %esi
c0026d6e:	5f                   	pop    %edi
c0026d6f:	5d                   	pop    %ebp
c0026d70:	c3                   	ret    

c0026d71 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c0026d71:	83 ec 14             	sub    $0x14,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0026d74:	8d 44 24 28          	lea    0x28(%esp),%eax
c0026d78:	50                   	push   %eax
c0026d79:	68 f2 69 02 c0       	push   $0xc00269f2
c0026d7e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026d82:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026d86:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026d8a:	ff 74 24 2c          	pushl  0x2c(%esp)
c0026d8e:	e8 71 ff ff ff       	call   c0026d04 <binary_search>
}
c0026d93:	83 c4 2c             	add    $0x2c,%esp
c0026d96:	c3                   	ret    

c0026d97 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0026d97:	56                   	push   %esi
c0026d98:	53                   	push   %ebx
c0026d99:	83 ec 04             	sub    $0x4,%esp
c0026d9c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0026da0:	8b 74 24 14          	mov    0x14(%esp),%esi
c0026da4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
c0026da8:	85 db                	test   %ebx,%ebx
c0026daa:	0f 94 c2             	sete   %dl
c0026dad:	85 c0                	test   %eax,%eax
c0026daf:	75 22                	jne    c0026dd3 <memcpy+0x3c>
c0026db1:	84 d2                	test   %dl,%dl
c0026db3:	75 1e                	jne    c0026dd3 <memcpy+0x3c>
c0026db5:	83 ec 0c             	sub    $0xc,%esp
c0026db8:	68 22 ea 02 c0       	push   $0xc002ea22
c0026dbd:	68 3f d2 02 c0       	push   $0xc002d23f
c0026dc2:	68 14 cd 02 c0       	push   $0xc002cd14
c0026dc7:	6a 0c                	push   $0xc
c0026dc9:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026dce:	e8 fa 0e 00 00       	call   c0027ccd <debug_panic>
  ASSERT (src != NULL || size == 0);
c0026dd3:	85 f6                	test   %esi,%esi
c0026dd5:	75 04                	jne    c0026ddb <memcpy+0x44>
c0026dd7:	84 d2                	test   %dl,%dl
c0026dd9:	74 0b                	je     c0026de6 <memcpy+0x4f>

  while (size-- > 0)
c0026ddb:	ba 00 00 00 00       	mov    $0x0,%edx
c0026de0:	85 db                	test   %ebx,%ebx
c0026de2:	75 20                	jne    c0026e04 <memcpy+0x6d>
c0026de4:	eb 2c                	jmp    c0026e12 <memcpy+0x7b>
{
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);
c0026de6:	83 ec 0c             	sub    $0xc,%esp
c0026de9:	68 4e ea 02 c0       	push   $0xc002ea4e
c0026dee:	68 3f d2 02 c0       	push   $0xc002d23f
c0026df3:	68 14 cd 02 c0       	push   $0xc002cd14
c0026df8:	6a 0d                	push   $0xd
c0026dfa:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026dff:	e8 c9 0e 00 00       	call   c0027ccd <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0026e04:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c0026e08:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c0026e0b:	83 c2 01             	add    $0x1,%edx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0026e0e:	39 da                	cmp    %ebx,%edx
c0026e10:	75 f2                	jne    c0026e04 <memcpy+0x6d>
    *dst++ = *src++;

  return dst_;
}
c0026e12:	83 c4 04             	add    $0x4,%esp
c0026e15:	5b                   	pop    %ebx
c0026e16:	5e                   	pop    %esi
c0026e17:	c3                   	ret    

c0026e18 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0026e18:	57                   	push   %edi
c0026e19:	56                   	push   %esi
c0026e1a:	53                   	push   %ebx
c0026e1b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0026e1f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0026e23:	8b 7c 24 18          	mov    0x18(%esp),%edi
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
c0026e27:	85 ff                	test   %edi,%edi
c0026e29:	0f 94 c2             	sete   %dl
c0026e2c:	85 c0                	test   %eax,%eax
c0026e2e:	75 22                	jne    c0026e52 <memmove+0x3a>
c0026e30:	84 d2                	test   %dl,%dl
c0026e32:	75 1e                	jne    c0026e52 <memmove+0x3a>
c0026e34:	83 ec 0c             	sub    $0xc,%esp
c0026e37:	68 22 ea 02 c0       	push   $0xc002ea22
c0026e3c:	68 3f d2 02 c0       	push   $0xc002d23f
c0026e41:	68 0c cd 02 c0       	push   $0xc002cd0c
c0026e46:	6a 1d                	push   $0x1d
c0026e48:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026e4d:	e8 7b 0e 00 00       	call   c0027ccd <debug_panic>
  ASSERT (src != NULL || size == 0);
c0026e52:	85 db                	test   %ebx,%ebx
c0026e54:	75 22                	jne    c0026e78 <memmove+0x60>
c0026e56:	84 d2                	test   %dl,%dl
c0026e58:	75 1e                	jne    c0026e78 <memmove+0x60>
c0026e5a:	83 ec 0c             	sub    $0xc,%esp
c0026e5d:	68 4e ea 02 c0       	push   $0xc002ea4e
c0026e62:	68 3f d2 02 c0       	push   $0xc002d23f
c0026e67:	68 0c cd 02 c0       	push   $0xc002cd0c
c0026e6c:	6a 1e                	push   $0x1e
c0026e6e:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026e73:	e8 55 0e 00 00       	call   c0027ccd <debug_panic>

  if (dst < src) 
c0026e78:	39 d8                	cmp    %ebx,%eax
c0026e7a:	73 1b                	jae    c0026e97 <memmove+0x7f>
    {
      while (size-- > 0)
c0026e7c:	85 ff                	test   %edi,%edi
c0026e7e:	74 38                	je     c0026eb8 <memmove+0xa0>
c0026e80:	ba 00 00 00 00       	mov    $0x0,%edx
        *dst++ = *src++;
c0026e85:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
c0026e89:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c0026e8c:	83 c2 01             	add    $0x1,%edx
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
c0026e8f:	39 fa                	cmp    %edi,%edx
c0026e91:	75 f2                	jne    c0026e85 <memmove+0x6d>
c0026e93:	01 f8                	add    %edi,%eax
c0026e95:	eb 21                	jmp    c0026eb8 <memmove+0xa0>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
c0026e97:	8d 34 38             	lea    (%eax,%edi,1),%esi
      src += size;
      while (size-- > 0)
c0026e9a:	8d 57 ff             	lea    -0x1(%edi),%edx
c0026e9d:	85 ff                	test   %edi,%edi
c0026e9f:	74 15                	je     c0026eb6 <memmove+0x9e>
c0026ea1:	89 f0                	mov    %esi,%eax
c0026ea3:	29 f8                	sub    %edi,%eax
        *--dst = *--src;
c0026ea5:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
c0026ea9:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
c0026eac:	83 ea 01             	sub    $0x1,%edx
c0026eaf:	83 fa ff             	cmp    $0xffffffff,%edx
c0026eb2:	75 ed                	jne    c0026ea1 <memmove+0x89>
c0026eb4:	eb 02                	jmp    c0026eb8 <memmove+0xa0>
      while (size-- > 0)
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
c0026eb6:	89 f0                	mov    %esi,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
c0026eb8:	5b                   	pop    %ebx
c0026eb9:	5e                   	pop    %esi
c0026eba:	5f                   	pop    %edi
c0026ebb:	c3                   	ret    

c0026ebc <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0026ebc:	57                   	push   %edi
c0026ebd:	56                   	push   %esi
c0026ebe:	53                   	push   %ebx
c0026ebf:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0026ec3:	8b 74 24 14          	mov    0x14(%esp),%esi
c0026ec7:	8b 44 24 18          	mov    0x18(%esp),%eax
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
c0026ecb:	85 c0                	test   %eax,%eax
c0026ecd:	0f 94 c2             	sete   %dl
c0026ed0:	85 db                	test   %ebx,%ebx
c0026ed2:	75 22                	jne    c0026ef6 <memcmp+0x3a>
c0026ed4:	84 d2                	test   %dl,%dl
c0026ed6:	75 1e                	jne    c0026ef6 <memcmp+0x3a>
c0026ed8:	83 ec 0c             	sub    $0xc,%esp
c0026edb:	68 67 ea 02 c0       	push   $0xc002ea67
c0026ee0:	68 3f d2 02 c0       	push   $0xc002d23f
c0026ee5:	68 04 cd 02 c0       	push   $0xc002cd04
c0026eea:	6a 3a                	push   $0x3a
c0026eec:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026ef1:	e8 d7 0d 00 00       	call   c0027ccd <debug_panic>
  ASSERT (b != NULL || size == 0);
c0026ef6:	85 f6                	test   %esi,%esi
c0026ef8:	75 04                	jne    c0026efe <memcmp+0x42>
c0026efa:	84 d2                	test   %dl,%dl
c0026efc:	74 18                	je     c0026f16 <memcmp+0x5a>

  for (; size-- > 0; a++, b++)
c0026efe:	8d 78 ff             	lea    -0x1(%eax),%edi
c0026f01:	85 c0                	test   %eax,%eax
c0026f03:	74 56                	je     c0026f5b <memcmp+0x9f>
    if (*a != *b)
c0026f05:	0f b6 13             	movzbl (%ebx),%edx
c0026f08:	0f b6 0e             	movzbl (%esi),%ecx
c0026f0b:	38 ca                	cmp    %cl,%dl
c0026f0d:	75 35                	jne    c0026f44 <memcmp+0x88>
c0026f0f:	b8 00 00 00 00       	mov    $0x0,%eax
c0026f14:	eb 3a                	jmp    c0026f50 <memcmp+0x94>
{
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);
c0026f16:	83 ec 0c             	sub    $0xc,%esp
c0026f19:	68 7e ea 02 c0       	push   $0xc002ea7e
c0026f1e:	68 3f d2 02 c0       	push   $0xc002d23f
c0026f23:	68 04 cd 02 c0       	push   $0xc002cd04
c0026f28:	6a 3b                	push   $0x3b
c0026f2a:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026f2f:	e8 99 0d 00 00       	call   c0027ccd <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0026f34:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
c0026f39:	83 c0 01             	add    $0x1,%eax
c0026f3c:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
c0026f40:	38 ca                	cmp    %cl,%dl
c0026f42:	74 0c                	je     c0026f50 <memcmp+0x94>
      return *a > *b ? +1 : -1;
c0026f44:	38 d1                	cmp    %dl,%cl
c0026f46:	19 c0                	sbb    %eax,%eax
c0026f48:	83 e0 02             	and    $0x2,%eax
c0026f4b:	83 e8 01             	sub    $0x1,%eax
c0026f4e:	eb 10                	jmp    c0026f60 <memcmp+0xa4>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0026f50:	39 f8                	cmp    %edi,%eax
c0026f52:	75 e0                	jne    c0026f34 <memcmp+0x78>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
c0026f54:	b8 00 00 00 00       	mov    $0x0,%eax
c0026f59:	eb 05                	jmp    c0026f60 <memcmp+0xa4>
c0026f5b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0026f60:	5b                   	pop    %ebx
c0026f61:	5e                   	pop    %esi
c0026f62:	5f                   	pop    %edi
c0026f63:	c3                   	ret    

c0026f64 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0026f64:	83 ec 0c             	sub    $0xc,%esp
c0026f67:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0026f6b:	8b 54 24 14          	mov    0x14(%esp),%edx
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
c0026f6f:	85 c9                	test   %ecx,%ecx
c0026f71:	75 1e                	jne    c0026f91 <strcmp+0x2d>
c0026f73:	83 ec 0c             	sub    $0xc,%esp
c0026f76:	68 8d da 02 c0       	push   $0xc002da8d
c0026f7b:	68 3f d2 02 c0       	push   $0xc002d23f
c0026f80:	68 fc cc 02 c0       	push   $0xc002ccfc
c0026f85:	6a 4e                	push   $0x4e
c0026f87:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026f8c:	e8 3c 0d 00 00       	call   c0027ccd <debug_panic>
  ASSERT (b != NULL);
c0026f91:	85 d2                	test   %edx,%edx
c0026f93:	74 0d                	je     c0026fa2 <strcmp+0x3e>

  while (*a != '\0' && *a == *b) 
c0026f95:	0f b6 01             	movzbl (%ecx),%eax
c0026f98:	84 c0                	test   %al,%al
c0026f9a:	74 35                	je     c0026fd1 <strcmp+0x6d>
c0026f9c:	3a 02                	cmp    (%edx),%al
c0026f9e:	74 20                	je     c0026fc0 <strcmp+0x5c>
c0026fa0:	eb 2f                	jmp    c0026fd1 <strcmp+0x6d>
{
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);
c0026fa2:	83 ec 0c             	sub    $0xc,%esp
c0026fa5:	68 95 ea 02 c0       	push   $0xc002ea95
c0026faa:	68 3f d2 02 c0       	push   $0xc002d23f
c0026faf:	68 fc cc 02 c0       	push   $0xc002ccfc
c0026fb4:	6a 4f                	push   $0x4f
c0026fb6:	68 3b ea 02 c0       	push   $0xc002ea3b
c0026fbb:	e8 0d 0d 00 00       	call   c0027ccd <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0026fc0:	83 c1 01             	add    $0x1,%ecx
      b++;
c0026fc3:	83 c2 01             	add    $0x1,%edx
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0026fc6:	0f b6 01             	movzbl (%ecx),%eax
c0026fc9:	84 c0                	test   %al,%al
c0026fcb:	74 04                	je     c0026fd1 <strcmp+0x6d>
c0026fcd:	3a 02                	cmp    (%edx),%al
c0026fcf:	74 ef                	je     c0026fc0 <strcmp+0x5c>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
c0026fd1:	0f b6 12             	movzbl (%edx),%edx
c0026fd4:	38 c2                	cmp    %al,%dl
c0026fd6:	77 08                	ja     c0026fe0 <strcmp+0x7c>
c0026fd8:	0f 92 c0             	setb   %al
c0026fdb:	0f b6 c0             	movzbl %al,%eax
c0026fde:	eb 05                	jmp    c0026fe5 <strcmp+0x81>
c0026fe0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0026fe5:	83 c4 0c             	add    $0xc,%esp
c0026fe8:	c3                   	ret    

c0026fe9 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0026fe9:	53                   	push   %ebx
c0026fea:	83 ec 08             	sub    $0x8,%esp
c0026fed:	8b 44 24 10          	mov    0x10(%esp),%eax
c0026ff1:	8b 54 24 14          	mov    0x14(%esp),%edx
c0026ff5:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  const unsigned char *block = block_;
  unsigned char ch = ch_;
c0026ff9:	89 d3                	mov    %edx,%ebx

  ASSERT (block != NULL || size == 0);
c0026ffb:	85 c0                	test   %eax,%eax
c0026ffd:	75 04                	jne    c0027003 <memchr+0x1a>
c0026fff:	85 c9                	test   %ecx,%ecx
c0027001:	75 0f                	jne    c0027012 <memchr+0x29>

  for (; size-- > 0; block++)
c0027003:	85 c9                	test   %ecx,%ecx
c0027005:	74 3e                	je     c0027045 <memchr+0x5c>
    if (*block == ch)
c0027007:	3a 10                	cmp    (%eax),%dl
c0027009:	74 3f                	je     c002704a <memchr+0x61>
c002700b:	8d 50 01             	lea    0x1(%eax),%edx
c002700e:	01 c1                	add    %eax,%ecx
c0027010:	eb 26                	jmp    c0027038 <memchr+0x4f>
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
c0027012:	83 ec 0c             	sub    $0xc,%esp
c0027015:	68 9f ea 02 c0       	push   $0xc002ea9f
c002701a:	68 3f d2 02 c0       	push   $0xc002d23f
c002701f:	68 f4 cc 02 c0       	push   $0xc002ccf4
c0027024:	6a 63                	push   $0x63
c0027026:	68 3b ea 02 c0       	push   $0xc002ea3b
c002702b:	e8 9d 0c 00 00       	call   c0027ccd <debug_panic>
c0027030:	83 c2 01             	add    $0x1,%edx

  for (; size-- > 0; block++)
    if (*block == ch)
c0027033:	3a 5a ff             	cmp    -0x1(%edx),%bl
c0027036:	74 12                	je     c002704a <memchr+0x61>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0027038:	89 d0                	mov    %edx,%eax
c002703a:	39 ca                	cmp    %ecx,%edx
c002703c:	75 f2                	jne    c0027030 <memchr+0x47>
    if (*block == ch)
      return (void *) block;

  return NULL;
c002703e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027043:	eb 05                	jmp    c002704a <memchr+0x61>
c0027045:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002704a:	83 c4 08             	add    $0x8,%esp
c002704d:	5b                   	pop    %ebx
c002704e:	c3                   	ret    

c002704f <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002704f:	53                   	push   %ebx
c0027050:	83 ec 08             	sub    $0x8,%esp
c0027053:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027057:	8b 54 24 14          	mov    0x14(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);
c002705b:	85 c0                	test   %eax,%eax
c002705d:	74 0b                	je     c002706a <strchr+0x1b>
c002705f:	89 d1                	mov    %edx,%ecx

  for (;;) 
    if (*string == c)
c0027061:	0f b6 18             	movzbl (%eax),%ebx
c0027064:	38 da                	cmp    %bl,%dl
c0027066:	75 20                	jne    c0027088 <strchr+0x39>
c0027068:	eb 40                	jmp    c00270aa <strchr+0x5b>
char *
strchr (const char *string, int c_) 
{
  char c = c_;

  ASSERT (string != NULL);
c002706a:	83 ec 0c             	sub    $0xc,%esp
c002706d:	68 ba ea 02 c0       	push   $0xc002eaba
c0027072:	68 3f d2 02 c0       	push   $0xc002d23f
c0027077:	68 ec cc 02 c0       	push   $0xc002ccec
c002707c:	6a 75                	push   $0x75
c002707e:	68 3b ea 02 c0       	push   $0xc002ea3b
c0027083:	e8 45 0c 00 00       	call   c0027ccd <debug_panic>

  for (;;) 
    if (*string == c)
      return (char *) string;
    else if (*string == '\0')
c0027088:	84 db                	test   %bl,%bl
c002708a:	75 06                	jne    c0027092 <strchr+0x43>
c002708c:	eb 10                	jmp    c002709e <strchr+0x4f>
c002708e:	84 d2                	test   %dl,%dl
c0027090:	74 13                	je     c00270a5 <strchr+0x56>
      return NULL;
    else
      string++;
c0027092:	83 c0 01             	add    $0x1,%eax
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
c0027095:	0f b6 10             	movzbl (%eax),%edx
c0027098:	38 d1                	cmp    %dl,%cl
c002709a:	75 f2                	jne    c002708e <strchr+0x3f>
c002709c:	eb 0c                	jmp    c00270aa <strchr+0x5b>
      return (char *) string;
    else if (*string == '\0')
      return NULL;
c002709e:	b8 00 00 00 00       	mov    $0x0,%eax
c00270a3:	eb 05                	jmp    c00270aa <strchr+0x5b>
c00270a5:	b8 00 00 00 00       	mov    $0x0,%eax
    else
      string++;
}
c00270aa:	83 c4 08             	add    $0x8,%esp
c00270ad:	5b                   	pop    %ebx
c00270ae:	c3                   	ret    

c00270af <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00270af:	57                   	push   %edi
c00270b0:	56                   	push   %esi
c00270b1:	53                   	push   %ebx
c00270b2:	8b 74 24 10          	mov    0x10(%esp),%esi
c00270b6:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00270ba:	0f b6 06             	movzbl (%esi),%eax
c00270bd:	84 c0                	test   %al,%al
c00270bf:	74 26                	je     c00270e7 <strcspn+0x38>
c00270c1:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
c00270c6:	83 ec 08             	sub    $0x8,%esp
c00270c9:	0f be c0             	movsbl %al,%eax
c00270cc:	50                   	push   %eax
c00270cd:	57                   	push   %edi
c00270ce:	e8 7c ff ff ff       	call   c002704f <strchr>
c00270d3:	83 c4 10             	add    $0x10,%esp
c00270d6:	85 c0                	test   %eax,%eax
c00270d8:	75 12                	jne    c00270ec <strcspn+0x3d>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00270da:	83 c3 01             	add    $0x1,%ebx
c00270dd:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c00270e1:	84 c0                	test   %al,%al
c00270e3:	75 e1                	jne    c00270c6 <strcspn+0x17>
c00270e5:	eb 05                	jmp    c00270ec <strcspn+0x3d>
c00270e7:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
      break;
  return length;
}
c00270ec:	89 d8                	mov    %ebx,%eax
c00270ee:	5b                   	pop    %ebx
c00270ef:	5e                   	pop    %esi
c00270f0:	5f                   	pop    %edi
c00270f1:	c3                   	ret    

c00270f2 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c00270f2:	56                   	push   %esi
c00270f3:	53                   	push   %ebx
c00270f4:	83 ec 04             	sub    $0x4,%esp
c00270f7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00270fb:	8b 74 24 14          	mov    0x14(%esp),%esi
  for (; *string != '\0'; string++)
c00270ff:	0f b6 13             	movzbl (%ebx),%edx
c0027102:	84 d2                	test   %dl,%dl
c0027104:	74 20                	je     c0027126 <strpbrk+0x34>
    if (strchr (stop, *string) != NULL)
c0027106:	83 ec 08             	sub    $0x8,%esp
c0027109:	0f be d2             	movsbl %dl,%edx
c002710c:	52                   	push   %edx
c002710d:	56                   	push   %esi
c002710e:	e8 3c ff ff ff       	call   c002704f <strchr>
c0027113:	83 c4 10             	add    $0x10,%esp
c0027116:	85 c0                	test   %eax,%eax
c0027118:	75 13                	jne    c002712d <strpbrk+0x3b>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
c002711a:	83 c3 01             	add    $0x1,%ebx
c002711d:	0f b6 13             	movzbl (%ebx),%edx
c0027120:	84 d2                	test   %dl,%dl
c0027122:	75 e2                	jne    c0027106 <strpbrk+0x14>
c0027124:	eb 09                	jmp    c002712f <strpbrk+0x3d>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
c0027126:	b8 00 00 00 00       	mov    $0x0,%eax
c002712b:	eb 02                	jmp    c002712f <strpbrk+0x3d>
c002712d:	89 d8                	mov    %ebx,%eax
}
c002712f:	83 c4 04             	add    $0x4,%esp
c0027132:	5b                   	pop    %ebx
c0027133:	5e                   	pop    %esi
c0027134:	c3                   	ret    

c0027135 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0027135:	53                   	push   %ebx
c0027136:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c002713a:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c002713f:	0f b6 0a             	movzbl (%edx),%ecx
c0027142:	84 c9                	test   %cl,%cl
c0027144:	74 16                	je     c002715c <strrchr+0x27>
c0027146:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c002714b:	38 cb                	cmp    %cl,%bl
c002714d:	0f 44 c2             	cmove  %edx,%eax
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0027150:	83 c2 01             	add    $0x1,%edx
c0027153:	0f b6 0a             	movzbl (%edx),%ecx
c0027156:	84 c9                	test   %cl,%cl
c0027158:	75 f1                	jne    c002714b <strrchr+0x16>
c002715a:	eb 05                	jmp    c0027161 <strrchr+0x2c>
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;
c002715c:	b8 00 00 00 00       	mov    $0x0,%eax

  for (; *string != '\0'; string++)
    if (*string == c)
      p = string;
  return (char *) p;
}
c0027161:	5b                   	pop    %ebx
c0027162:	c3                   	ret    

c0027163 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0027163:	57                   	push   %edi
c0027164:	56                   	push   %esi
c0027165:	53                   	push   %ebx
c0027166:	8b 74 24 10          	mov    0x10(%esp),%esi
c002716a:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002716e:	0f b6 06             	movzbl (%esi),%eax
c0027171:	84 c0                	test   %al,%al
c0027173:	74 26                	je     c002719b <strspn+0x38>
c0027175:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
c002717a:	83 ec 08             	sub    $0x8,%esp
c002717d:	0f be c0             	movsbl %al,%eax
c0027180:	50                   	push   %eax
c0027181:	57                   	push   %edi
c0027182:	e8 c8 fe ff ff       	call   c002704f <strchr>
c0027187:	83 c4 10             	add    $0x10,%esp
c002718a:	85 c0                	test   %eax,%eax
c002718c:	74 12                	je     c00271a0 <strspn+0x3d>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002718e:	83 c3 01             	add    $0x1,%ebx
c0027191:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0027195:	84 c0                	test   %al,%al
c0027197:	75 e1                	jne    c002717a <strspn+0x17>
c0027199:	eb 05                	jmp    c00271a0 <strspn+0x3d>
c002719b:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
      break;
  return length;
}
c00271a0:	89 d8                	mov    %ebx,%eax
c00271a2:	5b                   	pop    %ebx
c00271a3:	5e                   	pop    %esi
c00271a4:	5f                   	pop    %edi
c00271a5:	c3                   	ret    

c00271a6 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c00271a6:	55                   	push   %ebp
c00271a7:	57                   	push   %edi
c00271a8:	56                   	push   %esi
c00271a9:	53                   	push   %ebx
c00271aa:	83 ec 0c             	sub    $0xc,%esp
c00271ad:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c00271b1:	8b 74 24 24          	mov    0x24(%esp),%esi
  char *token;
  
  ASSERT (delimiters != NULL);
c00271b5:	85 f6                	test   %esi,%esi
c00271b7:	75 21                	jne    c00271da <strtok_r+0x34>
c00271b9:	83 ec 0c             	sub    $0xc,%esp
c00271bc:	68 c9 ea 02 c0       	push   $0xc002eac9
c00271c1:	68 3f d2 02 c0       	push   $0xc002d23f
c00271c6:	68 e0 cc 02 c0       	push   $0xc002cce0
c00271cb:	68 ef 00 00 00       	push   $0xef
c00271d0:	68 3b ea 02 c0       	push   $0xc002ea3b
c00271d5:	e8 f3 0a 00 00       	call   c0027ccd <debug_panic>
  ASSERT (save_ptr != NULL);
c00271da:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c00271df:	75 21                	jne    c0027202 <strtok_r+0x5c>
c00271e1:	83 ec 0c             	sub    $0xc,%esp
c00271e4:	68 dc ea 02 c0       	push   $0xc002eadc
c00271e9:	68 3f d2 02 c0       	push   $0xc002d23f
c00271ee:	68 e0 cc 02 c0       	push   $0xc002cce0
c00271f3:	68 f0 00 00 00       	push   $0xf0
c00271f8:	68 3b ea 02 c0       	push   $0xc002ea3b
c00271fd:	e8 cb 0a 00 00       	call   c0027ccd <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0027202:	85 db                	test   %ebx,%ebx
c0027204:	75 41                	jne    c0027247 <strtok_r+0xa1>
    s = *save_ptr;
c0027206:	8b 44 24 28          	mov    0x28(%esp),%eax
c002720a:	8b 18                	mov    (%eax),%ebx
  ASSERT (s != NULL);
c002720c:	85 db                	test   %ebx,%ebx
c002720e:	75 37                	jne    c0027247 <strtok_r+0xa1>
c0027210:	83 ec 0c             	sub    $0xc,%esp
c0027213:	68 d2 ea 02 c0       	push   $0xc002ead2
c0027218:	68 3f d2 02 c0       	push   $0xc002d23f
c002721d:	68 e0 cc 02 c0       	push   $0xc002cce0
c0027222:	68 f6 00 00 00       	push   $0xf6
c0027227:	68 3b ea 02 c0       	push   $0xc002ea3b
c002722c:	e8 9c 0a 00 00       	call   c0027ccd <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0027231:	89 f8                	mov    %edi,%eax
c0027233:	84 c0                	test   %al,%al
c0027235:	75 0d                	jne    c0027244 <strtok_r+0x9e>
        {
          *save_ptr = s;
c0027237:	8b 44 24 28          	mov    0x28(%esp),%eax
c002723b:	89 18                	mov    %ebx,(%eax)
          return NULL;
c002723d:	b8 00 00 00 00       	mov    $0x0,%eax
c0027242:	eb 58                	jmp    c002729c <strtok_r+0xf6>
        }

      s++;
c0027244:	83 c3 01             	add    $0x1,%ebx
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0027247:	0f b6 3b             	movzbl (%ebx),%edi
c002724a:	83 ec 08             	sub    $0x8,%esp
c002724d:	89 f8                	mov    %edi,%eax
c002724f:	0f be c0             	movsbl %al,%eax
c0027252:	50                   	push   %eax
c0027253:	56                   	push   %esi
c0027254:	e8 f6 fd ff ff       	call   c002704f <strchr>
c0027259:	83 c4 10             	add    $0x10,%esp
c002725c:	85 c0                	test   %eax,%eax
c002725e:	75 d1                	jne    c0027231 <strtok_r+0x8b>
c0027260:	89 df                	mov    %ebx,%edi
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
    s++;
c0027262:	83 c7 01             	add    $0x1,%edi
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
c0027265:	0f b6 2f             	movzbl (%edi),%ebp
c0027268:	83 ec 08             	sub    $0x8,%esp
c002726b:	89 e8                	mov    %ebp,%eax
c002726d:	0f be c0             	movsbl %al,%eax
c0027270:	50                   	push   %eax
c0027271:	56                   	push   %esi
c0027272:	e8 d8 fd ff ff       	call   c002704f <strchr>
c0027277:	83 c4 10             	add    $0x10,%esp
c002727a:	85 c0                	test   %eax,%eax
c002727c:	74 e4                	je     c0027262 <strtok_r+0xbc>
    s++;
  if (*s != '\0') 
c002727e:	89 e8                	mov    %ebp,%eax
c0027280:	84 c0                	test   %al,%al
c0027282:	74 10                	je     c0027294 <strtok_r+0xee>
    {
      *s = '\0';
c0027284:	c6 07 00             	movb   $0x0,(%edi)
      *save_ptr = s + 1;
c0027287:	83 c7 01             	add    $0x1,%edi
c002728a:	8b 44 24 28          	mov    0x28(%esp),%eax
c002728e:	89 38                	mov    %edi,(%eax)
c0027290:	89 d8                	mov    %ebx,%eax
c0027292:	eb 08                	jmp    c002729c <strtok_r+0xf6>
    }
  else 
    *save_ptr = s;
c0027294:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027298:	89 38                	mov    %edi,(%eax)
c002729a:	89 d8                	mov    %ebx,%eax
  return token;
}
c002729c:	83 c4 0c             	add    $0xc,%esp
c002729f:	5b                   	pop    %ebx
c00272a0:	5e                   	pop    %esi
c00272a1:	5f                   	pop    %edi
c00272a2:	5d                   	pop    %ebp
c00272a3:	c3                   	ret    

c00272a4 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c00272a4:	56                   	push   %esi
c00272a5:	53                   	push   %ebx
c00272a6:	83 ec 04             	sub    $0x4,%esp
c00272a9:	8b 44 24 10          	mov    0x10(%esp),%eax
c00272ad:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00272b1:	8b 74 24 18          	mov    0x18(%esp),%esi
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
c00272b5:	85 c0                	test   %eax,%eax
c00272b7:	75 04                	jne    c00272bd <memset+0x19>
c00272b9:	85 f6                	test   %esi,%esi
c00272bb:	75 0b                	jne    c00272c8 <memset+0x24>
c00272bd:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  
  while (size-- > 0)
c00272c0:	89 c2                	mov    %eax,%edx
c00272c2:	85 f6                	test   %esi,%esi
c00272c4:	75 23                	jne    c00272e9 <memset+0x45>
c00272c6:	eb 2b                	jmp    c00272f3 <memset+0x4f>
void *
memset (void *dst_, int value, size_t size) 
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
c00272c8:	83 ec 0c             	sub    $0xc,%esp
c00272cb:	68 22 ea 02 c0       	push   $0xc002ea22
c00272d0:	68 3f d2 02 c0       	push   $0xc002d23f
c00272d5:	68 d8 cc 02 c0       	push   $0xc002ccd8
c00272da:	68 1b 01 00 00       	push   $0x11b
c00272df:	68 3b ea 02 c0       	push   $0xc002ea3b
c00272e4:	e8 e4 09 00 00       	call   c0027ccd <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c00272e9:	83 c2 01             	add    $0x1,%edx
c00272ec:	88 5a ff             	mov    %bl,-0x1(%edx)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c00272ef:	39 d1                	cmp    %edx,%ecx
c00272f1:	75 f6                	jne    c00272e9 <memset+0x45>
    *dst++ = value;

  return dst_;
}
c00272f3:	83 c4 04             	add    $0x4,%esp
c00272f6:	5b                   	pop    %ebx
c00272f7:	5e                   	pop    %esi
c00272f8:	c3                   	ret    

c00272f9 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c00272f9:	83 ec 0c             	sub    $0xc,%esp
c00272fc:	8b 54 24 10          	mov    0x10(%esp),%edx
  const char *p;

  ASSERT (string != NULL);
c0027300:	85 d2                	test   %edx,%edx
c0027302:	74 09                	je     c002730d <strlen+0x14>

  for (p = string; *p != '\0'; p++)
c0027304:	89 d0                	mov    %edx,%eax
c0027306:	80 3a 00             	cmpb   $0x0,(%edx)
c0027309:	74 2d                	je     c0027338 <strlen+0x3f>
c002730b:	eb 21                	jmp    c002732e <strlen+0x35>
size_t
strlen (const char *string) 
{
  const char *p;

  ASSERT (string != NULL);
c002730d:	83 ec 0c             	sub    $0xc,%esp
c0027310:	68 ba ea 02 c0       	push   $0xc002eaba
c0027315:	68 3f d2 02 c0       	push   $0xc002d23f
c002731a:	68 d0 cc 02 c0       	push   $0xc002ccd0
c002731f:	68 29 01 00 00       	push   $0x129
c0027324:	68 3b ea 02 c0       	push   $0xc002ea3b
c0027329:	e8 9f 09 00 00       	call   c0027ccd <debug_panic>

  for (p = string; *p != '\0'; p++)
c002732e:	89 d0                	mov    %edx,%eax
c0027330:	83 c0 01             	add    $0x1,%eax
c0027333:	80 38 00             	cmpb   $0x0,(%eax)
c0027336:	75 f8                	jne    c0027330 <strlen+0x37>
    continue;
  return p - string;
c0027338:	29 d0                	sub    %edx,%eax
}
c002733a:	83 c4 0c             	add    $0xc,%esp
c002733d:	c3                   	ret    

c002733e <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c002733e:	55                   	push   %ebp
c002733f:	57                   	push   %edi
c0027340:	56                   	push   %esi
c0027341:	53                   	push   %ebx
c0027342:	83 ec 1c             	sub    $0x1c,%esp
c0027345:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  size_t haystack_len = strlen (haystack);
c0027349:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c002734e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027353:	89 d9                	mov    %ebx,%ecx
c0027355:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0027359:	f2 ae                	repnz scas %es:(%edi),%al
c002735b:	f7 d1                	not    %ecx
c002735d:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
c0027360:	89 d9                	mov    %ebx,%ecx
c0027362:	89 ef                	mov    %ebp,%edi
c0027364:	f2 ae                	repnz scas %es:(%edi),%al
c0027366:	89 c8                	mov    %ecx,%eax
c0027368:	f7 d0                	not    %eax
c002736a:	8d 78 ff             	lea    -0x1(%eax),%edi

  if (haystack_len >= needle_len) 
c002736d:	39 fa                	cmp    %edi,%edx
c002736f:	72 33                	jb     c00273a4 <strstr+0x66>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0027371:	29 fa                	sub    %edi,%edx
c0027373:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027377:	bb 00 00 00 00       	mov    $0x0,%ebx
c002737c:	89 de                	mov    %ebx,%esi
c002737e:	03 74 24 30          	add    0x30(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
c0027382:	83 ec 04             	sub    $0x4,%esp
c0027385:	57                   	push   %edi
c0027386:	55                   	push   %ebp
c0027387:	56                   	push   %esi
c0027388:	e8 2f fb ff ff       	call   c0026ebc <memcmp>
c002738d:	83 c4 10             	add    $0x10,%esp
c0027390:	85 c0                	test   %eax,%eax
c0027392:	74 17                	je     c00273ab <strstr+0x6d>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0027394:	83 c3 01             	add    $0x1,%ebx
c0027397:	3b 5c 24 0c          	cmp    0xc(%esp),%ebx
c002739b:	76 df                	jbe    c002737c <strstr+0x3e>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
c002739d:	b8 00 00 00 00       	mov    $0x0,%eax
c00273a2:	eb 09                	jmp    c00273ad <strstr+0x6f>
c00273a4:	b8 00 00 00 00       	mov    $0x0,%eax
c00273a9:	eb 02                	jmp    c00273ad <strstr+0x6f>
  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
c00273ab:	89 f0                	mov    %esi,%eax
          return (char *) haystack + i;
    }

  return NULL;
}
c00273ad:	83 c4 1c             	add    $0x1c,%esp
c00273b0:	5b                   	pop    %ebx
c00273b1:	5e                   	pop    %esi
c00273b2:	5f                   	pop    %edi
c00273b3:	5d                   	pop    %ebp
c00273b4:	c3                   	ret    

c00273b5 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00273b5:	8b 54 24 04          	mov    0x4(%esp),%edx
c00273b9:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00273bd:	80 3a 00             	cmpb   $0x0,(%edx)
c00273c0:	74 18                	je     c00273da <strnlen+0x25>
c00273c2:	85 c9                	test   %ecx,%ecx
c00273c4:	74 14                	je     c00273da <strnlen+0x25>
c00273c6:	b8 00 00 00 00       	mov    $0x0,%eax
c00273cb:	83 c0 01             	add    $0x1,%eax
c00273ce:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c00273d2:	74 0b                	je     c00273df <strnlen+0x2a>
c00273d4:	39 c1                	cmp    %eax,%ecx
c00273d6:	77 f3                	ja     c00273cb <strnlen+0x16>
c00273d8:	f3 c3                	repz ret 
c00273da:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c00273df:	f3 c3                	repz ret 

c00273e1 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c00273e1:	55                   	push   %ebp
c00273e2:	57                   	push   %edi
c00273e3:	56                   	push   %esi
c00273e4:	53                   	push   %ebx
c00273e5:	83 ec 0c             	sub    $0xc,%esp
c00273e8:	8b 74 24 20          	mov    0x20(%esp),%esi
c00273ec:	8b 6c 24 24          	mov    0x24(%esp),%ebp
c00273f0:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
c00273f4:	85 f6                	test   %esi,%esi
c00273f6:	75 21                	jne    c0027419 <strlcpy+0x38>
c00273f8:	83 ec 0c             	sub    $0xc,%esp
c00273fb:	68 ed ea 02 c0       	push   $0xc002eaed
c0027400:	68 3f d2 02 c0       	push   $0xc002d23f
c0027405:	68 c8 cc 02 c0       	push   $0xc002ccc8
c002740a:	68 4a 01 00 00       	push   $0x14a
c002740f:	68 3b ea 02 c0       	push   $0xc002ea3b
c0027414:	e8 b4 08 00 00       	call   c0027ccd <debug_panic>
  ASSERT (src != NULL);
c0027419:	85 ed                	test   %ebp,%ebp
c002741b:	75 21                	jne    c002743e <strlcpy+0x5d>
c002741d:	83 ec 0c             	sub    $0xc,%esp
c0027420:	68 f9 ea 02 c0       	push   $0xc002eaf9
c0027425:	68 3f d2 02 c0       	push   $0xc002d23f
c002742a:	68 c8 cc 02 c0       	push   $0xc002ccc8
c002742f:	68 4b 01 00 00       	push   $0x14b
c0027434:	68 3b ea 02 c0       	push   $0xc002ea3b
c0027439:	e8 8f 08 00 00       	call   c0027ccd <debug_panic>

  src_len = strlen (src);
c002743e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027443:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0027448:	89 ef                	mov    %ebp,%edi
c002744a:	f2 ae                	repnz scas %es:(%edi),%al
c002744c:	f7 d1                	not    %ecx
c002744e:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  if (size > 0) 
c0027451:	85 d2                	test   %edx,%edx
c0027453:	74 1c                	je     c0027471 <strlcpy+0x90>
    {
      size_t dst_len = size - 1;
c0027455:	83 ea 01             	sub    $0x1,%edx
c0027458:	39 d3                	cmp    %edx,%ebx
c002745a:	89 d7                	mov    %edx,%edi
c002745c:	0f 46 fb             	cmovbe %ebx,%edi
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
c002745f:	83 ec 04             	sub    $0x4,%esp
c0027462:	57                   	push   %edi
c0027463:	55                   	push   %ebp
c0027464:	56                   	push   %esi
c0027465:	e8 2d f9 ff ff       	call   c0026d97 <memcpy>
      dst[dst_len] = '\0';
c002746a:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
c002746e:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
c0027471:	89 d8                	mov    %ebx,%eax
c0027473:	83 c4 0c             	add    $0xc,%esp
c0027476:	5b                   	pop    %ebx
c0027477:	5e                   	pop    %esi
c0027478:	5f                   	pop    %edi
c0027479:	5d                   	pop    %ebp
c002747a:	c3                   	ret    

c002747b <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c002747b:	55                   	push   %ebp
c002747c:	57                   	push   %edi
c002747d:	56                   	push   %esi
c002747e:	53                   	push   %ebx
c002747f:	83 ec 0c             	sub    $0xc,%esp
c0027482:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0027486:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002748b:	75 21                	jne    c00274ae <strlcat+0x33>
c002748d:	83 ec 0c             	sub    $0xc,%esp
c0027490:	68 ed ea 02 c0       	push   $0xc002eaed
c0027495:	68 3f d2 02 c0       	push   $0xc002d23f
c002749a:	68 c0 cc 02 c0       	push   $0xc002ccc0
c002749f:	68 68 01 00 00       	push   $0x168
c00274a4:	68 3b ea 02 c0       	push   $0xc002ea3b
c00274a9:	e8 1f 08 00 00       	call   c0027ccd <debug_panic>
  ASSERT (src != NULL);
c00274ae:	85 d2                	test   %edx,%edx
c00274b0:	75 21                	jne    c00274d3 <strlcat+0x58>
c00274b2:	83 ec 0c             	sub    $0xc,%esp
c00274b5:	68 f9 ea 02 c0       	push   $0xc002eaf9
c00274ba:	68 3f d2 02 c0       	push   $0xc002d23f
c00274bf:	68 c0 cc 02 c0       	push   $0xc002ccc0
c00274c4:	68 69 01 00 00       	push   $0x169
c00274c9:	68 3b ea 02 c0       	push   $0xc002ea3b
c00274ce:	e8 fa 07 00 00       	call   c0027ccd <debug_panic>

  src_len = strlen (src);
c00274d3:	be ff ff ff ff       	mov    $0xffffffff,%esi
c00274d8:	b8 00 00 00 00       	mov    $0x0,%eax
c00274dd:	89 f1                	mov    %esi,%ecx
c00274df:	89 d7                	mov    %edx,%edi
c00274e1:	f2 ae                	repnz scas %es:(%edi),%al
c00274e3:	f7 d1                	not    %ecx
c00274e5:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
c00274e8:	89 f1                	mov    %esi,%ecx
c00274ea:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00274ee:	f2 ae                	repnz scas %es:(%edi),%al
c00274f0:	89 c8                	mov    %ecx,%eax
c00274f2:	f7 d0                	not    %eax
c00274f4:	8d 58 ff             	lea    -0x1(%eax),%ebx
  if (size > 0 && dst_len < size) 
c00274f7:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c00274fc:	74 2c                	je     c002752a <strlcat+0xaf>
c00274fe:	3b 5c 24 28          	cmp    0x28(%esp),%ebx
c0027502:	73 26                	jae    c002752a <strlcat+0xaf>
    {
      size_t copy_cnt = size - dst_len - 1;
c0027504:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027508:	8d 70 ff             	lea    -0x1(%eax),%esi
c002750b:	29 de                	sub    %ebx,%esi
c002750d:	39 f5                	cmp    %esi,%ebp
c002750f:	0f 46 f5             	cmovbe %ebp,%esi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
c0027512:	89 df                	mov    %ebx,%edi
c0027514:	03 7c 24 20          	add    0x20(%esp),%edi
c0027518:	83 ec 04             	sub    $0x4,%esp
c002751b:	56                   	push   %esi
c002751c:	52                   	push   %edx
c002751d:	57                   	push   %edi
c002751e:	e8 74 f8 ff ff       	call   c0026d97 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
c0027523:	c6 04 37 00          	movb   $0x0,(%edi,%esi,1)
c0027527:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
c002752a:	8d 44 1d 00          	lea    0x0(%ebp,%ebx,1),%eax
}
c002752e:	83 c4 0c             	add    $0xc,%esp
c0027531:	5b                   	pop    %ebx
c0027532:	5e                   	pop    %esi
c0027533:	5f                   	pop    %edi
c0027534:	5d                   	pop    %ebp
c0027535:	c3                   	ret    

c0027536 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0027536:	55                   	push   %ebp
c0027537:	57                   	push   %edi
c0027538:	56                   	push   %esi
c0027539:	53                   	push   %ebx
c002753a:	83 ec 1c             	sub    $0x1c,%esp
c002753d:	89 04 24             	mov    %eax,(%esp)
c0027540:	89 54 24 04          	mov    %edx,0x4(%esp)
c0027544:	8b 74 24 30          	mov    0x30(%esp),%esi
c0027548:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
c002754c:	85 ff                	test   %edi,%edi
c002754e:	75 43                	jne    c0027593 <udiv64+0x5d>
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
c0027550:	8b 44 24 04          	mov    0x4(%esp),%eax
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027554:	ba 00 00 00 00       	mov    $0x0,%edx
c0027559:	f7 f6                	div    %esi
c002755b:	89 c7                	mov    %eax,%edi
c002755d:	89 d0                	mov    %edx,%eax
c002755f:	89 c2                	mov    %eax,%edx
c0027561:	b8 00 00 00 00       	mov    $0x0,%eax
c0027566:	8b 0c 24             	mov    (%esp),%ecx
c0027569:	bb 00 00 00 00       	mov    $0x0,%ebx
c002756e:	01 c8                	add    %ecx,%eax
c0027570:	11 da                	adc    %ebx,%edx
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
c0027572:	f7 f6                	div    %esi
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0027574:	89 f9                	mov    %edi,%ecx
c0027576:	89 cf                	mov    %ecx,%edi
c0027578:	be 00 00 00 00       	mov    $0x0,%esi
c002757d:	ba 00 00 00 00       	mov    $0x0,%edx
c0027582:	01 c6                	add    %eax,%esi
c0027584:	11 d7                	adc    %edx,%edi
c0027586:	89 74 24 08          	mov    %esi,0x8(%esp)
c002758a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c002758e:	e9 05 01 00 00       	jmp    c0027698 <udiv64+0x162>
c0027593:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0027595:	8b 0c 24             	mov    (%esp),%ecx
c0027598:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c002759c:	39 df                	cmp    %ebx,%edi
c002759e:	0f 87 e4 00 00 00    	ja     c0027688 <udiv64+0x152>
c00275a4:	72 08                	jb     c00275ae <udiv64+0x78>
c00275a6:	39 ce                	cmp    %ecx,%esi
c00275a8:	0f 87 da 00 00 00    	ja     c0027688 <udiv64+0x152>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
c00275ae:	89 d0                	mov    %edx,%eax
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c00275b0:	bd 00 00 00 00       	mov    $0x0,%ebp
  if (x <= 0x0000FFFF)
c00275b5:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
c00275bb:	77 08                	ja     c00275c5 <udiv64+0x8f>
    {
      n += 16;
      x <<= 16; 
c00275bd:	c1 e0 10             	shl    $0x10,%eax
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
  if (x <= 0x0000FFFF)
    {
      n += 16;
c00275c0:	bd 10 00 00 00       	mov    $0x10,%ebp
      x <<= 16; 
    }
  if (x <= 0x00FFFFFF)
c00275c5:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c00275ca:	77 06                	ja     c00275d2 <udiv64+0x9c>
    {
      n += 8;
c00275cc:	83 c5 08             	add    $0x8,%ebp
      x <<= 8; 
c00275cf:	c1 e0 08             	shl    $0x8,%eax
    }
  if (x <= 0x0FFFFFFF)
c00275d2:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
c00275d7:	77 06                	ja     c00275df <udiv64+0xa9>
    {
      n += 4;
c00275d9:	83 c5 04             	add    $0x4,%ebp
      x <<= 4;
c00275dc:	c1 e0 04             	shl    $0x4,%eax
    }
  if (x <= 0x3FFFFFFF)
c00275df:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
c00275e4:	77 06                	ja     c00275ec <udiv64+0xb6>
    {
      n += 2;
c00275e6:	83 c5 02             	add    $0x2,%ebp
      x <<= 2; 
c00275e9:	c1 e0 02             	shl    $0x2,%eax
    }
  if (x <= 0x7FFFFFFF)
    n++;
c00275ec:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c00275f1:	83 d5 00             	adc    $0x0,%ebp
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c00275f4:	8b 04 24             	mov    (%esp),%eax
c00275f7:	8b 54 24 04          	mov    0x4(%esp),%edx
c00275fb:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c00275ff:	d1 ea                	shr    %edx
c0027601:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027605:	89 54 24 0c          	mov    %edx,0xc(%esp)
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
c0027609:	89 f0                	mov    %esi,%eax
c002760b:	89 fa                	mov    %edi,%edx
c002760d:	89 e9                	mov    %ebp,%ecx
c002760f:	0f a5 f2             	shld   %cl,%esi,%edx
c0027612:	d3 e0                	shl    %cl,%eax
c0027614:	f6 c1 20             	test   $0x20,%cl
c0027617:	74 02                	je     c002761b <udiv64+0xe5>
c0027619:	89 c2                	mov    %eax,%edx
c002761b:	89 d3                	mov    %edx,%ebx
c002761d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027621:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027625:	f7 f3                	div    %ebx
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0027627:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c002762c:	29 e9                	sub    %ebp,%ecx
c002762e:	d3 e8                	shr    %cl,%eax
c0027630:	89 c2                	mov    %eax,%edx
c0027632:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027637:	89 44 24 10          	mov    %eax,0x10(%esp)
c002763b:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c002763f:	83 c2 ff             	add    $0xffffffff,%edx
c0027642:	83 d1 ff             	adc    $0xffffffff,%ecx
c0027645:	89 cb                	mov    %ecx,%ebx
c0027647:	89 54 24 08          	mov    %edx,0x8(%esp)
c002764b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c002764f:	89 fd                	mov    %edi,%ebp
c0027651:	0f af ea             	imul   %edx,%ebp
c0027654:	89 d8                	mov    %ebx,%eax
c0027656:	0f af c6             	imul   %esi,%eax
c0027659:	01 c5                	add    %eax,%ebp
c002765b:	89 f0                	mov    %esi,%eax
c002765d:	f7 e2                	mul    %edx
c002765f:	01 ea                	add    %ebp,%edx
c0027661:	8b 0c 24             	mov    (%esp),%ecx
c0027664:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0027668:	29 c1                	sub    %eax,%ecx
c002766a:	19 d3                	sbb    %edx,%ebx
c002766c:	39 df                	cmp    %ebx,%edi
c002766e:	77 28                	ja     c0027698 <udiv64+0x162>
c0027670:	72 04                	jb     c0027676 <udiv64+0x140>
c0027672:	39 ce                	cmp    %ecx,%esi
c0027674:	77 22                	ja     c0027698 <udiv64+0x162>
c0027676:	8b 44 24 10          	mov    0x10(%esp),%eax
c002767a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002767e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0027682:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0027686:	eb 10                	jmp    c0027698 <udiv64+0x162>
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
        return 0;
c0027688:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002768f:	00 
c0027690:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0027697:	00 
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
c0027698:	8b 44 24 08          	mov    0x8(%esp),%eax
c002769c:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00276a0:	83 c4 1c             	add    $0x1c,%esp
c00276a3:	5b                   	pop    %ebx
c00276a4:	5e                   	pop    %esi
c00276a5:	5f                   	pop    %edi
c00276a6:	5d                   	pop    %ebp
c00276a7:	c3                   	ret    

c00276a8 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c00276a8:	57                   	push   %edi
c00276a9:	56                   	push   %esi
c00276aa:	53                   	push   %ebx
c00276ab:	83 ec 08             	sub    $0x8,%esp
c00276ae:	89 04 24             	mov    %eax,(%esp)
c00276b1:	89 54 24 04          	mov    %edx,0x4(%esp)
c00276b5:	8b 74 24 18          	mov    0x18(%esp),%esi
c00276b9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c00276bd:	85 d2                	test   %edx,%edx
c00276bf:	79 07                	jns    c00276c8 <sdiv64+0x20>
c00276c1:	f7 d8                	neg    %eax
c00276c3:	83 d2 00             	adc    $0x0,%edx
c00276c6:	f7 da                	neg    %edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c00276c8:	89 f1                	mov    %esi,%ecx
c00276ca:	89 fb                	mov    %edi,%ebx
c00276cc:	85 ff                	test   %edi,%edi
c00276ce:	79 07                	jns    c00276d7 <sdiv64+0x2f>
c00276d0:	f7 d9                	neg    %ecx
c00276d2:	83 d3 00             	adc    $0x0,%ebx
c00276d5:	f7 db                	neg    %ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c00276d7:	53                   	push   %ebx
c00276d8:	51                   	push   %ecx
c00276d9:	e8 58 fe ff ff       	call   c0027536 <udiv64>
c00276de:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c00276e1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00276e5:	f7 d1                	not    %ecx
c00276e7:	c1 e9 1f             	shr    $0x1f,%ecx
c00276ea:	89 fb                	mov    %edi,%ebx
c00276ec:	c1 eb 1f             	shr    $0x1f,%ebx
c00276ef:	38 d9                	cmp    %bl,%cl
c00276f1:	75 07                	jne    c00276fa <sdiv64+0x52>
c00276f3:	f7 d8                	neg    %eax
c00276f5:	83 d2 00             	adc    $0x0,%edx
c00276f8:	f7 da                	neg    %edx
}
c00276fa:	83 c4 08             	add    $0x8,%esp
c00276fd:	5b                   	pop    %ebx
c00276fe:	5e                   	pop    %esi
c00276ff:	5f                   	pop    %edi
c0027700:	c3                   	ret    

c0027701 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0027701:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
c0027704:	ff 74 24 14          	pushl  0x14(%esp)
c0027708:	ff 74 24 14          	pushl  0x14(%esp)
c002770c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027710:	8b 54 24 14          	mov    0x14(%esp),%edx
c0027714:	e8 8f ff ff ff       	call   c00276a8 <sdiv64>
}
c0027719:	83 c4 0c             	add    $0xc,%esp
c002771c:	c3                   	ret    

c002771d <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c002771d:	57                   	push   %edi
c002771e:	56                   	push   %esi
c002771f:	53                   	push   %ebx
c0027720:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027724:	8b 74 24 18          	mov    0x18(%esp),%esi
c0027728:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
  return n - d * sdiv64 (n, d);
c002772c:	57                   	push   %edi
c002772d:	56                   	push   %esi
c002772e:	89 d8                	mov    %ebx,%eax
c0027730:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0027734:	e8 6f ff ff ff       	call   c00276a8 <sdiv64>
c0027739:	83 c4 08             	add    $0x8,%esp

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
  return smod64 (n, d);
c002773c:	0f af f0             	imul   %eax,%esi
c002773f:	89 d8                	mov    %ebx,%eax
c0027741:	29 f0                	sub    %esi,%eax
c0027743:	99                   	cltd   
}
c0027744:	5b                   	pop    %ebx
c0027745:	5e                   	pop    %esi
c0027746:	5f                   	pop    %edi
c0027747:	c3                   	ret    

c0027748 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0027748:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
c002774b:	ff 74 24 14          	pushl  0x14(%esp)
c002774f:	ff 74 24 14          	pushl  0x14(%esp)
c0027753:	8b 44 24 10          	mov    0x10(%esp),%eax
c0027757:	8b 54 24 14          	mov    0x14(%esp),%edx
c002775b:	e8 d6 fd ff ff       	call   c0027536 <udiv64>
}
c0027760:	83 c4 0c             	add    $0xc,%esp
c0027763:	c3                   	ret    

c0027764 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0027764:	57                   	push   %edi
c0027765:	56                   	push   %esi
c0027766:	53                   	push   %ebx
c0027767:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002776b:	8b 74 24 18          	mov    0x18(%esp),%esi
c002776f:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
  return n - d * udiv64 (n, d);
c0027773:	57                   	push   %edi
c0027774:	56                   	push   %esi
c0027775:	89 d8                	mov    %ebx,%eax
c0027777:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002777b:	e8 b6 fd ff ff       	call   c0027536 <udiv64>
c0027780:	83 c4 08             	add    $0x8,%esp

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
  return umod64 (n, d);
c0027783:	0f af f0             	imul   %eax,%esi
c0027786:	89 d8                	mov    %ebx,%eax
c0027788:	29 f0                	sub    %esi,%eax
c002778a:	ba 00 00 00 00       	mov    $0x0,%edx
}
c002778f:	5b                   	pop    %ebx
c0027790:	5e                   	pop    %esi
c0027791:	5f                   	pop    %edi
c0027792:	c3                   	ret    

c0027793 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0027793:	55                   	push   %ebp
c0027794:	57                   	push   %edi
c0027795:	56                   	push   %esi
c0027796:	53                   	push   %ebx
c0027797:	83 ec 04             	sub    $0x4,%esp
c002779a:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c002779d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c00277a3:	b8 00 00 00 00       	mov    $0x0,%eax
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c00277a8:	85 d2                	test   %edx,%edx
c00277aa:	74 62                	je     c002780e <parse_octal_field+0x7b>
c00277ac:	eb 40                	jmp    c00277ee <parse_octal_field+0x5b>
    {
      char c = s[ofs];
c00277ae:	8b 04 24             	mov    (%esp),%eax
c00277b1:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
c00277b5:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c00277b8:	89 e8                	mov    %ebp,%eax
c00277ba:	3c 07                	cmp    $0x7,%al
c00277bc:	77 1f                	ja     c00277dd <parse_octal_field+0x4a>
        {
          if (*value > ULONG_MAX / 8)
c00277be:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c00277c4:	77 43                	ja     c0027809 <parse_octal_field+0x76>
            {
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
c00277c6:	0f be db             	movsbl %bl,%ebx
c00277c9:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c00277cd:	89 39                	mov    %edi,(%ecx)
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c00277cf:	83 c6 01             	add    $0x1,%esi
c00277d2:	39 f2                	cmp    %esi,%edx
c00277d4:	75 d8                	jne    c00277ae <parse_octal_field+0x1b>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c00277d6:	b8 00 00 00 00       	mov    $0x0,%eax
c00277db:	eb 31                	jmp    c002780e <parse_octal_field+0x7b>
          return ofs > 0;
        }
      else
        {
          /* Bad character. */
          return false;
c00277dd:	b8 00 00 00 00       	mov    $0x0,%eax
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
        }
      else if (c == ' ' || c == '\0')
c00277e2:	f6 c3 df             	test   $0xdf,%bl
c00277e5:	75 27                	jne    c002780e <parse_octal_field+0x7b>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c00277e7:	85 f6                	test   %esi,%esi
c00277e9:	0f 95 c0             	setne  %al
c00277ec:	eb 20                	jmp    c002780e <parse_octal_field+0x7b>
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
    {
      char c = s[ofs];
c00277ee:	8b 04 24             	mov    (%esp),%eax
c00277f1:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
c00277f4:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c00277f7:	bf 00 00 00 00       	mov    $0x0,%edi
c00277fc:	be 00 00 00 00       	mov    $0x0,%esi
c0027801:	89 e8                	mov    %ebp,%eax
c0027803:	3c 07                	cmp    $0x7,%al
c0027805:	76 bf                	jbe    c00277c6 <parse_octal_field+0x33>
c0027807:	eb d4                	jmp    c00277dd <parse_octal_field+0x4a>
        {
          if (*value > ULONG_MAX / 8)
            {
              /* Overflow. */
              return false;
c0027809:	b8 00 00 00 00       	mov    $0x0,%eax
        }
    }

  /* Field did not end in space or null byte. */
  return false;
}
c002780e:	83 c4 04             	add    $0x4,%esp
c0027811:	5b                   	pop    %ebx
c0027812:	5e                   	pop    %esi
c0027813:	5f                   	pop    %edi
c0027814:	5d                   	pop    %ebp
c0027815:	c3                   	ret    

c0027816 <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c0027816:	57                   	push   %edi
c0027817:	56                   	push   %esi
c0027818:	53                   	push   %ebx
c0027819:	89 c3                	mov    %eax,%ebx
  while (*file_name == '/'
c002781b:	eb 11                	jmp    c002782e <strip_antisocial_prefixes+0x18>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c002781d:	83 ec 08             	sub    $0x8,%esp
c0027820:	6a 2f                	push   $0x2f
c0027822:	53                   	push   %ebx
c0027823:	e8 27 f8 ff ff       	call   c002704f <strchr>
c0027828:	83 c4 10             	add    $0x10,%esp
c002782b:	8d 58 01             	lea    0x1(%eax),%ebx
   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
  while (*file_name == '/'
c002782e:	0f b6 33             	movzbl (%ebx),%esi
c0027831:	89 f0                	mov    %esi,%eax
c0027833:	3c 2f                	cmp    $0x2f,%al
c0027835:	74 e6                	je     c002781d <strip_antisocial_prefixes+0x7>
         || !memcmp (file_name, "./", 2)
c0027837:	83 ec 04             	sub    $0x4,%esp
c002783a:	6a 02                	push   $0x2
c002783c:	68 9d de 02 c0       	push   $0xc002de9d
c0027841:	53                   	push   %ebx
c0027842:	e8 75 f6 ff ff       	call   c0026ebc <memcmp>
c0027847:	83 c4 10             	add    $0x10,%esp
c002784a:	85 c0                	test   %eax,%eax
c002784c:	74 cf                	je     c002781d <strip_antisocial_prefixes+0x7>
         || !memcmp (file_name, "../", 3))
c002784e:	83 ec 04             	sub    $0x4,%esp
c0027851:	6a 03                	push   $0x3
c0027853:	68 05 eb 02 c0       	push   $0xc002eb05
c0027858:	53                   	push   %ebx
c0027859:	e8 5e f6 ff ff       	call   c0026ebc <memcmp>
c002785e:	83 c4 10             	add    $0x10,%esp
c0027861:	85 c0                	test   %eax,%eax
c0027863:	74 b8                	je     c002781d <strip_antisocial_prefixes+0x7>
    file_name = strchr (file_name, '/') + 1;
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0027865:	b8 23 e4 02 c0       	mov    $0xc002e423,%eax
c002786a:	89 f2                	mov    %esi,%edx
c002786c:	84 d2                	test   %dl,%dl
c002786e:	74 23                	je     c0027893 <strip_antisocial_prefixes+0x7d>
c0027870:	bf 22 e4 02 c0       	mov    $0xc002e422,%edi
c0027875:	b9 03 00 00 00       	mov    $0x3,%ecx
c002787a:	89 de                	mov    %ebx,%esi
c002787c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002787e:	0f 97 c0             	seta   %al
c0027881:	0f 92 c2             	setb   %dl
c0027884:	29 d0                	sub    %edx,%eax
c0027886:	0f be c0             	movsbl %al,%eax
c0027889:	85 c0                	test   %eax,%eax
c002788b:	b8 23 e4 02 c0       	mov    $0xc002e423,%eax
c0027890:	0f 45 c3             	cmovne %ebx,%eax
}
c0027893:	5b                   	pop    %ebx
c0027894:	5e                   	pop    %esi
c0027895:	5f                   	pop    %edi
c0027896:	c3                   	ret    

c0027897 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c0027897:	55                   	push   %ebp
c0027898:	57                   	push   %edi
c0027899:	56                   	push   %esi
c002789a:	53                   	push   %ebx
c002789b:	83 ec 0c             	sub    $0xc,%esp
c002789e:	8b 74 24 24          	mov    0x24(%esp),%esi
c00278a2:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  struct ustar_header *h = (struct ustar_header *) header;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c00278a6:	83 fe 30             	cmp    $0x30,%esi
c00278a9:	0f 94 c2             	sete   %dl
c00278ac:	83 fe 35             	cmp    $0x35,%esi
c00278af:	0f 94 c0             	sete   %al
c00278b2:	08 c2                	or     %al,%dl
c00278b4:	75 1e                	jne    c00278d4 <ustar_make_header+0x3d>
c00278b6:	83 ec 0c             	sub    $0xc,%esp
c00278b9:	68 f0 eb 02 c0       	push   $0xc002ebf0
c00278be:	68 3f d2 02 c0       	push   $0xc002d23f
c00278c3:	68 1c cd 02 c0       	push   $0xc002cd1c
c00278c8:	6a 59                	push   $0x59
c00278ca:	68 09 eb 02 c0       	push   $0xc002eb09
c00278cf:	e8 f9 03 00 00       	call   c0027ccd <debug_panic>
c00278d4:	89 d5                	mov    %edx,%ebp

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c00278d6:	8b 44 24 20          	mov    0x20(%esp),%eax
c00278da:	e8 37 ff ff ff       	call   c0027816 <strip_antisocial_prefixes>
c00278df:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
c00278e1:	b8 00 00 00 00       	mov    $0x0,%eax
c00278e6:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c00278eb:	89 d7                	mov    %edx,%edi
c00278ed:	f2 ae                	repnz scas %es:(%edi),%al
c00278ef:	f7 d1                	not    %ecx
c00278f1:	83 e9 01             	sub    $0x1,%ecx
c00278f4:	83 f9 63             	cmp    $0x63,%ecx
c00278f7:	76 1b                	jbe    c0027914 <ustar_make_header+0x7d>
    {
      printf ("%s: file name too long\n", file_name);
c00278f9:	83 ec 08             	sub    $0x8,%esp
c00278fc:	52                   	push   %edx
c00278fd:	68 1b eb 02 c0       	push   $0xc002eb1b
c0027902:	e8 4e e7 ff ff       	call   c0026055 <printf>
      return false;
c0027907:	83 c4 10             	add    $0x10,%esp
c002790a:	bd 00 00 00 00       	mov    $0x0,%ebp
c002790f:	e9 4b 01 00 00       	jmp    c0027a5f <ustar_make_header+0x1c8>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c0027914:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
c002791a:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
c0027921:	00 00 00 
c0027924:	8d 7b 04             	lea    0x4(%ebx),%edi
c0027927:	83 e7 fc             	and    $0xfffffffc,%edi
c002792a:	89 d9                	mov    %ebx,%ecx
c002792c:	29 f9                	sub    %edi,%ecx
c002792e:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0027934:	c1 e9 02             	shr    $0x2,%ecx
c0027937:	b8 00 00 00 00       	mov    $0x0,%eax
c002793c:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
c002793e:	83 ec 04             	sub    $0x4,%esp
c0027941:	6a 64                	push   $0x64
c0027943:	52                   	push   %edx
c0027944:	53                   	push   %ebx
c0027945:	e8 97 fa ff ff       	call   c00273e1 <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
c002794a:	83 c4 10             	add    $0x10,%esp
c002794d:	83 fe 30             	cmp    $0x30,%esi
c0027950:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0027955:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c002795a:	0f 45 c2             	cmovne %edx,%eax
c002795d:	50                   	push   %eax
c002795e:	68 33 eb 02 c0       	push   $0xc002eb33
c0027963:	6a 08                	push   $0x8
c0027965:	8d 43 64             	lea    0x64(%ebx),%eax
c0027968:	50                   	push   %eax
c0027969:	e8 f4 ed ff ff       	call   c0026762 <snprintf>
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c002796e:	83 c4 0c             	add    $0xc,%esp
c0027971:	6a 08                	push   $0x8
c0027973:	68 38 eb 02 c0       	push   $0xc002eb38
c0027978:	8d 43 6c             	lea    0x6c(%ebx),%eax
c002797b:	50                   	push   %eax
c002797c:	e8 60 fa ff ff       	call   c00273e1 <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
c0027981:	83 c4 0c             	add    $0xc,%esp
c0027984:	6a 08                	push   $0x8
c0027986:	68 38 eb 02 c0       	push   $0xc002eb38
c002798b:	8d 43 74             	lea    0x74(%ebx),%eax
c002798e:	50                   	push   %eax
c002798f:	e8 4d fa ff ff       	call   c00273e1 <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
c0027994:	ff 74 24 38          	pushl  0x38(%esp)
c0027998:	68 40 eb 02 c0       	push   $0xc002eb40
c002799d:	6a 0c                	push   $0xc
c002799f:	8d 43 7c             	lea    0x7c(%ebx),%eax
c00279a2:	50                   	push   %eax
c00279a3:	e8 ba ed ff ff       	call   c0026762 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c00279a8:	83 c4 20             	add    $0x20,%esp
c00279ab:	68 00 8c b7 43       	push   $0x43b78c00
c00279b0:	68 40 eb 02 c0       	push   $0xc002eb40
c00279b5:	6a 0c                	push   $0xc
c00279b7:	8d 83 88 00 00 00    	lea    0x88(%ebx),%eax
c00279bd:	50                   	push   %eax
c00279be:	e8 9f ed ff ff       	call   c0026762 <snprintf>
  h->typeflag = type;
c00279c3:	89 f0                	mov    %esi,%eax
c00279c5:	88 83 9c 00 00 00    	mov    %al,0x9c(%ebx)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c00279cb:	83 c4 0c             	add    $0xc,%esp
c00279ce:	6a 06                	push   $0x6
c00279d0:	68 46 eb 02 c0       	push   $0xc002eb46
c00279d5:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
c00279db:	50                   	push   %eax
c00279dc:	e8 00 fa ff ff       	call   c00273e1 <strlcpy>
  h->version[0] = h->version[1] = '0';
c00279e1:	c6 83 08 01 00 00 30 	movb   $0x30,0x108(%ebx)
c00279e8:	c6 83 07 01 00 00 30 	movb   $0x30,0x107(%ebx)
  strlcpy (h->gname, "root", sizeof h->gname);
c00279ef:	83 c4 0c             	add    $0xc,%esp
c00279f2:	6a 20                	push   $0x20
c00279f4:	68 54 e0 02 c0       	push   $0xc002e054
c00279f9:	8d 83 29 01 00 00    	lea    0x129(%ebx),%eax
c00279ff:	50                   	push   %eax
c0027a00:	e8 dc f9 ff ff       	call   c00273e1 <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
c0027a05:	83 c4 0c             	add    $0xc,%esp
c0027a08:	6a 20                	push   $0x20
c0027a0a:	68 54 e0 02 c0       	push   $0xc002e054
c0027a0f:	8d 83 09 01 00 00    	lea    0x109(%ebx),%eax
c0027a15:	50                   	push   %eax
c0027a16:	e8 c6 f9 ff ff       	call   c00273e1 <strlcpy>
c0027a1b:	83 c4 10             	add    $0x10,%esp
c0027a1e:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
{
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
c0027a23:	ba 00 00 00 00       	mov    $0x0,%edx
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
c0027a28:	83 f8 07             	cmp    $0x7,%eax
c0027a2b:	76 0a                	jbe    c0027a37 <ustar_make_header+0x1a0>
c0027a2d:	0f b6 8c 03 94 00 00 	movzbl 0x94(%ebx,%eax,1),%ecx
c0027a34:	00 
c0027a35:	eb 05                	jmp    c0027a3c <ustar_make_header+0x1a5>
c0027a37:	b9 20 00 00 00       	mov    $0x20,%ecx
c0027a3c:	01 ca                	add    %ecx,%edx
c0027a3e:	83 c0 01             	add    $0x1,%eax
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0027a41:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0027a46:	75 e0                	jne    c0027a28 <ustar_make_header+0x191>
  h->version[0] = h->version[1] = '0';
  strlcpy (h->gname, "root", sizeof h->gname);
  strlcpy (h->uname, "root", sizeof h->uname);

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0027a48:	52                   	push   %edx
c0027a49:	68 33 eb 02 c0       	push   $0xc002eb33
c0027a4e:	6a 08                	push   $0x8
c0027a50:	81 c3 94 00 00 00    	add    $0x94,%ebx
c0027a56:	53                   	push   %ebx
c0027a57:	e8 06 ed ff ff       	call   c0026762 <snprintf>

  return true;
c0027a5c:	83 c4 10             	add    $0x10,%esp
}
c0027a5f:	89 e8                	mov    %ebp,%eax
c0027a61:	83 c4 0c             	add    $0xc,%esp
c0027a64:	5b                   	pop    %ebx
c0027a65:	5e                   	pop    %esi
c0027a66:	5f                   	pop    %edi
c0027a67:	5d                   	pop    %ebp
c0027a68:	c3                   	ret    

c0027a69 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0027a69:	53                   	push   %ebx
c0027a6a:	83 ec 18             	sub    $0x18,%esp
c0027a6d:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0027a71:	8d 93 00 02 00 00    	lea    0x200(%ebx),%edx
c0027a77:	89 d8                	mov    %ebx,%eax
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
    if (*block++ != 0)
c0027a79:	83 c0 01             	add    $0x1,%eax
c0027a7c:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0027a80:	0f 85 1d 01 00 00    	jne    c0027ba3 <ustar_parse_header+0x13a>
/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
c0027a86:	39 d0                	cmp    %edx,%eax
c0027a88:	75 ef                	jne    c0027a79 <ustar_parse_header+0x10>
c0027a8a:	e9 3c 01 00 00       	jmp    c0027bcb <ustar_parse_header+0x162>

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
c0027a8f:	b9 60 eb 02 c0       	mov    $0xc002eb60,%ecx
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
c0027a94:	80 bb 07 01 00 00 30 	cmpb   $0x30,0x107(%ebx)
c0027a9b:	0f 85 4d 01 00 00    	jne    c0027bee <ustar_parse_header+0x185>
c0027aa1:	80 bb 08 01 00 00 30 	cmpb   $0x30,0x108(%ebx)
c0027aa8:	0f 85 40 01 00 00    	jne    c0027bee <ustar_parse_header+0x185>
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0027aae:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
c0027ab4:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0027ab8:	ba 08 00 00 00       	mov    $0x8,%edx
c0027abd:	e8 d1 fc ff ff       	call   c0027793 <parse_octal_field>
    return "corrupt chksum field";
c0027ac2:	b9 76 eb 02 c0       	mov    $0xc002eb76,%ecx
  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0027ac7:	84 c0                	test   %al,%al
c0027ac9:	0f 84 1f 01 00 00    	je     c0027bee <ustar_parse_header+0x185>
c0027acf:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
c0027ad4:	ba 00 00 00 00       	mov    $0x0,%edx
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
c0027ad9:	83 f8 07             	cmp    $0x7,%eax
c0027adc:	76 0a                	jbe    c0027ae8 <ustar_parse_header+0x7f>
c0027ade:	0f b6 8c 03 94 00 00 	movzbl 0x94(%ebx,%eax,1),%ecx
c0027ae5:	00 
c0027ae6:	eb 05                	jmp    c0027aed <ustar_parse_header+0x84>
c0027ae8:	b9 20 00 00 00       	mov    $0x20,%ecx
c0027aed:	01 ca                	add    %ecx,%edx
c0027aef:	83 c0 01             	add    $0x1,%eax
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0027af2:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0027af7:	75 e0                	jne    c0027ad9 <ustar_parse_header+0x70>
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
c0027af9:	b9 8b eb 02 c0       	mov    $0xc002eb8b,%ecx
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
c0027afe:	39 54 24 0c          	cmp    %edx,0xc(%esp)
c0027b02:	0f 85 e6 00 00 00    	jne    c0027bee <ustar_parse_header+0x185>
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
c0027b08:	b9 9d eb 02 c0       	mov    $0xc002eb9d,%ecx
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0027b0d:	80 7b 63 00          	cmpb   $0x0,0x63(%ebx)
c0027b11:	0f 85 d7 00 00 00    	jne    c0027bee <ustar_parse_header+0x185>
c0027b17:	80 bb 59 01 00 00 00 	cmpb   $0x0,0x159(%ebx)
c0027b1e:	0f 85 ca 00 00 00    	jne    c0027bee <ustar_parse_header+0x185>
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0027b24:	0f b6 83 9c 00 00 00 	movzbl 0x9c(%ebx),%eax
c0027b2b:	3c 30                	cmp    $0x30,%al
c0027b2d:	74 0d                	je     c0027b3c <ustar_parse_header+0xd3>
    return "unimplemented file type";
c0027b2f:	b9 b0 eb 02 c0       	mov    $0xc002ebb0,%ecx
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0027b34:	3c 35                	cmp    $0x35,%al
c0027b36:	0f 85 b2 00 00 00    	jne    c0027bee <ustar_parse_header+0x185>
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
c0027b3c:	3c 30                	cmp    $0x30,%al
c0027b3e:	75 30                	jne    c0027b70 <ustar_parse_header+0x107>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0027b40:	8d 43 7c             	lea    0x7c(%ebx),%eax
c0027b43:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0027b47:	ba 0c 00 00 00       	mov    $0xc,%edx
c0027b4c:	e8 42 fc ff ff       	call   c0027793 <parse_octal_field>
        return "corrupt file size field";
c0027b51:	b9 c8 eb 02 c0       	mov    $0xc002ebc8,%ecx
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0027b56:	84 c0                	test   %al,%al
c0027b58:	0f 84 90 00 00 00    	je     c0027bee <ustar_parse_header+0x185>
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
        return "file too large";
c0027b5e:	b9 e0 eb 02 c0       	mov    $0xc002ebe0,%ecx
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
c0027b63:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0027b68:	0f 88 80 00 00 00    	js     c0027bee <ustar_parse_header+0x185>
c0027b6e:	eb 08                	jmp    c0027b78 <ustar_parse_header+0x10f>
        return "file too large";
    }
  else
    size_ul = 0;
c0027b70:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0027b77:	00 

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0027b78:	89 d8                	mov    %ebx,%eax
c0027b7a:	e8 97 fc ff ff       	call   c0027816 <strip_antisocial_prefixes>
c0027b7f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0027b83:	89 01                	mov    %eax,(%ecx)
  *type = h->typeflag;
c0027b85:	0f be 83 9c 00 00 00 	movsbl 0x9c(%ebx),%eax
c0027b8c:	8b 5c 24 28          	mov    0x28(%esp),%ebx
c0027b90:	89 03                	mov    %eax,(%ebx)
  *size = size_ul;
c0027b92:	8b 44 24 08          	mov    0x8(%esp),%eax
c0027b96:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c0027b9a:	89 03                	mov    %eax,(%ebx)
  return NULL;
c0027b9c:	b9 00 00 00 00       	mov    $0x0,%ecx
c0027ba1:	eb 4b                	jmp    c0027bee <ustar_parse_header+0x185>
      *size = 0;
      return NULL;
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0027ba3:	83 ec 04             	sub    $0x4,%esp
c0027ba6:	6a 06                	push   $0x6
c0027ba8:	68 46 eb 02 c0       	push   $0xc002eb46
c0027bad:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
c0027bb3:	50                   	push   %eax
c0027bb4:	e8 03 f3 ff ff       	call   c0026ebc <memcmp>
c0027bb9:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c0027bbc:	b9 4c eb 02 c0       	mov    $0xc002eb4c,%ecx
      *size = 0;
      return NULL;
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0027bc1:	85 c0                	test   %eax,%eax
c0027bc3:	0f 84 c6 fe ff ff    	je     c0027a8f <ustar_parse_header+0x26>
c0027bc9:	eb 23                	jmp    c0027bee <ustar_parse_header+0x185>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
c0027bcb:	8b 44 24 24          	mov    0x24(%esp),%eax
c0027bcf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0027bd5:	8b 44 24 28          	mov    0x28(%esp),%eax
c0027bd9:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0027bdf:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0027be3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0027be9:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c0027bee:	89 c8                	mov    %ecx,%eax
c0027bf0:	83 c4 18             	add    $0x18,%esp
c0027bf3:	5b                   	pop    %ebx
c0027bf4:	c3                   	ret    

c0027bf5 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0027bf5:	55                   	push   %ebp
c0027bf6:	89 e5                	mov    %esp,%ebp
c0027bf8:	53                   	push   %ebx
c0027bf9:	83 ec 04             	sub    $0x4,%esp
c0027bfc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0027bff:	8b 53 04             	mov    0x4(%ebx),%edx
    case THREAD_RUNNING:  
      status = "RUNNING";
      break;

    case THREAD_READY:  
      status = "READY";
c0027c02:	b8 21 ec 02 c0       	mov    $0xc002ec21,%eax
print_stacktrace(struct thread *t, void *aux UNUSED)
{
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0027c07:	83 fa 01             	cmp    $0x1,%edx
c0027c0a:	74 1a                	je     c0027c26 <print_stacktrace+0x31>
    case THREAD_RUNNING:  
      status = "RUNNING";
c0027c0c:	b8 11 d6 02 c0       	mov    $0xc002d611,%eax
print_stacktrace(struct thread *t, void *aux UNUSED)
{
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
c0027c11:	83 fa 01             	cmp    $0x1,%edx
c0027c14:	72 10                	jb     c0027c26 <print_stacktrace+0x31>
c0027c16:	83 fa 02             	cmp    $0x2,%edx
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";
c0027c19:	ba 27 ec 02 c0       	mov    $0xc002ec27,%edx
c0027c1e:	b8 cb d5 02 c0       	mov    $0xc002d5cb,%eax
c0027c23:	0f 45 c2             	cmovne %edx,%eax

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0027c26:	83 ec 04             	sub    $0x4,%esp
c0027c29:	50                   	push   %eax
c0027c2a:	8d 43 08             	lea    0x8(%ebx),%eax
c0027c2d:	50                   	push   %eax
c0027c2e:	68 4c ec 02 c0       	push   $0xc002ec4c
c0027c33:	e8 1d e4 ff ff       	call   c0026055 <printf>

  if (t == thread_current()) 
c0027c38:	e8 9d 8d ff ff       	call   c00209da <thread_current>
c0027c3d:	83 c4 10             	add    $0x10,%esp
c0027c40:	39 c3                	cmp    %eax,%ebx
c0027c42:	75 08                	jne    c0027c4c <print_stacktrace+0x57>
    {
      frame = __builtin_frame_address (1);
c0027c44:	8b 5d 00             	mov    0x0(%ebp),%ebx
      retaddr = __builtin_return_address (0);
c0027c47:	8b 45 04             	mov    0x4(%ebp),%eax
c0027c4a:	eb 2c                	jmp    c0027c78 <print_stacktrace+0x83>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0027c4c:	8b 53 18             	mov    0x18(%ebx),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0027c4f:	81 c3 00 10 00 00    	add    $0x1000,%ebx
c0027c55:	39 da                	cmp    %ebx,%edx
c0027c57:	74 0a                	je     c0027c63 <print_stacktrace+0x6e>
c0027c59:	8b 42 10             	mov    0x10(%edx),%eax
c0027c5c:	3d 21 15 02 c0       	cmp    $0xc0021521,%eax
c0027c61:	75 12                	jne    c0027c75 <print_stacktrace+0x80>
        {
          printf (" thread was never scheduled.\n");
c0027c63:	83 ec 0c             	sub    $0xc,%esp
c0027c66:	68 2f ec 02 c0       	push   $0xc002ec2f
c0027c6b:	e8 94 1a 00 00       	call   c0029704 <puts>
          return;
c0027c70:	83 c4 10             	add    $0x10,%esp
c0027c73:	eb 53                	jmp    c0027cc8 <print_stacktrace+0xd3>
        }

      frame = (void **) saved_frame->ebp;
c0027c75:	8b 5a 08             	mov    0x8(%edx),%ebx
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
c0027c78:	83 ec 08             	sub    $0x8,%esp
c0027c7b:	50                   	push   %eax
c0027c7c:	68 8c e8 02 c0       	push   $0xc002e88c
c0027c81:	e8 cf e3 ff ff       	call   c0026055 <printf>
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0027c86:	83 c4 10             	add    $0x10,%esp
c0027c89:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0027c8f:	76 27                	jbe    c0027cb8 <print_stacktrace+0xc3>
c0027c91:	83 3b 00             	cmpl   $0x0,(%ebx)
c0027c94:	74 22                	je     c0027cb8 <print_stacktrace+0xc3>
    printf (" %p", frame[1]);
c0027c96:	83 ec 08             	sub    $0x8,%esp
c0027c99:	ff 73 04             	pushl  0x4(%ebx)
c0027c9c:	68 8c e8 02 c0       	push   $0xc002e88c
c0027ca1:	e8 af e3 ff ff       	call   c0026055 <printf>
      frame = (void **) saved_frame->ebp;
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0027ca6:	8b 1b                	mov    (%ebx),%ebx
c0027ca8:	83 c4 10             	add    $0x10,%esp
c0027cab:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
c0027cb1:	76 05                	jbe    c0027cb8 <print_stacktrace+0xc3>
c0027cb3:	83 3b 00             	cmpl   $0x0,(%ebx)
c0027cb6:	75 de                	jne    c0027c96 <print_stacktrace+0xa1>
    printf (" %p", frame[1]);
  printf (".\n");
c0027cb8:	83 ec 0c             	sub    $0xc,%esp
c0027cbb:	68 23 e4 02 c0       	push   $0xc002e423
c0027cc0:	e8 3f 1a 00 00       	call   c0029704 <puts>
c0027cc5:	83 c4 10             	add    $0x10,%esp
}
c0027cc8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027ccb:	c9                   	leave  
c0027ccc:	c3                   	ret    

c0027ccd <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0027ccd:	57                   	push   %edi
c0027cce:	56                   	push   %esi
c0027ccf:	53                   	push   %ebx
c0027cd0:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027cd4:	8b 74 24 14          	mov    0x14(%esp),%esi
c0027cd8:	8b 7c 24 18          	mov    0x18(%esp),%edi
  static int level;
  va_list args;

  intr_disable ();
c0027cdc:	e8 af 99 ff ff       	call   c0021690 <intr_disable>
  console_panic ();
c0027ce1:	e8 c5 19 00 00       	call   c00296ab <console_panic>

  level++;
c0027ce6:	a1 e0 95 03 c0       	mov    0xc00395e0,%eax
c0027ceb:	83 c0 01             	add    $0x1,%eax
c0027cee:	a3 e0 95 03 c0       	mov    %eax,0xc00395e0
  if (level == 1) 
c0027cf3:	83 f8 01             	cmp    $0x1,%eax
c0027cf6:	75 34                	jne    c0027d2c <debug_panic+0x5f>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0027cf8:	57                   	push   %edi
c0027cf9:	56                   	push   %esi
c0027cfa:	53                   	push   %ebx
c0027cfb:	68 74 ec 02 c0       	push   $0xc002ec74
c0027d00:	e8 50 e3 ff ff       	call   c0026055 <printf>

      va_start (args, message);
c0027d05:	8d 44 24 30          	lea    0x30(%esp),%eax
      vprintf (message, args);
c0027d09:	83 c4 08             	add    $0x8,%esp
c0027d0c:	50                   	push   %eax
c0027d0d:	ff 74 24 28          	pushl  0x28(%esp)
c0027d11:	e8 ba 19 00 00       	call   c00296d0 <vprintf>
      printf ("\n");
c0027d16:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0027d1d:	e8 53 1a 00 00       	call   c0029775 <putchar>
      va_end (args);

      debug_backtrace ();
c0027d22:	e8 99 dd ff ff       	call   c0025ac0 <debug_backtrace>
c0027d27:	83 c4 10             	add    $0x10,%esp
c0027d2a:	eb 15                	jmp    c0027d41 <debug_panic+0x74>
    }
  else if (level == 2)
c0027d2c:	83 f8 02             	cmp    $0x2,%eax
c0027d2f:	75 10                	jne    c0027d41 <debug_panic+0x74>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0027d31:	57                   	push   %edi
c0027d32:	56                   	push   %esi
c0027d33:	53                   	push   %ebx
c0027d34:	68 94 ec 02 c0       	push   $0xc002ec94
c0027d39:	e8 17 e3 ff ff       	call   c0026055 <printf>
c0027d3e:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c0027d41:	e8 1a c6 ff ff       	call   c0024360 <serial_flush>
  shutdown ();
c0027d46:	e8 ba dc ff ff       	call   c0025a05 <shutdown>
c0027d4b:	eb fe                	jmp    c0027d4b <debug_panic+0x7e>

c0027d4d <debug_backtrace_all>:
}

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0027d4d:	53                   	push   %ebx
c0027d4e:	83 ec 08             	sub    $0x8,%esp
  enum intr_level oldlevel = intr_disable ();
c0027d51:	e8 3a 99 ff ff       	call   c0021690 <intr_disable>
c0027d56:	89 c3                	mov    %eax,%ebx

  thread_foreach (print_stacktrace, 0);
c0027d58:	83 ec 08             	sub    $0x8,%esp
c0027d5b:	6a 00                	push   $0x0
c0027d5d:	68 f5 7b 02 c0       	push   $0xc0027bf5
c0027d62:	e8 b1 8f ff ff       	call   c0020d18 <thread_foreach>
  intr_set_level (oldlevel);
c0027d67:	89 1c 24             	mov    %ebx,(%esp)
c0027d6a:	e8 28 99 ff ff       	call   c0021697 <intr_set_level>
}
c0027d6f:	83 c4 18             	add    $0x18,%esp
c0027d72:	5b                   	pop    %ebx
c0027d73:	c3                   	ret    

c0027d74 <list_init>:
}

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0027d74:	83 ec 0c             	sub    $0xc,%esp
c0027d77:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0027d7b:	85 c0                	test   %eax,%eax
c0027d7d:	75 1e                	jne    c0027d9d <list_init+0x29>
c0027d7f:	83 ec 0c             	sub    $0xc,%esp
c0027d82:	68 be ec 02 c0       	push   $0xc002ecbe
c0027d87:	68 3f d2 02 c0       	push   $0xc002d23f
c0027d8c:	68 18 ce 02 c0       	push   $0xc002ce18
c0027d91:	6a 3f                	push   $0x3f
c0027d93:	68 cb ec 02 c0       	push   $0xc002eccb
c0027d98:	e8 30 ff ff ff       	call   c0027ccd <debug_panic>
  list->head.prev = NULL;
c0027d9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0027da3:	8d 50 08             	lea    0x8(%eax),%edx
c0027da6:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0027da9:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c0027dac:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0027db3:	83 c4 0c             	add    $0xc,%esp
c0027db6:	c3                   	ret    

c0027db7 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0027db7:	83 ec 0c             	sub    $0xc,%esp
c0027dba:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0027dbe:	85 c0                	test   %eax,%eax
c0027dc0:	75 1e                	jne    c0027de0 <list_begin+0x29>
c0027dc2:	83 ec 0c             	sub    $0xc,%esp
c0027dc5:	68 be ec 02 c0       	push   $0xc002ecbe
c0027dca:	68 3f d2 02 c0       	push   $0xc002d23f
c0027dcf:	68 0c ce 02 c0       	push   $0xc002ce0c
c0027dd4:	6a 4a                	push   $0x4a
c0027dd6:	68 cb ec 02 c0       	push   $0xc002eccb
c0027ddb:	e8 ed fe ff ff       	call   c0027ccd <debug_panic>
  return list->head.next;
c0027de0:	8b 40 04             	mov    0x4(%eax),%eax
}
c0027de3:	83 c4 0c             	add    $0xc,%esp
c0027de6:	c3                   	ret    

c0027de7 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0027de7:	83 ec 0c             	sub    $0xc,%esp
c0027dea:	8b 44 24 10          	mov    0x10(%esp),%eax

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0027dee:	85 c0                	test   %eax,%eax
c0027df0:	74 16                	je     c0027e08 <list_next+0x21>
c0027df2:	83 38 00             	cmpl   $0x0,(%eax)
c0027df5:	75 06                	jne    c0027dfd <list_next+0x16>
c0027df7:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0027dfb:	75 29                	jne    c0027e26 <list_next+0x3f>
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0027dfd:	83 38 00             	cmpl   $0x0,(%eax)
c0027e00:	74 06                	je     c0027e08 <list_next+0x21>
c0027e02:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0027e06:	75 1e                	jne    c0027e26 <list_next+0x3f>
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
  ASSERT (is_head (elem) || is_interior (elem));
c0027e08:	83 ec 0c             	sub    $0xc,%esp
c0027e0b:	68 74 ed 02 c0       	push   $0xc002ed74
c0027e10:	68 3f d2 02 c0       	push   $0xc002d23f
c0027e15:	68 00 ce 02 c0       	push   $0xc002ce00
c0027e1a:	6a 54                	push   $0x54
c0027e1c:	68 cb ec 02 c0       	push   $0xc002eccb
c0027e21:	e8 a7 fe ff ff       	call   c0027ccd <debug_panic>
  return elem->next;
c0027e26:	8b 40 04             	mov    0x4(%eax),%eax
}
c0027e29:	83 c4 0c             	add    $0xc,%esp
c0027e2c:	c3                   	ret    

c0027e2d <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0027e2d:	83 ec 0c             	sub    $0xc,%esp
c0027e30:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0027e34:	85 c0                	test   %eax,%eax
c0027e36:	75 1e                	jne    c0027e56 <list_end+0x29>
c0027e38:	83 ec 0c             	sub    $0xc,%esp
c0027e3b:	68 be ec 02 c0       	push   $0xc002ecbe
c0027e40:	68 3f d2 02 c0       	push   $0xc002d23f
c0027e45:	68 f4 cd 02 c0       	push   $0xc002cdf4
c0027e4a:	6a 60                	push   $0x60
c0027e4c:	68 cb ec 02 c0       	push   $0xc002eccb
c0027e51:	e8 77 fe ff ff       	call   c0027ccd <debug_panic>
  return &list->tail;
c0027e56:	83 c0 08             	add    $0x8,%eax
}
c0027e59:	83 c4 0c             	add    $0xc,%esp
c0027e5c:	c3                   	ret    

c0027e5d <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0027e5d:	83 ec 0c             	sub    $0xc,%esp
c0027e60:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c0027e64:	85 c0                	test   %eax,%eax
c0027e66:	75 1e                	jne    c0027e86 <list_rbegin+0x29>
c0027e68:	83 ec 0c             	sub    $0xc,%esp
c0027e6b:	68 be ec 02 c0       	push   $0xc002ecbe
c0027e70:	68 3f d2 02 c0       	push   $0xc002d23f
c0027e75:	68 e8 cd 02 c0       	push   $0xc002cde8
c0027e7a:	6a 69                	push   $0x69
c0027e7c:	68 cb ec 02 c0       	push   $0xc002eccb
c0027e81:	e8 47 fe ff ff       	call   c0027ccd <debug_panic>
  return list->tail.prev;
c0027e86:	8b 40 08             	mov    0x8(%eax),%eax
}
c0027e89:	83 c4 0c             	add    $0xc,%esp
c0027e8c:	c3                   	ret    

c0027e8d <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c0027e8d:	83 ec 0c             	sub    $0xc,%esp
c0027e90:	8b 44 24 10          	mov    0x10(%esp),%eax
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0027e94:	85 c0                	test   %eax,%eax
c0027e96:	74 16                	je     c0027eae <list_prev+0x21>
c0027e98:	83 38 00             	cmpl   $0x0,(%eax)
c0027e9b:	74 06                	je     c0027ea3 <list_prev+0x16>
c0027e9d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0027ea1:	75 29                	jne    c0027ecc <list_prev+0x3f>

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0027ea3:	83 38 00             	cmpl   $0x0,(%eax)
c0027ea6:	74 06                	je     c0027eae <list_prev+0x21>
c0027ea8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0027eac:	74 1e                	je     c0027ecc <list_prev+0x3f>
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
  ASSERT (is_interior (elem) || is_tail (elem));
c0027eae:	83 ec 0c             	sub    $0xc,%esp
c0027eb1:	68 9c ed 02 c0       	push   $0xc002ed9c
c0027eb6:	68 3f d2 02 c0       	push   $0xc002d23f
c0027ebb:	68 dc cd 02 c0       	push   $0xc002cddc
c0027ec0:	6a 73                	push   $0x73
c0027ec2:	68 cb ec 02 c0       	push   $0xc002eccb
c0027ec7:	e8 01 fe ff ff       	call   c0027ccd <debug_panic>
  return elem->prev;
c0027ecc:	8b 00                	mov    (%eax),%eax
}
c0027ece:	83 c4 0c             	add    $0xc,%esp
c0027ed1:	c3                   	ret    

c0027ed2 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0027ed2:	55                   	push   %ebp
c0027ed3:	57                   	push   %edi
c0027ed4:	56                   	push   %esi
c0027ed5:	53                   	push   %ebx
c0027ed6:	83 ec 0c             	sub    $0xc,%esp
c0027ed9:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  ASSERT (a != NULL);
c0027edd:	85 c0                	test   %eax,%eax
c0027edf:	75 21                	jne    c0027f02 <find_end_of_run+0x30>
c0027ee1:	83 ec 0c             	sub    $0xc,%esp
c0027ee4:	68 8d da 02 c0       	push   $0xc002da8d
c0027ee9:	68 3f d2 02 c0       	push   $0xc002d23f
c0027eee:	68 60 cd 02 c0       	push   $0xc002cd60
c0027ef3:	68 69 01 00 00       	push   $0x169
c0027ef8:	68 cb ec 02 c0       	push   $0xc002eccb
c0027efd:	e8 cb fd ff ff       	call   c0027ccd <debug_panic>
c0027f02:	89 c3                	mov    %eax,%ebx
c0027f04:	89 d6                	mov    %edx,%esi
c0027f06:	89 cf                	mov    %ecx,%edi
  ASSERT (b != NULL);
c0027f08:	85 d2                	test   %edx,%edx
c0027f0a:	75 21                	jne    c0027f2d <find_end_of_run+0x5b>
c0027f0c:	83 ec 0c             	sub    $0xc,%esp
c0027f0f:	68 95 ea 02 c0       	push   $0xc002ea95
c0027f14:	68 3f d2 02 c0       	push   $0xc002d23f
c0027f19:	68 60 cd 02 c0       	push   $0xc002cd60
c0027f1e:	68 6a 01 00 00       	push   $0x16a
c0027f23:	68 cb ec 02 c0       	push   $0xc002eccb
c0027f28:	e8 a0 fd ff ff       	call   c0027ccd <debug_panic>
  ASSERT (less != NULL);
c0027f2d:	85 c9                	test   %ecx,%ecx
c0027f2f:	75 21                	jne    c0027f52 <find_end_of_run+0x80>
c0027f31:	83 ec 0c             	sub    $0xc,%esp
c0027f34:	68 e3 ec 02 c0       	push   $0xc002ece3
c0027f39:	68 3f d2 02 c0       	push   $0xc002d23f
c0027f3e:	68 60 cd 02 c0       	push   $0xc002cd60
c0027f43:	68 6b 01 00 00       	push   $0x16b
c0027f48:	68 cb ec 02 c0       	push   $0xc002eccb
c0027f4d:	e8 7b fd ff ff       	call   c0027ccd <debug_panic>
  ASSERT (a != b);
c0027f52:	39 d0                	cmp    %edx,%eax
c0027f54:	75 21                	jne    c0027f77 <find_end_of_run+0xa5>
c0027f56:	83 ec 0c             	sub    $0xc,%esp
c0027f59:	68 f0 ec 02 c0       	push   $0xc002ecf0
c0027f5e:	68 3f d2 02 c0       	push   $0xc002d23f
c0027f63:	68 60 cd 02 c0       	push   $0xc002cd60
c0027f68:	68 6c 01 00 00       	push   $0x16c
c0027f6d:	68 cb ec 02 c0       	push   $0xc002eccb
c0027f72:	e8 56 fd ff ff       	call   c0027ccd <debug_panic>
  
  do 
    {
      a = list_next (a);
c0027f77:	83 ec 0c             	sub    $0xc,%esp
c0027f7a:	53                   	push   %ebx
c0027f7b:	e8 67 fe ff ff       	call   c0027de7 <list_next>
c0027f80:	83 c4 10             	add    $0x10,%esp
c0027f83:	89 c3                	mov    %eax,%ebx
    }
  while (a != b && !less (a, list_prev (a), aux));
c0027f85:	39 c6                	cmp    %eax,%esi
c0027f87:	74 18                	je     c0027fa1 <find_end_of_run+0xcf>
c0027f89:	83 ec 0c             	sub    $0xc,%esp
c0027f8c:	50                   	push   %eax
c0027f8d:	e8 fb fe ff ff       	call   c0027e8d <list_prev>
c0027f92:	83 c4 0c             	add    $0xc,%esp
c0027f95:	55                   	push   %ebp
c0027f96:	50                   	push   %eax
c0027f97:	53                   	push   %ebx
c0027f98:	ff d7                	call   *%edi
c0027f9a:	83 c4 10             	add    $0x10,%esp
c0027f9d:	84 c0                	test   %al,%al
c0027f9f:	74 d6                	je     c0027f77 <find_end_of_run+0xa5>
  return a;
}
c0027fa1:	89 d8                	mov    %ebx,%eax
c0027fa3:	83 c4 0c             	add    $0xc,%esp
c0027fa6:	5b                   	pop    %ebx
c0027fa7:	5e                   	pop    %esi
c0027fa8:	5f                   	pop    %edi
c0027fa9:	5d                   	pop    %ebp
c0027faa:	c3                   	ret    

c0027fab <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c0027fab:	55                   	push   %ebp
c0027fac:	57                   	push   %edi
c0027fad:	56                   	push   %esi
c0027fae:	53                   	push   %ebx
c0027faf:	83 ec 0c             	sub    $0xc,%esp
c0027fb2:	89 c3                	mov    %eax,%ebx
c0027fb4:	89 d6                	mov    %edx,%esi
c0027fb6:	89 cd                	mov    %ecx,%ebp
c0027fb8:	8b 7c 24 20          	mov    0x20(%esp),%edi
  if (a != b)
c0027fbc:	39 d0                	cmp    %edx,%eax
c0027fbe:	75 1f                	jne    c0027fdf <is_sorted+0x34>
    while ((a = list_next (a)) != b) 
      if (less (a, list_prev (a), aux))
        return false;
  return true;
c0027fc0:	b8 01 00 00 00       	mov    $0x1,%eax
c0027fc5:	eb 36                	jmp    c0027ffd <is_sorted+0x52>
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
      if (less (a, list_prev (a), aux))
c0027fc7:	83 ec 0c             	sub    $0xc,%esp
c0027fca:	53                   	push   %ebx
c0027fcb:	e8 bd fe ff ff       	call   c0027e8d <list_prev>
c0027fd0:	83 c4 0c             	add    $0xc,%esp
c0027fd3:	57                   	push   %edi
c0027fd4:	50                   	push   %eax
c0027fd5:	53                   	push   %ebx
c0027fd6:	ff d5                	call   *%ebp
c0027fd8:	83 c4 10             	add    $0x10,%esp
c0027fdb:	84 c0                	test   %al,%al
c0027fdd:	75 19                	jne    c0027ff8 <is_sorted+0x4d>
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
c0027fdf:	83 ec 0c             	sub    $0xc,%esp
c0027fe2:	53                   	push   %ebx
c0027fe3:	e8 ff fd ff ff       	call   c0027de7 <list_next>
c0027fe8:	83 c4 10             	add    $0x10,%esp
c0027feb:	89 c3                	mov    %eax,%ebx
c0027fed:	39 c6                	cmp    %eax,%esi
c0027fef:	75 d6                	jne    c0027fc7 <is_sorted+0x1c>
      if (less (a, list_prev (a), aux))
        return false;
  return true;
c0027ff1:	b8 01 00 00 00       	mov    $0x1,%eax
c0027ff6:	eb 05                	jmp    c0027ffd <is_sorted+0x52>
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
      if (less (a, list_prev (a), aux))
        return false;
c0027ff8:	b8 00 00 00 00       	mov    $0x0,%eax
  return true;
}
c0027ffd:	83 c4 0c             	add    $0xc,%esp
c0028000:	5b                   	pop    %ebx
c0028001:	5e                   	pop    %esi
c0028002:	5f                   	pop    %edi
c0028003:	5d                   	pop    %ebp
c0028004:	c3                   	ret    

c0028005 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0028005:	83 ec 0c             	sub    $0xc,%esp
c0028008:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002800c:	85 c0                	test   %eax,%eax
c002800e:	75 21                	jne    c0028031 <list_rend+0x2c>
c0028010:	83 ec 0c             	sub    $0xc,%esp
c0028013:	68 be ec 02 c0       	push   $0xc002ecbe
c0028018:	68 3f d2 02 c0       	push   $0xc002d23f
c002801d:	68 d0 cd 02 c0       	push   $0xc002cdd0
c0028022:	68 87 00 00 00       	push   $0x87
c0028027:	68 cb ec 02 c0       	push   $0xc002eccb
c002802c:	e8 9c fc ff ff       	call   c0027ccd <debug_panic>
  return &list->head;
}
c0028031:	83 c4 0c             	add    $0xc,%esp
c0028034:	c3                   	ret    

c0028035 <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0028035:	83 ec 0c             	sub    $0xc,%esp
c0028038:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002803c:	85 c0                	test   %eax,%eax
c002803e:	75 21                	jne    c0028061 <list_head+0x2c>
c0028040:	83 ec 0c             	sub    $0xc,%esp
c0028043:	68 be ec 02 c0       	push   $0xc002ecbe
c0028048:	68 3f d2 02 c0       	push   $0xc002d23f
c002804d:	68 c4 cd 02 c0       	push   $0xc002cdc4
c0028052:	68 99 00 00 00       	push   $0x99
c0028057:	68 cb ec 02 c0       	push   $0xc002eccb
c002805c:	e8 6c fc ff ff       	call   c0027ccd <debug_panic>
  return &list->head;
}
c0028061:	83 c4 0c             	add    $0xc,%esp
c0028064:	c3                   	ret    

c0028065 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0028065:	83 ec 0c             	sub    $0xc,%esp
c0028068:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT (list != NULL);
c002806c:	85 c0                	test   %eax,%eax
c002806e:	75 21                	jne    c0028091 <list_tail+0x2c>
c0028070:	83 ec 0c             	sub    $0xc,%esp
c0028073:	68 be ec 02 c0       	push   $0xc002ecbe
c0028078:	68 3f d2 02 c0       	push   $0xc002d23f
c002807d:	68 b8 cd 02 c0       	push   $0xc002cdb8
c0028082:	68 a1 00 00 00       	push   $0xa1
c0028087:	68 cb ec 02 c0       	push   $0xc002eccb
c002808c:	e8 3c fc ff ff       	call   c0027ccd <debug_panic>
  return &list->tail;
c0028091:	83 c0 08             	add    $0x8,%eax
}
c0028094:	83 c4 0c             	add    $0xc,%esp
c0028097:	c3                   	ret    

c0028098 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c0028098:	83 ec 0c             	sub    $0xc,%esp
c002809b:	8b 44 24 10          	mov    0x10(%esp),%eax
c002809f:	8b 54 24 14          	mov    0x14(%esp),%edx
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00280a3:	85 c0                	test   %eax,%eax
c00280a5:	74 4b                	je     c00280f2 <list_insert+0x5a>
c00280a7:	83 38 00             	cmpl   $0x0,(%eax)
c00280aa:	74 06                	je     c00280b2 <list_insert+0x1a>
c00280ac:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00280b0:	75 0b                	jne    c00280bd <list_insert+0x25>

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00280b2:	83 38 00             	cmpl   $0x0,(%eax)
c00280b5:	74 3b                	je     c00280f2 <list_insert+0x5a>
c00280b7:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00280bb:	75 35                	jne    c00280f2 <list_insert+0x5a>
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
  ASSERT (is_interior (before) || is_tail (before));
  ASSERT (elem != NULL);
c00280bd:	85 d2                	test   %edx,%edx
c00280bf:	75 21                	jne    c00280e2 <list_insert+0x4a>
c00280c1:	83 ec 0c             	sub    $0xc,%esp
c00280c4:	68 f7 ec 02 c0       	push   $0xc002ecf7
c00280c9:	68 3f d2 02 c0       	push   $0xc002d23f
c00280ce:	68 ac cd 02 c0       	push   $0xc002cdac
c00280d3:	68 ac 00 00 00       	push   $0xac
c00280d8:	68 cb ec 02 c0       	push   $0xc002eccb
c00280dd:	e8 eb fb ff ff       	call   c0027ccd <debug_panic>

  elem->prev = before->prev;
c00280e2:	8b 08                	mov    (%eax),%ecx
c00280e4:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c00280e6:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c00280e9:	8b 08                	mov    (%eax),%ecx
c00280eb:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c00280ee:	89 10                	mov    %edx,(%eax)
}
c00280f0:	eb 21                	jmp    c0028113 <list_insert+0x7b>
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
  ASSERT (is_interior (before) || is_tail (before));
c00280f2:	83 ec 0c             	sub    $0xc,%esp
c00280f5:	68 c4 ed 02 c0       	push   $0xc002edc4
c00280fa:	68 3f d2 02 c0       	push   $0xc002d23f
c00280ff:	68 ac cd 02 c0       	push   $0xc002cdac
c0028104:	68 ab 00 00 00       	push   $0xab
c0028109:	68 cb ec 02 c0       	push   $0xc002eccb
c002810e:	e8 ba fb ff ff       	call   c0027ccd <debug_panic>

  elem->prev = before->prev;
  elem->next = before;
  before->prev->next = elem;
  before->prev = elem;
}
c0028113:	83 c4 0c             	add    $0xc,%esp
c0028116:	c3                   	ret    

c0028117 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0028117:	56                   	push   %esi
c0028118:	53                   	push   %ebx
c0028119:	83 ec 04             	sub    $0x4,%esp
c002811c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0028120:	8b 74 24 14          	mov    0x14(%esp),%esi
c0028124:	8b 44 24 18          	mov    0x18(%esp),%eax
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028128:	85 db                	test   %ebx,%ebx
c002812a:	74 4a                	je     c0028176 <list_splice+0x5f>
c002812c:	83 3b 00             	cmpl   $0x0,(%ebx)
c002812f:	74 06                	je     c0028137 <list_splice+0x20>
c0028131:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028135:	75 0b                	jne    c0028142 <list_splice+0x2b>

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0028137:	83 3b 00             	cmpl   $0x0,(%ebx)
c002813a:	74 3a                	je     c0028176 <list_splice+0x5f>
c002813c:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
c0028140:	75 34                	jne    c0028176 <list_splice+0x5f>
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
  ASSERT (is_interior (before) || is_tail (before));
  if (first == last)
c0028142:	39 c6                	cmp    %eax,%esi
c0028144:	0f 84 ab 00 00 00    	je     c00281f5 <list_splice+0xde>
    return;
  last = list_prev (last);
c002814a:	83 ec 0c             	sub    $0xc,%esp
c002814d:	50                   	push   %eax
c002814e:	e8 3a fd ff ff       	call   c0027e8d <list_prev>
c0028153:	83 c4 10             	add    $0x10,%esp
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0028156:	85 f6                	test   %esi,%esi
c0028158:	74 3d                	je     c0028197 <list_splice+0x80>
c002815a:	8b 16                	mov    (%esi),%edx
c002815c:	85 d2                	test   %edx,%edx
c002815e:	74 37                	je     c0028197 <list_splice+0x80>
c0028160:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0028164:	75 52                	jne    c00281b8 <list_splice+0xa1>
c0028166:	eb 2f                	jmp    c0028197 <list_splice+0x80>
c0028168:	83 38 00             	cmpl   $0x0,(%eax)
c002816b:	74 4f                	je     c00281bc <list_splice+0xa5>
c002816d:	8b 48 04             	mov    0x4(%eax),%ecx
c0028170:	85 c9                	test   %ecx,%ecx
c0028172:	75 69                	jne    c00281dd <list_splice+0xc6>
c0028174:	eb 46                	jmp    c00281bc <list_splice+0xa5>
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
  ASSERT (is_interior (before) || is_tail (before));
c0028176:	83 ec 0c             	sub    $0xc,%esp
c0028179:	68 c4 ed 02 c0       	push   $0xc002edc4
c002817e:	68 3f d2 02 c0       	push   $0xc002d23f
c0028183:	68 a0 cd 02 c0       	push   $0xc002cda0
c0028188:	68 bb 00 00 00       	push   $0xbb
c002818d:	68 cb ec 02 c0       	push   $0xc002eccb
c0028192:	e8 36 fb ff ff       	call   c0027ccd <debug_panic>
  if (first == last)
    return;
  last = list_prev (last);

  ASSERT (is_interior (first));
c0028197:	83 ec 0c             	sub    $0xc,%esp
c002819a:	68 04 ed 02 c0       	push   $0xc002ed04
c002819f:	68 3f d2 02 c0       	push   $0xc002d23f
c00281a4:	68 a0 cd 02 c0       	push   $0xc002cda0
c00281a9:	68 c0 00 00 00       	push   $0xc0
c00281ae:	68 cb ec 02 c0       	push   $0xc002eccb
c00281b3:	e8 15 fb ff ff       	call   c0027ccd <debug_panic>
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c00281b8:	85 c0                	test   %eax,%eax
c00281ba:	75 ac                	jne    c0028168 <list_splice+0x51>
  if (first == last)
    return;
  last = list_prev (last);

  ASSERT (is_interior (first));
  ASSERT (is_interior (last));
c00281bc:	83 ec 0c             	sub    $0xc,%esp
c00281bf:	68 18 ed 02 c0       	push   $0xc002ed18
c00281c4:	68 3f d2 02 c0       	push   $0xc002d23f
c00281c9:	68 a0 cd 02 c0       	push   $0xc002cda0
c00281ce:	68 c1 00 00 00       	push   $0xc1
c00281d3:	68 cb ec 02 c0       	push   $0xc002eccb
c00281d8:	e8 f0 fa ff ff       	call   c0027ccd <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c00281dd:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c00281e0:	8b 50 04             	mov    0x4(%eax),%edx
c00281e3:	8b 0e                	mov    (%esi),%ecx
c00281e5:	89 0a                	mov    %ecx,(%edx)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c00281e7:	8b 13                	mov    (%ebx),%edx
c00281e9:	89 16                	mov    %edx,(%esi)
  last->next = before;
c00281eb:	89 58 04             	mov    %ebx,0x4(%eax)
  before->prev->next = first;
c00281ee:	8b 13                	mov    (%ebx),%edx
c00281f0:	89 72 04             	mov    %esi,0x4(%edx)
  before->prev = last;
c00281f3:	89 03                	mov    %eax,(%ebx)
}
c00281f5:	83 c4 04             	add    $0x4,%esp
c00281f8:	5b                   	pop    %ebx
c00281f9:	5e                   	pop    %esi
c00281fa:	c3                   	ret    

c00281fb <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c00281fb:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_begin (list), elem);
c00281fe:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028202:	e8 b0 fb ff ff       	call   c0027db7 <list_begin>
c0028207:	83 c4 08             	add    $0x8,%esp
c002820a:	ff 74 24 1c          	pushl  0x1c(%esp)
c002820e:	50                   	push   %eax
c002820f:	e8 84 fe ff ff       	call   c0028098 <list_insert>
}
c0028214:	83 c4 1c             	add    $0x1c,%esp
c0028217:	c3                   	ret    

c0028218 <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0028218:	83 ec 18             	sub    $0x18,%esp
  list_insert (list_end (list), elem);
c002821b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002821f:	e8 09 fc ff ff       	call   c0027e2d <list_end>
c0028224:	83 c4 08             	add    $0x8,%esp
c0028227:	ff 74 24 1c          	pushl  0x1c(%esp)
c002822b:	50                   	push   %eax
c002822c:	e8 67 fe ff ff       	call   c0028098 <list_insert>
}
c0028231:	83 c4 1c             	add    $0x1c,%esp
c0028234:	c3                   	ret    

c0028235 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0028235:	83 ec 0c             	sub    $0xc,%esp
c0028238:	8b 44 24 10          	mov    0x10(%esp),%eax
/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002823c:	85 c0                	test   %eax,%eax
c002823e:	74 0d                	je     c002824d <list_remove+0x18>
c0028240:	8b 10                	mov    (%eax),%edx
c0028242:	85 d2                	test   %edx,%edx
c0028244:	74 07                	je     c002824d <list_remove+0x18>
c0028246:	8b 48 04             	mov    0x4(%eax),%ecx
c0028249:	85 c9                	test   %ecx,%ecx
c002824b:	75 21                	jne    c002826e <list_remove+0x39>
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
  ASSERT (is_interior (elem));
c002824d:	83 ec 0c             	sub    $0xc,%esp
c0028250:	68 2b ed 02 c0       	push   $0xc002ed2b
c0028255:	68 3f d2 02 c0       	push   $0xc002d23f
c002825a:	68 94 cd 02 c0       	push   $0xc002cd94
c002825f:	68 fb 00 00 00       	push   $0xfb
c0028264:	68 cb ec 02 c0       	push   $0xc002eccb
c0028269:	e8 5f fa ff ff       	call   c0027ccd <debug_panic>
  elem->prev->next = elem->next;
c002826e:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0028271:	8b 50 04             	mov    0x4(%eax),%edx
c0028274:	8b 08                	mov    (%eax),%ecx
c0028276:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c0028278:	8b 40 04             	mov    0x4(%eax),%eax
}
c002827b:	83 c4 0c             	add    $0xc,%esp
c002827e:	c3                   	ret    

c002827f <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c002827f:	57                   	push   %edi
c0028280:	56                   	push   %esi
c0028281:	53                   	push   %ebx
c0028282:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct list_elem *e;
  size_t cnt = 0;

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028286:	83 ec 0c             	sub    $0xc,%esp
c0028289:	57                   	push   %edi
c002828a:	e8 28 fb ff ff       	call   c0027db7 <list_begin>
c002828f:	83 c4 10             	add    $0x10,%esp
c0028292:	89 c3                	mov    %eax,%ebx
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
  struct list_elem *e;
  size_t cnt = 0;
c0028294:	be 00 00 00 00       	mov    $0x0,%esi

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028299:	eb 11                	jmp    c00282ac <list_size+0x2d>
    cnt++;
c002829b:	83 c6 01             	add    $0x1,%esi
list_size (struct list *list)
{
  struct list_elem *e;
  size_t cnt = 0;

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002829e:	83 ec 0c             	sub    $0xc,%esp
c00282a1:	53                   	push   %ebx
c00282a2:	e8 40 fb ff ff       	call   c0027de7 <list_next>
c00282a7:	83 c4 10             	add    $0x10,%esp
c00282aa:	89 c3                	mov    %eax,%ebx
c00282ac:	83 ec 0c             	sub    $0xc,%esp
c00282af:	57                   	push   %edi
c00282b0:	e8 78 fb ff ff       	call   c0027e2d <list_end>
c00282b5:	83 c4 10             	add    $0x10,%esp
c00282b8:	39 c3                	cmp    %eax,%ebx
c00282ba:	75 df                	jne    c002829b <list_size+0x1c>
    cnt++;
  return cnt;
}
c00282bc:	89 f0                	mov    %esi,%eax
c00282be:	5b                   	pop    %ebx
c00282bf:	5e                   	pop    %esi
c00282c0:	5f                   	pop    %edi
c00282c1:	c3                   	ret    

c00282c2 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c00282c2:	56                   	push   %esi
c00282c3:	53                   	push   %ebx
c00282c4:	83 ec 10             	sub    $0x10,%esp
c00282c7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin (list) == list_end (list);
c00282cb:	53                   	push   %ebx
c00282cc:	e8 e6 fa ff ff       	call   c0027db7 <list_begin>
c00282d1:	89 c6                	mov    %eax,%esi
c00282d3:	89 1c 24             	mov    %ebx,(%esp)
c00282d6:	e8 52 fb ff ff       	call   c0027e2d <list_end>
c00282db:	39 c6                	cmp    %eax,%esi
c00282dd:	0f 94 c0             	sete   %al
}
c00282e0:	83 c4 14             	add    $0x14,%esp
c00282e3:	5b                   	pop    %ebx
c00282e4:	5e                   	pop    %esi
c00282e5:	c3                   	ret    

c00282e6 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c00282e6:	53                   	push   %ebx
c00282e7:	83 ec 14             	sub    $0x14,%esp
c00282ea:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c00282ee:	53                   	push   %ebx
c00282ef:	e8 ce ff ff ff       	call   c00282c2 <list_empty>
c00282f4:	83 c4 10             	add    $0x10,%esp
c00282f7:	84 c0                	test   %al,%al
c00282f9:	74 21                	je     c002831c <list_front+0x36>
c00282fb:	83 ec 0c             	sub    $0xc,%esp
c00282fe:	68 3e ed 02 c0       	push   $0xc002ed3e
c0028303:	68 3f d2 02 c0       	push   $0xc002d23f
c0028308:	68 88 cd 02 c0       	push   $0xc002cd88
c002830d:	68 1a 01 00 00       	push   $0x11a
c0028312:	68 cb ec 02 c0       	push   $0xc002eccb
c0028317:	e8 b1 f9 ff ff       	call   c0027ccd <debug_panic>
  return list->head.next;
c002831c:	8b 43 04             	mov    0x4(%ebx),%eax
}
c002831f:	83 c4 08             	add    $0x8,%esp
c0028322:	5b                   	pop    %ebx
c0028323:	c3                   	ret    

c0028324 <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0028324:	53                   	push   %ebx
c0028325:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front (list);
c0028328:	ff 74 24 1c          	pushl  0x1c(%esp)
c002832c:	e8 b5 ff ff ff       	call   c00282e6 <list_front>
c0028331:	89 c3                	mov    %eax,%ebx
  list_remove (front);
c0028333:	89 04 24             	mov    %eax,(%esp)
c0028336:	e8 fa fe ff ff       	call   c0028235 <list_remove>
  return front;
}
c002833b:	89 d8                	mov    %ebx,%eax
c002833d:	83 c4 18             	add    $0x18,%esp
c0028340:	5b                   	pop    %ebx
c0028341:	c3                   	ret    

c0028342 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0028342:	53                   	push   %ebx
c0028343:	83 ec 14             	sub    $0x14,%esp
c0028346:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  ASSERT (!list_empty (list));
c002834a:	53                   	push   %ebx
c002834b:	e8 72 ff ff ff       	call   c00282c2 <list_empty>
c0028350:	83 c4 10             	add    $0x10,%esp
c0028353:	84 c0                	test   %al,%al
c0028355:	74 21                	je     c0028378 <list_back+0x36>
c0028357:	83 ec 0c             	sub    $0xc,%esp
c002835a:	68 3e ed 02 c0       	push   $0xc002ed3e
c002835f:	68 3f d2 02 c0       	push   $0xc002d23f
c0028364:	68 7c cd 02 c0       	push   $0xc002cd7c
c0028369:	68 23 01 00 00       	push   $0x123
c002836e:	68 cb ec 02 c0       	push   $0xc002eccb
c0028373:	e8 55 f9 ff ff       	call   c0027ccd <debug_panic>
  return list->tail.prev;
c0028378:	8b 43 08             	mov    0x8(%ebx),%eax
}
c002837b:	83 c4 08             	add    $0x8,%esp
c002837e:	5b                   	pop    %ebx
c002837f:	c3                   	ret    

c0028380 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0028380:	53                   	push   %ebx
c0028381:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back (list);
c0028384:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028388:	e8 b5 ff ff ff       	call   c0028342 <list_back>
c002838d:	89 c3                	mov    %eax,%ebx
  list_remove (back);
c002838f:	89 04 24             	mov    %eax,(%esp)
c0028392:	e8 9e fe ff ff       	call   c0028235 <list_remove>
  return back;
}
c0028397:	89 d8                	mov    %ebx,%eax
c0028399:	83 c4 18             	add    $0x18,%esp
c002839c:	5b                   	pop    %ebx
c002839d:	c3                   	ret    

c002839e <list_reverse>:
}

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c002839e:	56                   	push   %esi
c002839f:	53                   	push   %ebx
c00283a0:	83 ec 10             	sub    $0x10,%esp
c00283a3:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty (list)) 
c00283a7:	56                   	push   %esi
c00283a8:	e8 15 ff ff ff       	call   c00282c2 <list_empty>
c00283ad:	83 c4 10             	add    $0x10,%esp
c00283b0:	84 c0                	test   %al,%al
c00283b2:	75 42                	jne    c00283f6 <list_reverse+0x58>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c00283b4:	83 ec 0c             	sub    $0xc,%esp
c00283b7:	56                   	push   %esi
c00283b8:	e8 fa f9 ff ff       	call   c0027db7 <list_begin>
c00283bd:	83 c4 10             	add    $0x10,%esp
c00283c0:	89 c3                	mov    %eax,%ebx
c00283c2:	eb 0c                	jmp    c00283d0 <list_reverse+0x32>

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
  struct list_elem *t = *a;
c00283c4:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c00283c6:	8b 43 04             	mov    0x4(%ebx),%eax
c00283c9:	89 03                	mov    %eax,(%ebx)
  *b = t;
c00283cb:	89 53 04             	mov    %edx,0x4(%ebx)
{
  if (!list_empty (list)) 
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c00283ce:	89 c3                	mov    %eax,%ebx
c00283d0:	83 ec 0c             	sub    $0xc,%esp
c00283d3:	56                   	push   %esi
c00283d4:	e8 54 fa ff ff       	call   c0027e2d <list_end>
c00283d9:	83 c4 10             	add    $0x10,%esp
c00283dc:	39 c3                	cmp    %eax,%ebx
c00283de:	75 e4                	jne    c00283c4 <list_reverse+0x26>

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
  struct list_elem *t = *a;
c00283e0:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c00283e3:	8b 56 08             	mov    0x8(%esi),%edx
c00283e6:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c00283e9:	89 46 08             	mov    %eax,0x8(%esi)

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
  struct list_elem *t = *a;
c00283ec:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c00283ee:	8b 58 04             	mov    0x4(%eax),%ebx
c00283f1:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c00283f3:	89 48 04             	mov    %ecx,0x4(%eax)
      for (e = list_begin (list); e != list_end (list); e = e->prev)
        swap (&e->prev, &e->next);
      swap (&list->head.next, &list->tail.prev);
      swap (&list->head.next->prev, &list->tail.prev->next);
    }
}
c00283f6:	83 c4 04             	add    $0x4,%esp
c00283f9:	5b                   	pop    %ebx
c00283fa:	5e                   	pop    %esi
c00283fb:	c3                   	ret    

c00283fc <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c00283fc:	55                   	push   %ebp
c00283fd:	57                   	push   %edi
c00283fe:	56                   	push   %esi
c00283ff:	53                   	push   %ebx
c0028400:	83 ec 1c             	sub    $0x1c,%esp
c0028403:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0028407:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002840b:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028410:	75 21                	jne    c0028433 <list_sort+0x37>
c0028412:	83 ec 0c             	sub    $0xc,%esp
c0028415:	68 be ec 02 c0       	push   $0xc002ecbe
c002841a:	68 3f d2 02 c0       	push   $0xc002d23f
c002841f:	68 70 cd 02 c0       	push   $0xc002cd70
c0028424:	68 99 01 00 00       	push   $0x199
c0028429:	68 cb ec 02 c0       	push   $0xc002eccb
c002842e:	e8 9a f8 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (less != NULL);
c0028433:	85 ed                	test   %ebp,%ebp
c0028435:	75 21                	jne    c0028458 <list_sort+0x5c>
c0028437:	83 ec 0c             	sub    $0xc,%esp
c002843a:	68 e3 ec 02 c0       	push   $0xc002ece3
c002843f:	68 3f d2 02 c0       	push   $0xc002d23f
c0028444:	68 70 cd 02 c0       	push   $0xc002cd70
c0028449:	68 9a 01 00 00       	push   $0x19a
c002844e:	68 cb ec 02 c0       	push   $0xc002eccb
c0028453:	e8 75 f8 ff ff       	call   c0027ccd <debug_panic>
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028458:	83 ec 0c             	sub    $0xc,%esp
c002845b:	ff 74 24 3c          	pushl  0x3c(%esp)
c002845f:	e8 53 f9 ff ff       	call   c0027db7 <list_begin>
c0028464:	83 c4 10             	add    $0x10,%esp
c0028467:	89 c6                	mov    %eax,%esi
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c0028469:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028470:	00 
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c0028471:	e9 73 01 00 00       	jmp    c00285e9 <list_sort+0x1ed>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c0028476:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002847b:	83 ec 0c             	sub    $0xc,%esp
c002847e:	57                   	push   %edi
c002847f:	89 e9                	mov    %ebp,%ecx
c0028481:	89 c2                	mov    %eax,%edx
c0028483:	89 f0                	mov    %esi,%eax
c0028485:	e8 48 fa ff ff       	call   c0027ed2 <find_end_of_run>
c002848a:	89 c3                	mov    %eax,%ebx
          if (a1b0 == list_end (list))
c002848c:	83 c4 04             	add    $0x4,%esp
c002848f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028493:	e8 95 f9 ff ff       	call   c0027e2d <list_end>
c0028498:	83 c4 10             	add    $0x10,%esp
c002849b:	39 c3                	cmp    %eax,%ebx
c002849d:	0f 84 5d 01 00 00    	je     c0028600 <list_sort+0x204>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c00284a3:	83 ec 0c             	sub    $0xc,%esp
c00284a6:	57                   	push   %edi
c00284a7:	89 e9                	mov    %ebp,%ecx
c00284a9:	89 c2                	mov    %eax,%edx
c00284ab:	89 d8                	mov    %ebx,%eax
c00284ad:	e8 20 fa ff ff       	call   c0027ed2 <find_end_of_run>
c00284b2:	89 44 24 18          	mov    %eax,0x18(%esp)
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
  ASSERT (a0 != NULL);
c00284b6:	83 c4 10             	add    $0x10,%esp
c00284b9:	85 f6                	test   %esi,%esi
c00284bb:	75 21                	jne    c00284de <list_sort+0xe2>
c00284bd:	83 ec 0c             	sub    $0xc,%esp
c00284c0:	68 51 ed 02 c0       	push   $0xc002ed51
c00284c5:	68 3f d2 02 c0       	push   $0xc002d23f
c00284ca:	68 50 cd 02 c0       	push   $0xc002cd50
c00284cf:	68 80 01 00 00       	push   $0x180
c00284d4:	68 cb ec 02 c0       	push   $0xc002eccb
c00284d9:	e8 ef f7 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (a1b0 != NULL);
c00284de:	85 db                	test   %ebx,%ebx
c00284e0:	75 21                	jne    c0028503 <list_sort+0x107>
c00284e2:	83 ec 0c             	sub    $0xc,%esp
c00284e5:	68 5c ed 02 c0       	push   $0xc002ed5c
c00284ea:	68 3f d2 02 c0       	push   $0xc002d23f
c00284ef:	68 50 cd 02 c0       	push   $0xc002cd50
c00284f4:	68 81 01 00 00       	push   $0x181
c00284f9:	68 cb ec 02 c0       	push   $0xc002eccb
c00284fe:	e8 ca f7 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (b1 != NULL);
c0028503:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028508:	75 21                	jne    c002852b <list_sort+0x12f>
c002850a:	83 ec 0c             	sub    $0xc,%esp
c002850d:	68 69 ed 02 c0       	push   $0xc002ed69
c0028512:	68 3f d2 02 c0       	push   $0xc002d23f
c0028517:	68 50 cd 02 c0       	push   $0xc002cd50
c002851c:	68 82 01 00 00       	push   $0x182
c0028521:	68 cb ec 02 c0       	push   $0xc002eccb
c0028526:	e8 a2 f7 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (less != NULL);
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002852b:	83 ec 0c             	sub    $0xc,%esp
c002852e:	57                   	push   %edi
c002852f:	89 e9                	mov    %ebp,%ecx
c0028531:	89 da                	mov    %ebx,%edx
c0028533:	89 f0                	mov    %esi,%eax
c0028535:	e8 71 fa ff ff       	call   c0027fab <is_sorted>
c002853a:	83 c4 10             	add    $0x10,%esp
c002853d:	84 c0                	test   %al,%al
c002853f:	75 21                	jne    c0028562 <list_sort+0x166>
c0028541:	83 ec 0c             	sub    $0xc,%esp
c0028544:	68 f0 ed 02 c0       	push   $0xc002edf0
c0028549:	68 3f d2 02 c0       	push   $0xc002d23f
c002854e:	68 50 cd 02 c0       	push   $0xc002cd50
c0028553:	68 84 01 00 00       	push   $0x184
c0028558:	68 cb ec 02 c0       	push   $0xc002eccb
c002855d:	e8 6b f7 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c0028562:	83 ec 0c             	sub    $0xc,%esp
c0028565:	57                   	push   %edi
c0028566:	89 e9                	mov    %ebp,%ecx
c0028568:	8b 54 24 18          	mov    0x18(%esp),%edx
c002856c:	89 d8                	mov    %ebx,%eax
c002856e:	e8 38 fa ff ff       	call   c0027fab <is_sorted>
c0028573:	83 c4 10             	add    $0x10,%esp
c0028576:	84 c0                	test   %al,%al
c0028578:	75 61                	jne    c00285db <list_sort+0x1df>
c002857a:	83 ec 0c             	sub    $0xc,%esp
c002857d:	68 10 ee 02 c0       	push   $0xc002ee10
c0028582:	68 3f d2 02 c0       	push   $0xc002d23f
c0028587:	68 50 cd 02 c0       	push   $0xc002cd50
c002858c:	68 85 01 00 00       	push   $0x185
c0028591:	68 cb ec 02 c0       	push   $0xc002eccb
c0028596:	e8 32 f7 ff ff       	call   c0027ccd <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002859b:	83 ec 04             	sub    $0x4,%esp
c002859e:	57                   	push   %edi
c002859f:	56                   	push   %esi
c00285a0:	53                   	push   %ebx
c00285a1:	ff d5                	call   *%ebp
c00285a3:	83 c4 10             	add    $0x10,%esp
c00285a6:	84 c0                	test   %al,%al
c00285a8:	75 10                	jne    c00285ba <list_sort+0x1be>
      a0 = list_next (a0);
c00285aa:	83 ec 0c             	sub    $0xc,%esp
c00285ad:	56                   	push   %esi
c00285ae:	e8 34 f8 ff ff       	call   c0027de7 <list_next>
c00285b3:	83 c4 10             	add    $0x10,%esp
c00285b6:	89 c6                	mov    %eax,%esi
c00285b8:	eb 21                	jmp    c00285db <list_sort+0x1df>
    else 
      {
        a1b0 = list_next (a1b0);
c00285ba:	83 ec 0c             	sub    $0xc,%esp
c00285bd:	53                   	push   %ebx
c00285be:	e8 24 f8 ff ff       	call   c0027de7 <list_next>
c00285c3:	89 c3                	mov    %eax,%ebx
        list_splice (a0, list_prev (a1b0), a1b0);
c00285c5:	89 04 24             	mov    %eax,(%esp)
c00285c8:	e8 c0 f8 ff ff       	call   c0027e8d <list_prev>
c00285cd:	83 c4 0c             	add    $0xc,%esp
c00285d0:	53                   	push   %ebx
c00285d1:	50                   	push   %eax
c00285d2:	56                   	push   %esi
c00285d3:	e8 3f fb ff ff       	call   c0028117 <list_splice>
c00285d8:	83 c4 10             	add    $0x10,%esp
  ASSERT (b1 != NULL);
  ASSERT (less != NULL);
  ASSERT (is_sorted (a0, a1b0, less, aux));
  ASSERT (is_sorted (a1b0, b1, less, aux));

  while (a0 != a1b0 && a1b0 != b1)
c00285db:	39 f3                	cmp    %esi,%ebx
c00285dd:	74 06                	je     c00285e5 <list_sort+0x1e9>
c00285df:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
c00285e3:	75 b6                	jne    c002859b <list_sort+0x19f>
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c00285e5:	8b 74 24 08          	mov    0x8(%esp),%esi
c00285e9:	83 ec 0c             	sub    $0xc,%esp
c00285ec:	ff 74 24 3c          	pushl  0x3c(%esp)
c00285f0:	e8 38 f8 ff ff       	call   c0027e2d <list_end>
c00285f5:	83 c4 10             	add    $0x10,%esp
c00285f8:	39 c6                	cmp    %eax,%esi
c00285fa:	0f 85 76 fe ff ff    	jne    c0028476 <list_sort+0x7a>

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c0028600:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c0028605:	0f 87 4d fe ff ff    	ja     c0028458 <list_sort+0x5c>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002860b:	83 ec 0c             	sub    $0xc,%esp
c002860e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028612:	e8 16 f8 ff ff       	call   c0027e2d <list_end>
c0028617:	83 c4 04             	add    $0x4,%esp
c002861a:	89 c3                	mov    %eax,%ebx
c002861c:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028620:	e8 92 f7 ff ff       	call   c0027db7 <list_begin>
c0028625:	89 3c 24             	mov    %edi,(%esp)
c0028628:	89 e9                	mov    %ebp,%ecx
c002862a:	89 da                	mov    %ebx,%edx
c002862c:	e8 7a f9 ff ff       	call   c0027fab <is_sorted>
c0028631:	83 c4 10             	add    $0x10,%esp
c0028634:	84 c0                	test   %al,%al
c0028636:	75 21                	jne    c0028659 <list_sort+0x25d>
c0028638:	83 ec 0c             	sub    $0xc,%esp
c002863b:	68 30 ee 02 c0       	push   $0xc002ee30
c0028640:	68 3f d2 02 c0       	push   $0xc002d23f
c0028645:	68 70 cd 02 c0       	push   $0xc002cd70
c002864a:	68 b7 01 00 00       	push   $0x1b7
c002864f:	68 cb ec 02 c0       	push   $0xc002eccb
c0028654:	e8 74 f6 ff ff       	call   c0027ccd <debug_panic>
}
c0028659:	83 c4 1c             	add    $0x1c,%esp
c002865c:	5b                   	pop    %ebx
c002865d:	5e                   	pop    %esi
c002865e:	5f                   	pop    %edi
c002865f:	5d                   	pop    %ebp
c0028660:	c3                   	ret    

c0028661 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c0028661:	55                   	push   %ebp
c0028662:	57                   	push   %edi
c0028663:	56                   	push   %esi
c0028664:	53                   	push   %ebx
c0028665:	83 ec 0c             	sub    $0xc,%esp
c0028668:	8b 74 24 20          	mov    0x20(%esp),%esi
c002866c:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0028670:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT (list != NULL);
c0028674:	85 f6                	test   %esi,%esi
c0028676:	75 21                	jne    c0028699 <list_insert_ordered+0x38>
c0028678:	83 ec 0c             	sub    $0xc,%esp
c002867b:	68 be ec 02 c0       	push   $0xc002ecbe
c0028680:	68 3f d2 02 c0       	push   $0xc002d23f
c0028685:	68 3c cd 02 c0       	push   $0xc002cd3c
c002868a:	68 c3 01 00 00       	push   $0x1c3
c002868f:	68 cb ec 02 c0       	push   $0xc002eccb
c0028694:	e8 34 f6 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (elem != NULL);
c0028699:	85 ff                	test   %edi,%edi
c002869b:	75 21                	jne    c00286be <list_insert_ordered+0x5d>
c002869d:	83 ec 0c             	sub    $0xc,%esp
c00286a0:	68 f7 ec 02 c0       	push   $0xc002ecf7
c00286a5:	68 3f d2 02 c0       	push   $0xc002d23f
c00286aa:	68 3c cd 02 c0       	push   $0xc002cd3c
c00286af:	68 c4 01 00 00       	push   $0x1c4
c00286b4:	68 cb ec 02 c0       	push   $0xc002eccb
c00286b9:	e8 0f f6 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (less != NULL);
c00286be:	85 ed                	test   %ebp,%ebp
c00286c0:	75 21                	jne    c00286e3 <list_insert_ordered+0x82>
c00286c2:	83 ec 0c             	sub    $0xc,%esp
c00286c5:	68 e3 ec 02 c0       	push   $0xc002ece3
c00286ca:	68 3f d2 02 c0       	push   $0xc002d23f
c00286cf:	68 3c cd 02 c0       	push   $0xc002cd3c
c00286d4:	68 c5 01 00 00       	push   $0x1c5
c00286d9:	68 cb ec 02 c0       	push   $0xc002eccb
c00286de:	e8 ea f5 ff ff       	call   c0027ccd <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c00286e3:	83 ec 0c             	sub    $0xc,%esp
c00286e6:	56                   	push   %esi
c00286e7:	e8 cb f6 ff ff       	call   c0027db7 <list_begin>
c00286ec:	83 c4 10             	add    $0x10,%esp
c00286ef:	89 c3                	mov    %eax,%ebx
c00286f1:	eb 20                	jmp    c0028713 <list_insert_ordered+0xb2>
    if (less (elem, e, aux))
c00286f3:	83 ec 04             	sub    $0x4,%esp
c00286f6:	ff 74 24 30          	pushl  0x30(%esp)
c00286fa:	53                   	push   %ebx
c00286fb:	57                   	push   %edi
c00286fc:	ff d5                	call   *%ebp
c00286fe:	83 c4 10             	add    $0x10,%esp
c0028701:	84 c0                	test   %al,%al
c0028703:	75 20                	jne    c0028725 <list_insert_ordered+0xc4>

  ASSERT (list != NULL);
  ASSERT (elem != NULL);
  ASSERT (less != NULL);

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0028705:	83 ec 0c             	sub    $0xc,%esp
c0028708:	53                   	push   %ebx
c0028709:	e8 d9 f6 ff ff       	call   c0027de7 <list_next>
c002870e:	83 c4 10             	add    $0x10,%esp
c0028711:	89 c3                	mov    %eax,%ebx
c0028713:	83 ec 0c             	sub    $0xc,%esp
c0028716:	56                   	push   %esi
c0028717:	e8 11 f7 ff ff       	call   c0027e2d <list_end>
c002871c:	83 c4 10             	add    $0x10,%esp
c002871f:	39 c3                	cmp    %eax,%ebx
c0028721:	75 d0                	jne    c00286f3 <list_insert_ordered+0x92>
c0028723:	eb 02                	jmp    c0028727 <list_insert_ordered+0xc6>
c0028725:	89 d8                	mov    %ebx,%eax
    if (less (elem, e, aux))
      break;
  return list_insert (e, elem);
c0028727:	83 ec 08             	sub    $0x8,%esp
c002872a:	57                   	push   %edi
c002872b:	50                   	push   %eax
c002872c:	e8 67 f9 ff ff       	call   c0028098 <list_insert>
}
c0028731:	83 c4 1c             	add    $0x1c,%esp
c0028734:	5b                   	pop    %ebx
c0028735:	5e                   	pop    %esi
c0028736:	5f                   	pop    %edi
c0028737:	5d                   	pop    %ebp
c0028738:	c3                   	ret    

c0028739 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c0028739:	55                   	push   %ebp
c002873a:	57                   	push   %edi
c002873b:	56                   	push   %esi
c002873c:	53                   	push   %ebx
c002873d:	83 ec 0c             	sub    $0xc,%esp
c0028740:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0028744:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c0028748:	85 ff                	test   %edi,%edi
c002874a:	75 21                	jne    c002876d <list_unique+0x34>
c002874c:	83 ec 0c             	sub    $0xc,%esp
c002874f:	68 be ec 02 c0       	push   $0xc002ecbe
c0028754:	68 3f d2 02 c0       	push   $0xc002d23f
c0028759:	68 30 cd 02 c0       	push   $0xc002cd30
c002875e:	68 d7 01 00 00       	push   $0x1d7
c0028763:	68 cb ec 02 c0       	push   $0xc002eccb
c0028768:	e8 60 f5 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (less != NULL);
c002876d:	85 ed                	test   %ebp,%ebp
c002876f:	75 21                	jne    c0028792 <list_unique+0x59>
c0028771:	83 ec 0c             	sub    $0xc,%esp
c0028774:	68 e3 ec 02 c0       	push   $0xc002ece3
c0028779:	68 3f d2 02 c0       	push   $0xc002d23f
c002877e:	68 30 cd 02 c0       	push   $0xc002cd30
c0028783:	68 d8 01 00 00       	push   $0x1d8
c0028788:	68 cb ec 02 c0       	push   $0xc002eccb
c002878d:	e8 3b f5 ff ff       	call   c0027ccd <debug_panic>
  if (list_empty (list))
c0028792:	83 ec 0c             	sub    $0xc,%esp
c0028795:	57                   	push   %edi
c0028796:	e8 27 fb ff ff       	call   c00282c2 <list_empty>
c002879b:	83 c4 10             	add    $0x10,%esp
c002879e:	84 c0                	test   %al,%al
c00287a0:	75 79                	jne    c002881b <list_unique+0xe2>
    return;

  elem = list_begin (list);
c00287a2:	83 ec 0c             	sub    $0xc,%esp
c00287a5:	57                   	push   %edi
c00287a6:	e8 0c f6 ff ff       	call   c0027db7 <list_begin>
c00287ab:	83 c4 10             	add    $0x10,%esp
c00287ae:	89 c6                	mov    %eax,%esi
  while ((next = list_next (elem)) != list_end (list))
c00287b0:	eb 4f                	jmp    c0028801 <list_unique+0xc8>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c00287b2:	83 ec 04             	sub    $0x4,%esp
c00287b5:	ff 74 24 30          	pushl  0x30(%esp)
c00287b9:	53                   	push   %ebx
c00287ba:	56                   	push   %esi
c00287bb:	ff d5                	call   *%ebp
c00287bd:	83 c4 10             	add    $0x10,%esp
c00287c0:	84 c0                	test   %al,%al
c00287c2:	75 3b                	jne    c00287ff <list_unique+0xc6>
c00287c4:	83 ec 04             	sub    $0x4,%esp
c00287c7:	ff 74 24 30          	pushl  0x30(%esp)
c00287cb:	56                   	push   %esi
c00287cc:	53                   	push   %ebx
c00287cd:	ff d5                	call   *%ebp
c00287cf:	83 c4 10             	add    $0x10,%esp
c00287d2:	84 c0                	test   %al,%al
c00287d4:	75 29                	jne    c00287ff <list_unique+0xc6>
      {
        list_remove (next);
c00287d6:	83 ec 0c             	sub    $0xc,%esp
c00287d9:	53                   	push   %ebx
c00287da:	e8 56 fa ff ff       	call   c0028235 <list_remove>
        if (duplicates != NULL)
c00287df:	83 c4 10             	add    $0x10,%esp
c00287e2:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c00287e7:	74 14                	je     c00287fd <list_unique+0xc4>
          list_push_back (duplicates, next);
c00287e9:	83 ec 08             	sub    $0x8,%esp
c00287ec:	53                   	push   %ebx
c00287ed:	ff 74 24 30          	pushl  0x30(%esp)
c00287f1:	e8 22 fa ff ff       	call   c0028218 <list_push_back>
c00287f6:	83 c4 10             	add    $0x10,%esp
c00287f9:	89 f3                	mov    %esi,%ebx
c00287fb:	eb 02                	jmp    c00287ff <list_unique+0xc6>
c00287fd:	89 f3                	mov    %esi,%ebx
c00287ff:	89 de                	mov    %ebx,%esi
  ASSERT (less != NULL);
  if (list_empty (list))
    return;

  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
c0028801:	83 ec 0c             	sub    $0xc,%esp
c0028804:	56                   	push   %esi
c0028805:	e8 dd f5 ff ff       	call   c0027de7 <list_next>
c002880a:	89 c3                	mov    %eax,%ebx
c002880c:	89 3c 24             	mov    %edi,(%esp)
c002880f:	e8 19 f6 ff ff       	call   c0027e2d <list_end>
c0028814:	83 c4 10             	add    $0x10,%esp
c0028817:	39 c3                	cmp    %eax,%ebx
c0028819:	75 97                	jne    c00287b2 <list_unique+0x79>
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c002881b:	83 c4 0c             	add    $0xc,%esp
c002881e:	5b                   	pop    %ebx
c002881f:	5e                   	pop    %esi
c0028820:	5f                   	pop    %edi
c0028821:	5d                   	pop    %ebp
c0028822:	c3                   	ret    

c0028823 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c0028823:	55                   	push   %ebp
c0028824:	57                   	push   %edi
c0028825:	56                   	push   %esi
c0028826:	53                   	push   %ebx
c0028827:	83 ec 18             	sub    $0x18,%esp
c002882a:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002882e:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin (list);
c0028832:	57                   	push   %edi
c0028833:	e8 7f f5 ff ff       	call   c0027db7 <list_begin>
c0028838:	89 c6                	mov    %eax,%esi
  if (max != list_end (list)) 
c002883a:	89 3c 24             	mov    %edi,(%esp)
c002883d:	e8 eb f5 ff ff       	call   c0027e2d <list_end>
c0028842:	83 c4 10             	add    $0x10,%esp
c0028845:	39 c6                	cmp    %eax,%esi
c0028847:	74 3e                	je     c0028887 <list_max+0x64>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0028849:	83 ec 0c             	sub    $0xc,%esp
c002884c:	56                   	push   %esi
c002884d:	e8 95 f5 ff ff       	call   c0027de7 <list_next>
c0028852:	83 c4 10             	add    $0x10,%esp
c0028855:	89 c3                	mov    %eax,%ebx
c0028857:	eb 1c                	jmp    c0028875 <list_max+0x52>
        if (less (max, e, aux))
c0028859:	83 ec 04             	sub    $0x4,%esp
c002885c:	55                   	push   %ebp
c002885d:	53                   	push   %ebx
c002885e:	56                   	push   %esi
c002885f:	ff 54 24 34          	call   *0x34(%esp)
c0028863:	84 c0                	test   %al,%al
          max = e; 
c0028865:	0f 45 f3             	cmovne %ebx,%esi
  struct list_elem *max = list_begin (list);
  if (max != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c0028868:	89 1c 24             	mov    %ebx,(%esp)
c002886b:	e8 77 f5 ff ff       	call   c0027de7 <list_next>
c0028870:	83 c4 10             	add    $0x10,%esp
c0028873:	89 c3                	mov    %eax,%ebx
c0028875:	83 ec 0c             	sub    $0xc,%esp
c0028878:	57                   	push   %edi
c0028879:	e8 af f5 ff ff       	call   c0027e2d <list_end>
c002887e:	83 c4 10             	add    $0x10,%esp
c0028881:	39 c3                	cmp    %eax,%ebx
c0028883:	75 d4                	jne    c0028859 <list_max+0x36>
c0028885:	eb 02                	jmp    c0028889 <list_max+0x66>
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
  struct list_elem *max = list_begin (list);
c0028887:	89 c6                	mov    %eax,%esi
      for (e = list_next (max); e != list_end (list); e = list_next (e))
        if (less (max, e, aux))
          max = e; 
    }
  return max;
}
c0028889:	89 f0                	mov    %esi,%eax
c002888b:	83 c4 0c             	add    $0xc,%esp
c002888e:	5b                   	pop    %ebx
c002888f:	5e                   	pop    %esi
c0028890:	5f                   	pop    %edi
c0028891:	5d                   	pop    %ebp
c0028892:	c3                   	ret    

c0028893 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c0028893:	55                   	push   %ebp
c0028894:	57                   	push   %edi
c0028895:	56                   	push   %esi
c0028896:	53                   	push   %ebx
c0028897:	83 ec 18             	sub    $0x18,%esp
c002889a:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002889e:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin (list);
c00288a2:	57                   	push   %edi
c00288a3:	e8 0f f5 ff ff       	call   c0027db7 <list_begin>
c00288a8:	89 c6                	mov    %eax,%esi
  if (min != list_end (list)) 
c00288aa:	89 3c 24             	mov    %edi,(%esp)
c00288ad:	e8 7b f5 ff ff       	call   c0027e2d <list_end>
c00288b2:	83 c4 10             	add    $0x10,%esp
c00288b5:	39 c6                	cmp    %eax,%esi
c00288b7:	74 3e                	je     c00288f7 <list_min+0x64>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c00288b9:	83 ec 0c             	sub    $0xc,%esp
c00288bc:	56                   	push   %esi
c00288bd:	e8 25 f5 ff ff       	call   c0027de7 <list_next>
c00288c2:	83 c4 10             	add    $0x10,%esp
c00288c5:	89 c3                	mov    %eax,%ebx
c00288c7:	eb 1c                	jmp    c00288e5 <list_min+0x52>
        if (less (e, min, aux))
c00288c9:	83 ec 04             	sub    $0x4,%esp
c00288cc:	55                   	push   %ebp
c00288cd:	56                   	push   %esi
c00288ce:	53                   	push   %ebx
c00288cf:	ff 54 24 34          	call   *0x34(%esp)
c00288d3:	84 c0                	test   %al,%al
          min = e; 
c00288d5:	0f 45 f3             	cmovne %ebx,%esi
  struct list_elem *min = list_begin (list);
  if (min != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c00288d8:	89 1c 24             	mov    %ebx,(%esp)
c00288db:	e8 07 f5 ff ff       	call   c0027de7 <list_next>
c00288e0:	83 c4 10             	add    $0x10,%esp
c00288e3:	89 c3                	mov    %eax,%ebx
c00288e5:	83 ec 0c             	sub    $0xc,%esp
c00288e8:	57                   	push   %edi
c00288e9:	e8 3f f5 ff ff       	call   c0027e2d <list_end>
c00288ee:	83 c4 10             	add    $0x10,%esp
c00288f1:	39 c3                	cmp    %eax,%ebx
c00288f3:	75 d4                	jne    c00288c9 <list_min+0x36>
c00288f5:	eb 02                	jmp    c00288f9 <list_min+0x66>
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
  struct list_elem *min = list_begin (list);
c00288f7:	89 c6                	mov    %eax,%esi
      for (e = list_next (min); e != list_end (list); e = list_next (e))
        if (less (e, min, aux))
          min = e; 
    }
  return min;
}
c00288f9:	89 f0                	mov    %esi,%eax
c00288fb:	83 c4 0c             	add    $0xc,%esp
c00288fe:	5b                   	pop    %ebx
c00288ff:	5e                   	pop    %esi
c0028900:	5f                   	pop    %edi
c0028901:	5d                   	pop    %ebp
c0028902:	c3                   	ret    

c0028903 <bitmap_buf_size>:
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c0028903:	8b 44 24 04          	mov    0x4(%esp),%eax
c0028907:	83 c0 1f             	add    $0x1f,%eax
c002890a:	c1 e8 05             	shr    $0x5,%eax
c002890d:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c0028914:	c3                   	ret    

c0028915 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c0028915:	53                   	push   %ebx
c0028916:	83 ec 08             	sub    $0x8,%esp
c0028919:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  if (b != NULL) 
c002891d:	85 db                	test   %ebx,%ebx
c002891f:	74 16                	je     c0028937 <bitmap_destroy+0x22>
    {
      free (b->bits);
c0028921:	83 ec 0c             	sub    $0xc,%esp
c0028924:	ff 73 04             	pushl  0x4(%ebx)
c0028927:	e8 d4 ac ff ff       	call   c0023600 <free>
      free (b);
c002892c:	89 1c 24             	mov    %ebx,(%esp)
c002892f:	e8 cc ac ff ff       	call   c0023600 <free>
c0028934:	83 c4 10             	add    $0x10,%esp
    }
}
c0028937:	83 c4 08             	add    $0x8,%esp
c002893a:	5b                   	pop    %ebx
c002893b:	c3                   	ret    

c002893c <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
  return b->bit_cnt;
c002893c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0028940:	8b 00                	mov    (%eax),%eax
}
c0028942:	c3                   	ret    

c0028943 <bitmap_mark>:
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c0028943:	53                   	push   %ebx
c0028944:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0028948:	89 cb                	mov    %ecx,%ebx
c002894a:	c1 eb 05             	shr    $0x5,%ebx
c002894d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028951:	8b 50 04             	mov    0x4(%eax),%edx
c0028954:	b8 01 00 00 00       	mov    $0x1,%eax
c0028959:	d3 e0                	shl    %cl,%eax
c002895b:	09 04 9a             	or     %eax,(%edx,%ebx,4)
}
c002895e:	5b                   	pop    %ebx
c002895f:	c3                   	ret    

c0028960 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c0028960:	53                   	push   %ebx
c0028961:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c0028965:	89 cb                	mov    %ecx,%ebx
c0028967:	c1 eb 05             	shr    $0x5,%ebx
c002896a:	8b 44 24 08          	mov    0x8(%esp),%eax
c002896e:	8b 50 04             	mov    0x4(%eax),%edx
c0028971:	b8 01 00 00 00       	mov    $0x1,%eax
c0028976:	d3 e0                	shl    %cl,%eax
c0028978:	f7 d0                	not    %eax
c002897a:	21 04 9a             	and    %eax,(%edx,%ebx,4)
}
c002897d:	5b                   	pop    %ebx
c002897e:	c3                   	ret    

c002897f <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002897f:	83 ec 0c             	sub    $0xc,%esp
c0028982:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028986:	8b 54 24 14          	mov    0x14(%esp),%edx
c002898a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT (b != NULL);
c002898e:	85 c0                	test   %eax,%eax
c0028990:	75 21                	jne    c00289b3 <bitmap_set+0x34>
c0028992:	83 ec 0c             	sub    $0xc,%esp
c0028995:	68 95 ea 02 c0       	push   $0xc002ea95
c002899a:	68 3f d2 02 c0       	push   $0xc002d23f
c002899f:	68 80 ce 02 c0       	push   $0xc002ce80
c00289a4:	68 93 00 00 00       	push   $0x93
c00289a9:	68 6a ee 02 c0       	push   $0xc002ee6a
c00289ae:	e8 1a f3 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (idx < b->bit_cnt);
c00289b3:	39 10                	cmp    %edx,(%eax)
c00289b5:	77 21                	ja     c00289d8 <bitmap_set+0x59>
c00289b7:	83 ec 0c             	sub    $0xc,%esp
c00289ba:	68 84 ee 02 c0       	push   $0xc002ee84
c00289bf:	68 3f d2 02 c0       	push   $0xc002d23f
c00289c4:	68 80 ce 02 c0       	push   $0xc002ce80
c00289c9:	68 94 00 00 00       	push   $0x94
c00289ce:	68 6a ee 02 c0       	push   $0xc002ee6a
c00289d3:	e8 f5 f2 ff ff       	call   c0027ccd <debug_panic>
  if (value)
c00289d8:	84 c9                	test   %cl,%cl
c00289da:	74 0f                	je     c00289eb <bitmap_set+0x6c>
    bitmap_mark (b, idx);
c00289dc:	83 ec 08             	sub    $0x8,%esp
c00289df:	52                   	push   %edx
c00289e0:	50                   	push   %eax
c00289e1:	e8 5d ff ff ff       	call   c0028943 <bitmap_mark>
c00289e6:	83 c4 10             	add    $0x10,%esp
c00289e9:	eb 0d                	jmp    c00289f8 <bitmap_set+0x79>
  else
    bitmap_reset (b, idx);
c00289eb:	83 ec 08             	sub    $0x8,%esp
c00289ee:	52                   	push   %edx
c00289ef:	50                   	push   %eax
c00289f0:	e8 6b ff ff ff       	call   c0028960 <bitmap_reset>
c00289f5:	83 c4 10             	add    $0x10,%esp
}
c00289f8:	83 c4 0c             	add    $0xc,%esp
c00289fb:	c3                   	ret    

c00289fc <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c00289fc:	53                   	push   %ebx
c00289fd:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  elem_type mask = bit_mask (bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c0028a01:	89 cb                	mov    %ecx,%ebx
c0028a03:	c1 eb 05             	shr    $0x5,%ebx
c0028a06:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028a0a:	8b 50 04             	mov    0x4(%eax),%edx
c0028a0d:	b8 01 00 00 00       	mov    $0x1,%eax
c0028a12:	d3 e0                	shl    %cl,%eax
c0028a14:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
}
c0028a17:	5b                   	pop    %ebx
c0028a18:	c3                   	ret    

c0028a19 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c0028a19:	53                   	push   %ebx
c0028a1a:	83 ec 08             	sub    $0x8,%esp
c0028a1d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028a21:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT (b != NULL);
c0028a25:	85 c0                	test   %eax,%eax
c0028a27:	75 21                	jne    c0028a4a <bitmap_test+0x31>
c0028a29:	83 ec 0c             	sub    $0xc,%esp
c0028a2c:	68 95 ea 02 c0       	push   $0xc002ea95
c0028a31:	68 3f d2 02 c0       	push   $0xc002d23f
c0028a36:	68 74 ce 02 c0       	push   $0xc002ce74
c0028a3b:	68 c8 00 00 00       	push   $0xc8
c0028a40:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028a45:	e8 83 f2 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (idx < b->bit_cnt);
c0028a4a:	39 08                	cmp    %ecx,(%eax)
c0028a4c:	77 21                	ja     c0028a6f <bitmap_test+0x56>
c0028a4e:	83 ec 0c             	sub    $0xc,%esp
c0028a51:	68 84 ee 02 c0       	push   $0xc002ee84
c0028a56:	68 3f d2 02 c0       	push   $0xc002d23f
c0028a5b:	68 74 ce 02 c0       	push   $0xc002ce74
c0028a60:	68 c9 00 00 00       	push   $0xc9
c0028a65:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028a6a:	e8 5e f2 ff ff       	call   c0027ccd <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c0028a6f:	89 cb                	mov    %ecx,%ebx
c0028a71:	c1 eb 05             	shr    $0x5,%ebx
c0028a74:	8b 50 04             	mov    0x4(%eax),%edx
c0028a77:	b8 01 00 00 00       	mov    $0x1,%eax
c0028a7c:	d3 e0                	shl    %cl,%eax
c0028a7e:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c0028a81:	0f 95 c0             	setne  %al
}
c0028a84:	83 c4 08             	add    $0x8,%esp
c0028a87:	5b                   	pop    %ebx
c0028a88:	c3                   	ret    

c0028a89 <bitmap_set_multiple>:
}

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0028a89:	55                   	push   %ebp
c0028a8a:	57                   	push   %edi
c0028a8b:	56                   	push   %esi
c0028a8c:	53                   	push   %ebx
c0028a8d:	83 ec 0c             	sub    $0xc,%esp
c0028a90:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0028a94:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0028a98:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028a9c:	0f b6 4c 24 2c       	movzbl 0x2c(%esp),%ecx
  size_t i;
  
  ASSERT (b != NULL);
c0028aa1:	85 ff                	test   %edi,%edi
c0028aa3:	75 21                	jne    c0028ac6 <bitmap_set_multiple+0x3d>
c0028aa5:	83 ec 0c             	sub    $0xc,%esp
c0028aa8:	68 95 ea 02 c0       	push   $0xc002ea95
c0028aad:	68 3f d2 02 c0       	push   $0xc002d23f
c0028ab2:	68 50 ce 02 c0       	push   $0xc002ce50
c0028ab7:	68 de 00 00 00       	push   $0xde
c0028abc:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028ac1:	e8 07 f2 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0028ac6:	8b 17                	mov    (%edi),%edx
c0028ac8:	39 da                	cmp    %ebx,%edx
c0028aca:	73 21                	jae    c0028aed <bitmap_set_multiple+0x64>
c0028acc:	83 ec 0c             	sub    $0xc,%esp
c0028acf:	68 95 ee 02 c0       	push   $0xc002ee95
c0028ad4:	68 3f d2 02 c0       	push   $0xc002d23f
c0028ad9:	68 50 ce 02 c0       	push   $0xc002ce50
c0028ade:	68 df 00 00 00       	push   $0xdf
c0028ae3:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028ae8:	e8 e0 f1 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0028aed:	8d 2c 03             	lea    (%ebx,%eax,1),%ebp
c0028af0:	39 ea                	cmp    %ebp,%edx
c0028af2:	72 09                	jb     c0028afd <bitmap_set_multiple+0x74>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c0028af4:	0f b6 f1             	movzbl %cl,%esi
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c0028af7:	85 c0                	test   %eax,%eax
c0028af9:	75 23                	jne    c0028b1e <bitmap_set_multiple+0x95>
c0028afb:	eb 36                	jmp    c0028b33 <bitmap_set_multiple+0xaa>
{
  size_t i;
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);
c0028afd:	83 ec 0c             	sub    $0xc,%esp
c0028b00:	68 a9 ee 02 c0       	push   $0xc002eea9
c0028b05:	68 3f d2 02 c0       	push   $0xc002d23f
c0028b0a:	68 50 ce 02 c0       	push   $0xc002ce50
c0028b0f:	68 e0 00 00 00       	push   $0xe0
c0028b14:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028b19:	e8 af f1 ff ff       	call   c0027ccd <debug_panic>

  for (i = 0; i < cnt; i++)
    bitmap_set (b, start + i, value);
c0028b1e:	83 ec 04             	sub    $0x4,%esp
c0028b21:	56                   	push   %esi
c0028b22:	53                   	push   %ebx
c0028b23:	57                   	push   %edi
c0028b24:	e8 56 fe ff ff       	call   c002897f <bitmap_set>
c0028b29:	83 c3 01             	add    $0x1,%ebx
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c0028b2c:	83 c4 10             	add    $0x10,%esp
c0028b2f:	39 eb                	cmp    %ebp,%ebx
c0028b31:	75 eb                	jne    c0028b1e <bitmap_set_multiple+0x95>
    bitmap_set (b, start + i, value);
}
c0028b33:	83 c4 0c             	add    $0xc,%esp
c0028b36:	5b                   	pop    %ebx
c0028b37:	5e                   	pop    %esi
c0028b38:	5f                   	pop    %edi
c0028b39:	5d                   	pop    %ebp
c0028b3a:	c3                   	ret    

c0028b3b <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c0028b3b:	83 ec 0c             	sub    $0xc,%esp
c0028b3e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028b42:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT (b != NULL);
c0028b46:	85 c0                	test   %eax,%eax
c0028b48:	75 21                	jne    c0028b6b <bitmap_set_all+0x30>
c0028b4a:	83 ec 0c             	sub    $0xc,%esp
c0028b4d:	68 95 ea 02 c0       	push   $0xc002ea95
c0028b52:	68 3f d2 02 c0       	push   $0xc002d23f
c0028b57:	68 64 ce 02 c0       	push   $0xc002ce64
c0028b5c:	68 d3 00 00 00       	push   $0xd3
c0028b61:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028b66:	e8 62 f1 ff ff       	call   c0027ccd <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c0028b6b:	0f b6 d2             	movzbl %dl,%edx
c0028b6e:	52                   	push   %edx
c0028b6f:	ff 30                	pushl  (%eax)
c0028b71:	6a 00                	push   $0x0
c0028b73:	50                   	push   %eax
c0028b74:	e8 10 ff ff ff       	call   c0028a89 <bitmap_set_multiple>
}
c0028b79:	83 c4 1c             	add    $0x1c,%esp
c0028b7c:	c3                   	ret    

c0028b7d <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c0028b7d:	56                   	push   %esi
c0028b7e:	53                   	push   %ebx
c0028b7f:	83 ec 10             	sub    $0x10,%esp
c0028b82:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  struct bitmap *b = malloc (sizeof *b);
c0028b86:	6a 08                	push   $0x8
c0028b88:	e8 e2 a8 ff ff       	call   c002346f <malloc>
  if (b != NULL)
c0028b8d:	83 c4 10             	add    $0x10,%esp
c0028b90:	85 c0                	test   %eax,%eax
c0028b92:	74 49                	je     c0028bdd <bitmap_create+0x60>
c0028b94:	89 c3                	mov    %eax,%ebx
    {
      b->bit_cnt = bit_cnt;
c0028b96:	89 30                	mov    %esi,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c0028b98:	83 ec 0c             	sub    $0xc,%esp
c0028b9b:	8d 46 1f             	lea    0x1f(%esi),%eax
c0028b9e:	c1 e8 05             	shr    $0x5,%eax
c0028ba1:	c1 e0 02             	shl    $0x2,%eax
c0028ba4:	50                   	push   %eax
c0028ba5:	e8 c5 a8 ff ff       	call   c002346f <malloc>
c0028baa:	89 43 04             	mov    %eax,0x4(%ebx)
      if (b->bits != NULL || bit_cnt == 0)
c0028bad:	83 c4 10             	add    $0x10,%esp
c0028bb0:	85 f6                	test   %esi,%esi
c0028bb2:	74 04                	je     c0028bb8 <bitmap_create+0x3b>
c0028bb4:	85 c0                	test   %eax,%eax
c0028bb6:	74 12                	je     c0028bca <bitmap_create+0x4d>
        {
          bitmap_set_all (b, false);
c0028bb8:	83 ec 08             	sub    $0x8,%esp
c0028bbb:	6a 00                	push   $0x0
c0028bbd:	53                   	push   %ebx
c0028bbe:	e8 78 ff ff ff       	call   c0028b3b <bitmap_set_all>
          return b;
c0028bc3:	83 c4 10             	add    $0x10,%esp
c0028bc6:	89 d8                	mov    %ebx,%eax
c0028bc8:	eb 18                	jmp    c0028be2 <bitmap_create+0x65>
        }
      free (b);
c0028bca:	83 ec 0c             	sub    $0xc,%esp
c0028bcd:	53                   	push   %ebx
c0028bce:	e8 2d aa ff ff       	call   c0023600 <free>
c0028bd3:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c0028bd6:	b8 00 00 00 00       	mov    $0x0,%eax
c0028bdb:	eb 05                	jmp    c0028be2 <bitmap_create+0x65>
c0028bdd:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028be2:	83 c4 04             	add    $0x4,%esp
c0028be5:	5b                   	pop    %ebx
c0028be6:	5e                   	pop    %esi
c0028be7:	c3                   	ret    

c0028be8 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c0028be8:	56                   	push   %esi
c0028be9:	53                   	push   %ebx
c0028bea:	83 ec 04             	sub    $0x4,%esp
c0028bed:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028bf1:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct bitmap *b = block;
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c0028bf5:	56                   	push   %esi
c0028bf6:	e8 08 fd ff ff       	call   c0028903 <bitmap_buf_size>
c0028bfb:	83 c4 04             	add    $0x4,%esp
c0028bfe:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0028c02:	76 1e                	jbe    c0028c22 <bitmap_create_in_buf+0x3a>
c0028c04:	83 ec 0c             	sub    $0xc,%esp
c0028c07:	68 c4 ee 02 c0       	push   $0xc002eec4
c0028c0c:	68 3f d2 02 c0       	push   $0xc002d23f
c0028c11:	68 8c ce 02 c0       	push   $0xc002ce8c
c0028c16:	6a 68                	push   $0x68
c0028c18:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028c1d:	e8 ab f0 ff ff       	call   c0027ccd <debug_panic>

  b->bit_cnt = bit_cnt;
c0028c22:	89 33                	mov    %esi,(%ebx)
  b->bits = (elem_type *) (b + 1);
c0028c24:	8d 43 08             	lea    0x8(%ebx),%eax
c0028c27:	89 43 04             	mov    %eax,0x4(%ebx)
  bitmap_set_all (b, false);
c0028c2a:	83 ec 08             	sub    $0x8,%esp
c0028c2d:	6a 00                	push   $0x0
c0028c2f:	53                   	push   %ebx
c0028c30:	e8 06 ff ff ff       	call   c0028b3b <bitmap_set_all>
  return b;
}
c0028c35:	89 d8                	mov    %ebx,%eax
c0028c37:	83 c4 14             	add    $0x14,%esp
c0028c3a:	5b                   	pop    %ebx
c0028c3b:	5e                   	pop    %esi
c0028c3c:	c3                   	ret    

c0028c3d <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0028c3d:	55                   	push   %ebp
c0028c3e:	57                   	push   %edi
c0028c3f:	56                   	push   %esi
c0028c40:	53                   	push   %ebx
c0028c41:	83 ec 1c             	sub    $0x1c,%esp
c0028c44:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0028c48:	8b 5c 24 34          	mov    0x34(%esp),%ebx
c0028c4c:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028c50:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c0028c55:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c0028c59:	85 ff                	test   %edi,%edi
c0028c5b:	75 21                	jne    c0028c7e <bitmap_count+0x41>
c0028c5d:	83 ec 0c             	sub    $0xc,%esp
c0028c60:	68 95 ea 02 c0       	push   $0xc002ea95
c0028c65:	68 3f d2 02 c0       	push   $0xc002d23f
c0028c6a:	68 40 ce 02 c0       	push   $0xc002ce40
c0028c6f:	68 ed 00 00 00       	push   $0xed
c0028c74:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028c79:	e8 4f f0 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0028c7e:	8b 17                	mov    (%edi),%edx
c0028c80:	39 da                	cmp    %ebx,%edx
c0028c82:	73 21                	jae    c0028ca5 <bitmap_count+0x68>
c0028c84:	83 ec 0c             	sub    $0xc,%esp
c0028c87:	68 95 ee 02 c0       	push   $0xc002ee95
c0028c8c:	68 3f d2 02 c0       	push   $0xc002d23f
c0028c91:	68 40 ce 02 c0       	push   $0xc002ce40
c0028c96:	68 ee 00 00 00       	push   $0xee
c0028c9b:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028ca0:	e8 28 f0 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0028ca5:	8d 2c 03             	lea    (%ebx,%eax,1),%ebp
c0028ca8:	39 ea                	cmp    %ebp,%edx
c0028caa:	72 0b                	jb     c0028cb7 <bitmap_count+0x7a>

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c0028cac:	be 00 00 00 00       	mov    $0x0,%esi
c0028cb1:	85 c0                	test   %eax,%eax
c0028cb3:	75 23                	jne    c0028cd8 <bitmap_count+0x9b>
c0028cb5:	eb 41                	jmp    c0028cf8 <bitmap_count+0xbb>
{
  size_t i, value_cnt;

  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);
c0028cb7:	83 ec 0c             	sub    $0xc,%esp
c0028cba:	68 a9 ee 02 c0       	push   $0xc002eea9
c0028cbf:	68 3f d2 02 c0       	push   $0xc002d23f
c0028cc4:	68 40 ce 02 c0       	push   $0xc002ce40
c0028cc9:	68 ef 00 00 00       	push   $0xef
c0028cce:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028cd3:	e8 f5 ef ff ff       	call   c0027ccd <debug_panic>

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
    if (bitmap_test (b, start + i) == value)
c0028cd8:	83 ec 08             	sub    $0x8,%esp
c0028cdb:	53                   	push   %ebx
c0028cdc:	57                   	push   %edi
c0028cdd:	e8 37 fd ff ff       	call   c0028a19 <bitmap_test>
c0028ce2:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c0028ce5:	3a 44 24 0f          	cmp    0xf(%esp),%al
c0028ce9:	0f 94 c0             	sete   %al
c0028cec:	0f b6 c0             	movzbl %al,%eax
c0028cef:	01 c6                	add    %eax,%esi
c0028cf1:	83 c3 01             	add    $0x1,%ebx
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c0028cf4:	39 eb                	cmp    %ebp,%ebx
c0028cf6:	75 e0                	jne    c0028cd8 <bitmap_count+0x9b>
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
}
c0028cf8:	89 f0                	mov    %esi,%eax
c0028cfa:	83 c4 1c             	add    $0x1c,%esp
c0028cfd:	5b                   	pop    %ebx
c0028cfe:	5e                   	pop    %esi
c0028cff:	5f                   	pop    %edi
c0028d00:	5d                   	pop    %ebp
c0028d01:	c3                   	ret    

c0028d02 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0028d02:	55                   	push   %ebp
c0028d03:	57                   	push   %edi
c0028d04:	56                   	push   %esi
c0028d05:	53                   	push   %ebx
c0028d06:	83 ec 0c             	sub    $0xc,%esp
c0028d09:	8b 74 24 20          	mov    0x20(%esp),%esi
c0028d0d:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c0028d11:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028d15:	0f b6 6c 24 2c       	movzbl 0x2c(%esp),%ebp
  size_t i;
  
  ASSERT (b != NULL);
c0028d1a:	85 f6                	test   %esi,%esi
c0028d1c:	75 21                	jne    c0028d3f <bitmap_contains+0x3d>
c0028d1e:	83 ec 0c             	sub    $0xc,%esp
c0028d21:	68 95 ea 02 c0       	push   $0xc002ea95
c0028d26:	68 3f d2 02 c0       	push   $0xc002d23f
c0028d2b:	68 30 ce 02 c0       	push   $0xc002ce30
c0028d30:	68 ff 00 00 00       	push   $0xff
c0028d35:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028d3a:	e8 8e ef ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0028d3f:	8b 16                	mov    (%esi),%edx
c0028d41:	39 da                	cmp    %ebx,%edx
c0028d43:	73 21                	jae    c0028d66 <bitmap_contains+0x64>
c0028d45:	83 ec 0c             	sub    $0xc,%esp
c0028d48:	68 95 ee 02 c0       	push   $0xc002ee95
c0028d4d:	68 3f d2 02 c0       	push   $0xc002d23f
c0028d52:	68 30 ce 02 c0       	push   $0xc002ce30
c0028d57:	68 00 01 00 00       	push   $0x100
c0028d5c:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028d61:	e8 67 ef ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c0028d66:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
c0028d69:	39 fa                	cmp    %edi,%edx
c0028d6b:	72 06                	jb     c0028d73 <bitmap_contains+0x71>

  for (i = 0; i < cnt; i++)
c0028d6d:	85 c0                	test   %eax,%eax
c0028d6f:	75 23                	jne    c0028d94 <bitmap_contains+0x92>
c0028d71:	eb 47                	jmp    c0028dba <bitmap_contains+0xb8>
{
  size_t i;
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);
c0028d73:	83 ec 0c             	sub    $0xc,%esp
c0028d76:	68 a9 ee 02 c0       	push   $0xc002eea9
c0028d7b:	68 3f d2 02 c0       	push   $0xc002d23f
c0028d80:	68 30 ce 02 c0       	push   $0xc002ce30
c0028d85:	68 01 01 00 00       	push   $0x101
c0028d8a:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028d8f:	e8 39 ef ff ff       	call   c0027ccd <debug_panic>

  for (i = 0; i < cnt; i++)
    if (bitmap_test (b, start + i) == value)
c0028d94:	83 ec 08             	sub    $0x8,%esp
c0028d97:	53                   	push   %ebx
c0028d98:	56                   	push   %esi
c0028d99:	e8 7b fc ff ff       	call   c0028a19 <bitmap_test>
c0028d9e:	83 c4 10             	add    $0x10,%esp
c0028da1:	89 e9                	mov    %ebp,%ecx
c0028da3:	38 c8                	cmp    %cl,%al
c0028da5:	74 0e                	je     c0028db5 <bitmap_contains+0xb3>
c0028da7:	83 c3 01             	add    $0x1,%ebx
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c0028daa:	39 df                	cmp    %ebx,%edi
c0028dac:	75 e6                	jne    c0028d94 <bitmap_contains+0x92>
    if (bitmap_test (b, start + i) == value)
      return true;
  return false;
c0028dae:	b8 00 00 00 00       	mov    $0x0,%eax
c0028db3:	eb 05                	jmp    c0028dba <bitmap_contains+0xb8>
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
    if (bitmap_test (b, start + i) == value)
      return true;
c0028db5:	b8 01 00 00 00       	mov    $0x1,%eax
  return false;
}
c0028dba:	83 c4 0c             	add    $0xc,%esp
c0028dbd:	5b                   	pop    %ebx
c0028dbe:	5e                   	pop    %esi
c0028dbf:	5f                   	pop    %edi
c0028dc0:	5d                   	pop    %ebp
c0028dc1:	c3                   	ret    

c0028dc2 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c0028dc2:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains (b, start, cnt, true);
c0028dc5:	6a 01                	push   $0x1
c0028dc7:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028dcb:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028dcf:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028dd3:	e8 2a ff ff ff       	call   c0028d02 <bitmap_contains>
}
c0028dd8:	83 c4 1c             	add    $0x1c,%esp
c0028ddb:	c3                   	ret    

c0028ddc <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c0028ddc:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, true);
c0028ddf:	6a 01                	push   $0x1
c0028de1:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028de5:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028de9:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028ded:	e8 10 ff ff ff       	call   c0028d02 <bitmap_contains>
c0028df2:	83 f0 01             	xor    $0x1,%eax
}
c0028df5:	83 c4 1c             	add    $0x1c,%esp
c0028df8:	c3                   	ret    

c0028df9 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c0028df9:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains (b, start, cnt, false);
c0028dfc:	6a 00                	push   $0x0
c0028dfe:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028e02:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028e06:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028e0a:	e8 f3 fe ff ff       	call   c0028d02 <bitmap_contains>
c0028e0f:	83 f0 01             	xor    $0x1,%eax
}
c0028e12:	83 c4 1c             	add    $0x1c,%esp
c0028e15:	c3                   	ret    

c0028e16 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c0028e16:	55                   	push   %ebp
c0028e17:	57                   	push   %edi
c0028e18:	56                   	push   %esi
c0028e19:	53                   	push   %ebx
c0028e1a:	83 ec 1c             	sub    $0x1c,%esp
c0028e1d:	8b 74 24 30          	mov    0x30(%esp),%esi
c0028e21:	8b 5c 24 34          	mov    0x34(%esp),%ebx
c0028e25:	8b 7c 24 38          	mov    0x38(%esp),%edi
c0028e29:	0f b6 4c 24 3c       	movzbl 0x3c(%esp),%ecx
  ASSERT (b != NULL);
c0028e2e:	85 f6                	test   %esi,%esi
c0028e30:	75 21                	jne    c0028e53 <bitmap_scan+0x3d>
c0028e32:	83 ec 0c             	sub    $0xc,%esp
c0028e35:	68 95 ea 02 c0       	push   $0xc002ea95
c0028e3a:	68 3f d2 02 c0       	push   $0xc002d23f
c0028e3f:	68 24 ce 02 c0       	push   $0xc002ce24
c0028e44:	68 2a 01 00 00       	push   $0x12a
c0028e49:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028e4e:	e8 7a ee ff ff       	call   c0027ccd <debug_panic>
  ASSERT (start <= b->bit_cnt);
c0028e53:	8b 16                	mov    (%esi),%edx
c0028e55:	39 da                	cmp    %ebx,%edx
c0028e57:	73 21                	jae    c0028e7a <bitmap_scan+0x64>
c0028e59:	83 ec 0c             	sub    $0xc,%esp
c0028e5c:	68 95 ee 02 c0       	push   $0xc002ee95
c0028e61:	68 3f d2 02 c0       	push   $0xc002d23f
c0028e66:	68 24 ce 02 c0       	push   $0xc002ce24
c0028e6b:	68 2b 01 00 00       	push   $0x12b
c0028e70:	68 6a ee 02 c0       	push   $0xc002ee6a
c0028e75:	e8 53 ee ff ff       	call   c0027ccd <debug_panic>
      size_t i;
      for (i = start; i <= last; i++)
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c0028e7a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);

  if (cnt <= b->bit_cnt) 
c0028e7f:	39 fa                	cmp    %edi,%edx
c0028e81:	72 39                	jb     c0028ebc <bitmap_scan+0xa6>
    {
      size_t last = b->bit_cnt - cnt;
c0028e83:	29 fa                	sub    %edi,%edx
c0028e85:	89 54 24 0c          	mov    %edx,0xc(%esp)
      size_t i;
      for (i = start; i <= last; i++)
c0028e89:	39 d3                	cmp    %edx,%ebx
c0028e8b:	77 26                	ja     c0028eb3 <bitmap_scan+0x9d>
        if (!bitmap_contains (b, i, cnt, !value))
c0028e8d:	83 f1 01             	xor    $0x1,%ecx
c0028e90:	0f b6 e9             	movzbl %cl,%ebp
c0028e93:	55                   	push   %ebp
c0028e94:	57                   	push   %edi
c0028e95:	53                   	push   %ebx
c0028e96:	56                   	push   %esi
c0028e97:	e8 66 fe ff ff       	call   c0028d02 <bitmap_contains>
c0028e9c:	83 c4 10             	add    $0x10,%esp
c0028e9f:	84 c0                	test   %al,%al
c0028ea1:	74 17                	je     c0028eba <bitmap_scan+0xa4>

  if (cnt <= b->bit_cnt) 
    {
      size_t last = b->bit_cnt - cnt;
      size_t i;
      for (i = start; i <= last; i++)
c0028ea3:	83 c3 01             	add    $0x1,%ebx
c0028ea6:	39 5c 24 0c          	cmp    %ebx,0xc(%esp)
c0028eaa:	73 e7                	jae    c0028e93 <bitmap_scan+0x7d>
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c0028eac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028eb1:	eb 09                	jmp    c0028ebc <bitmap_scan+0xa6>
c0028eb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028eb8:	eb 02                	jmp    c0028ebc <bitmap_scan+0xa6>
c0028eba:	89 d8                	mov    %ebx,%eax
}
c0028ebc:	83 c4 1c             	add    $0x1c,%esp
c0028ebf:	5b                   	pop    %ebx
c0028ec0:	5e                   	pop    %esi
c0028ec1:	5f                   	pop    %edi
c0028ec2:	5d                   	pop    %ebp
c0028ec3:	c3                   	ret    

c0028ec4 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c0028ec4:	55                   	push   %ebp
c0028ec5:	57                   	push   %edi
c0028ec6:	56                   	push   %esi
c0028ec7:	53                   	push   %ebx
c0028ec8:	83 ec 0c             	sub    $0xc,%esp
c0028ecb:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0028ecf:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c0028ed3:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan (b, start, cnt, value);
c0028ed7:	0f b6 c3             	movzbl %bl,%eax
c0028eda:	50                   	push   %eax
c0028edb:	55                   	push   %ebp
c0028edc:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028ee0:	57                   	push   %edi
c0028ee1:	e8 30 ff ff ff       	call   c0028e16 <bitmap_scan>
c0028ee6:	83 c4 10             	add    $0x10,%esp
c0028ee9:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR) 
c0028eeb:	83 f8 ff             	cmp    $0xffffffff,%eax
c0028eee:	74 12                	je     c0028f02 <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple (b, idx, cnt, !value);
c0028ef0:	83 f3 01             	xor    $0x1,%ebx
c0028ef3:	0f b6 db             	movzbl %bl,%ebx
c0028ef6:	53                   	push   %ebx
c0028ef7:	55                   	push   %ebp
c0028ef8:	50                   	push   %eax
c0028ef9:	57                   	push   %edi
c0028efa:	e8 8a fb ff ff       	call   c0028a89 <bitmap_set_multiple>
c0028eff:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c0028f02:	89 f0                	mov    %esi,%eax
c0028f04:	83 c4 0c             	add    $0xc,%esp
c0028f07:	5b                   	pop    %ebx
c0028f08:	5e                   	pop    %esi
c0028f09:	5f                   	pop    %edi
c0028f0a:	5d                   	pop    %ebp
c0028f0b:	c3                   	ret    

c0028f0c <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c0028f0c:	83 ec 0c             	sub    $0xc,%esp
c0028f0f:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c0028f13:	6a 00                	push   $0x0
c0028f15:	8b 02                	mov    (%edx),%eax
c0028f17:	83 c0 1f             	add    $0x1f,%eax
c0028f1a:	c1 e8 05             	shr    $0x5,%eax
c0028f1d:	c1 e0 02             	shl    $0x2,%eax
c0028f20:	50                   	push   %eax
c0028f21:	ff 72 04             	pushl  0x4(%edx)
c0028f24:	6a 00                	push   $0x0
c0028f26:	e8 54 d8 ff ff       	call   c002677f <hex_dump>
}
c0028f2b:	83 c4 1c             	add    $0x1c,%esp
c0028f2e:	c3                   	ret    

c0028f2f <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c0028f2f:	53                   	push   %ebx
c0028f30:	83 ec 10             	sub    $0x10,%esp
c0028f33:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c0028f35:	ff 70 14             	pushl  0x14(%eax)
c0028f38:	52                   	push   %edx
c0028f39:	ff 50 0c             	call   *0xc(%eax)
  return &h->buckets[bucket_idx];
c0028f3c:	8b 4b 04             	mov    0x4(%ebx),%ecx
c0028f3f:	8d 51 ff             	lea    -0x1(%ecx),%edx
c0028f42:	21 d0                	and    %edx,%eax
c0028f44:	c1 e0 04             	shl    $0x4,%eax
c0028f47:	03 43 08             	add    0x8(%ebx),%eax
}
c0028f4a:	83 c4 18             	add    $0x18,%esp
c0028f4d:	5b                   	pop    %ebx
c0028f4e:	c3                   	ret    

c0028f4f <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c0028f4f:	55                   	push   %ebp
c0028f50:	57                   	push   %edi
c0028f51:	56                   	push   %esi
c0028f52:	53                   	push   %ebx
c0028f53:	83 ec 18             	sub    $0x18,%esp
c0028f56:	89 c6                	mov    %eax,%esi
c0028f58:	89 d5                	mov    %edx,%ebp
c0028f5a:	89 cf                	mov    %ecx,%edi
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c0028f5c:	52                   	push   %edx
c0028f5d:	e8 55 ee ff ff       	call   c0027db7 <list_begin>
c0028f62:	89 c3                	mov    %eax,%ebx
c0028f64:	83 c4 10             	add    $0x10,%esp
c0028f67:	eb 32                	jmp    c0028f9b <find_elem+0x4c>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c0028f69:	83 ec 04             	sub    $0x4,%esp
c0028f6c:	ff 76 14             	pushl  0x14(%esi)
c0028f6f:	57                   	push   %edi
c0028f70:	53                   	push   %ebx
c0028f71:	ff 56 10             	call   *0x10(%esi)
c0028f74:	83 c4 10             	add    $0x10,%esp
c0028f77:	84 c0                	test   %al,%al
c0028f79:	75 12                	jne    c0028f8d <find_elem+0x3e>
c0028f7b:	83 ec 04             	sub    $0x4,%esp
c0028f7e:	ff 76 14             	pushl  0x14(%esi)
c0028f81:	53                   	push   %ebx
c0028f82:	57                   	push   %edi
c0028f83:	ff 56 10             	call   *0x10(%esi)
c0028f86:	83 c4 10             	add    $0x10,%esp
c0028f89:	84 c0                	test   %al,%al
c0028f8b:	74 25                	je     c0028fb2 <find_elem+0x63>
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c0028f8d:	83 ec 0c             	sub    $0xc,%esp
c0028f90:	53                   	push   %ebx
c0028f91:	e8 51 ee ff ff       	call   c0027de7 <list_next>
c0028f96:	89 c3                	mov    %eax,%ebx
c0028f98:	83 c4 10             	add    $0x10,%esp
c0028f9b:	83 ec 0c             	sub    $0xc,%esp
c0028f9e:	55                   	push   %ebp
c0028f9f:	e8 89 ee ff ff       	call   c0027e2d <list_end>
c0028fa4:	83 c4 10             	add    $0x10,%esp
c0028fa7:	39 c3                	cmp    %eax,%ebx
c0028fa9:	75 be                	jne    c0028f69 <find_elem+0x1a>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
        return hi; 
    }
  return NULL;
c0028fab:	b8 00 00 00 00       	mov    $0x0,%eax
c0028fb0:	eb 02                	jmp    c0028fb4 <find_elem+0x65>
c0028fb2:	89 d8                	mov    %ebx,%eax
}
c0028fb4:	83 c4 0c             	add    $0xc,%esp
c0028fb7:	5b                   	pop    %ebx
c0028fb8:	5e                   	pop    %esi
c0028fb9:	5f                   	pop    %edi
c0028fba:	5d                   	pop    %ebp
c0028fbb:	c3                   	ret    

c0028fbc <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c0028fbc:	55                   	push   %ebp
c0028fbd:	57                   	push   %edi
c0028fbe:	56                   	push   %esi
c0028fbf:	53                   	push   %ebx
c0028fc0:	83 ec 2c             	sub    $0x2c,%esp
c0028fc3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c0028fc7:	85 c0                	test   %eax,%eax
c0028fc9:	75 21                	jne    c0028fec <rehash+0x30>
c0028fcb:	83 ec 0c             	sub    $0xc,%esp
c0028fce:	68 ec ee 02 c0       	push   $0xc002eeec
c0028fd3:	68 3f d2 02 c0       	push   $0xc002d23f
c0028fd8:	68 e0 ce 02 c0       	push   $0xc002cee0
c0028fdd:	68 66 01 00 00       	push   $0x166
c0028fe2:	68 f6 ee 02 c0       	push   $0xc002eef6
c0028fe7:	e8 e1 ec ff ff       	call   c0027ccd <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c0028fec:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028ff0:	8b 48 04             	mov    0x4(%eax),%ecx
c0028ff3:	89 4c 24 18          	mov    %ecx,0x18(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c0028ff7:	8b 00                	mov    (%eax),%eax
c0028ff9:	89 44 24 10          	mov    %eax,0x10(%esp)
c0028ffd:	89 c3                	mov    %eax,%ebx
c0028fff:	d1 eb                	shr    %ebx
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
c0029001:	83 fb 03             	cmp    $0x3,%ebx
c0029004:	b8 04 00 00 00       	mov    $0x4,%eax
c0029009:	0f 46 d8             	cmovbe %eax,%ebx
c002900c:	eb 05                	jmp    c0029013 <rehash+0x57>

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
  return x & (x - 1);
c002900e:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0029011:	21 c3                	and    %eax,%ebx

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
  return x != 0 && turn_off_least_1bit (x) == 0;
c0029013:	85 db                	test   %ebx,%ebx
c0029015:	74 f7                	je     c002900e <rehash+0x52>
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c0029017:	8d 43 ff             	lea    -0x1(%ebx),%eax
c002901a:	85 d8                	test   %ebx,%eax
c002901c:	75 f0                	jne    c002900e <rehash+0x52>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002901e:	3b 5c 24 18          	cmp    0x18(%esp),%ebx
c0029022:	0f 84 dc 00 00 00    	je     c0029104 <rehash+0x148>
  size_t i;

  ASSERT (h != NULL);

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c0029028:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002902c:	8b 40 08             	mov    0x8(%eax),%eax
c002902f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c0029033:	83 ec 0c             	sub    $0xc,%esp
c0029036:	89 d8                	mov    %ebx,%eax
c0029038:	c1 e0 04             	shl    $0x4,%eax
c002903b:	50                   	push   %eax
c002903c:	e8 2e a4 ff ff       	call   c002346f <malloc>
c0029041:	89 c5                	mov    %eax,%ebp
  if (new_buckets == NULL) 
c0029043:	83 c4 10             	add    $0x10,%esp
c0029046:	85 c0                	test   %eax,%eax
c0029048:	0f 84 b6 00 00 00    	je     c0029104 <rehash+0x148>
c002904e:	89 c7                	mov    %eax,%edi
c0029050:	be 00 00 00 00       	mov    $0x0,%esi
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
    list_init (&new_buckets[i]);
c0029055:	83 ec 0c             	sub    $0xc,%esp
c0029058:	57                   	push   %edi
c0029059:	e8 16 ed ff ff       	call   c0027d74 <list_init>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002905e:	83 c6 01             	add    $0x1,%esi
c0029061:	83 c7 10             	add    $0x10,%edi
c0029064:	83 c4 10             	add    $0x10,%esp
c0029067:	39 f3                	cmp    %esi,%ebx
c0029069:	75 ea                	jne    c0029055 <rehash+0x99>
    list_init (&new_buckets[i]);

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002906b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002906f:	89 68 08             	mov    %ebp,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c0029072:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c0029075:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c002907a:	74 79                	je     c00290f5 <rehash+0x139>
c002907c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029080:	89 44 24 14          	mov    %eax,0x14(%esp)
c0029084:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c002908b:	00 
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002908c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0029090:	89 c5                	mov    %eax,%ebp
      for (elem = list_begin (old_bucket);
c0029092:	83 ec 0c             	sub    $0xc,%esp
c0029095:	50                   	push   %eax
c0029096:	e8 1c ed ff ff       	call   c0027db7 <list_begin>
c002909b:	89 c3                	mov    %eax,%ebx
c002909d:	83 c4 10             	add    $0x10,%esp
c00290a0:	eb 2f                	jmp    c00290d1 <rehash+0x115>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c00290a2:	89 da                	mov    %ebx,%edx
c00290a4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00290a8:	e8 82 fe ff ff       	call   c0028f2f <find_bucket>
c00290ad:	89 c7                	mov    %eax,%edi
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c00290af:	83 ec 0c             	sub    $0xc,%esp
c00290b2:	53                   	push   %ebx
c00290b3:	e8 2f ed ff ff       	call   c0027de7 <list_next>
c00290b8:	89 c6                	mov    %eax,%esi
          list_remove (elem);
c00290ba:	89 1c 24             	mov    %ebx,(%esp)
c00290bd:	e8 73 f1 ff ff       	call   c0028235 <list_remove>
          list_push_front (new_bucket, elem);
c00290c2:	83 c4 08             	add    $0x8,%esp
c00290c5:	53                   	push   %ebx
c00290c6:	57                   	push   %edi
c00290c7:	e8 2f f1 ff ff       	call   c00281fb <list_push_front>
c00290cc:	83 c4 10             	add    $0x10,%esp
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
c00290cf:	89 f3                	mov    %esi,%ebx
c00290d1:	83 ec 0c             	sub    $0xc,%esp
c00290d4:	55                   	push   %ebp
c00290d5:	e8 53 ed ff ff       	call   c0027e2d <list_end>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
c00290da:	83 c4 10             	add    $0x10,%esp
c00290dd:	39 c3                	cmp    %eax,%ebx
c00290df:	75 c1                	jne    c00290a2 <rehash+0xe6>
  /* Install new bucket info. */
  h->buckets = new_buckets;
  h->bucket_cnt = new_bucket_cnt;

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c00290e1:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
c00290e6:	8b 44 24 10          	mov    0x10(%esp),%eax
c00290ea:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c00290ef:	39 44 24 18          	cmp    %eax,0x18(%esp)
c00290f3:	75 97                	jne    c002908c <rehash+0xd0>
          list_remove (elem);
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
c00290f5:	83 ec 0c             	sub    $0xc,%esp
c00290f8:	ff 74 24 28          	pushl  0x28(%esp)
c00290fc:	e8 ff a4 ff ff       	call   c0023600 <free>
c0029101:	83 c4 10             	add    $0x10,%esp
}
c0029104:	83 c4 2c             	add    $0x2c,%esp
c0029107:	5b                   	pop    %ebx
c0029108:	5e                   	pop    %esi
c0029109:	5f                   	pop    %edi
c002910a:	5d                   	pop    %ebp
c002910b:	c3                   	ret    

c002910c <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002910c:	55                   	push   %ebp
c002910d:	57                   	push   %edi
c002910e:	56                   	push   %esi
c002910f:	53                   	push   %ebx
c0029110:	83 ec 0c             	sub    $0xc,%esp
c0029113:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029117:	8b 7c 24 24          	mov    0x24(%esp),%edi
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002911b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c002911f:	74 4c                	je     c002916d <hash_clear+0x61>
c0029121:	bd 00 00 00 00       	mov    $0x0,%ebp
    {
      struct list *bucket = &h->buckets[i];
c0029126:	89 eb                	mov    %ebp,%ebx
c0029128:	c1 e3 04             	shl    $0x4,%ebx
c002912b:	03 5e 08             	add    0x8(%esi),%ebx

      if (destructor != NULL) 
c002912e:	85 ff                	test   %edi,%edi
c0029130:	75 17                	jne    c0029149 <hash_clear+0x3d>
c0029132:	eb 25                	jmp    c0029159 <hash_clear+0x4d>
        while (!list_empty (bucket)) 
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c0029134:	83 ec 0c             	sub    $0xc,%esp
c0029137:	53                   	push   %ebx
c0029138:	e8 e7 f1 ff ff       	call   c0028324 <list_pop_front>
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
            destructor (hash_elem, h->aux);
c002913d:	83 c4 08             	add    $0x8,%esp
c0029140:	ff 76 14             	pushl  0x14(%esi)
c0029143:	50                   	push   %eax
c0029144:	ff d7                	call   *%edi
c0029146:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];

      if (destructor != NULL) 
        while (!list_empty (bucket)) 
c0029149:	83 ec 0c             	sub    $0xc,%esp
c002914c:	53                   	push   %ebx
c002914d:	e8 70 f1 ff ff       	call   c00282c2 <list_empty>
c0029152:	83 c4 10             	add    $0x10,%esp
c0029155:	84 c0                	test   %al,%al
c0029157:	74 db                	je     c0029134 <hash_clear+0x28>
            struct list_elem *list_elem = list_pop_front (bucket);
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
            destructor (hash_elem, h->aux);
          }

      list_init (bucket); 
c0029159:	83 ec 0c             	sub    $0xc,%esp
c002915c:	53                   	push   %ebx
c002915d:	e8 12 ec ff ff       	call   c0027d74 <list_init>
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c0029162:	83 c5 01             	add    $0x1,%ebp
c0029165:	83 c4 10             	add    $0x10,%esp
c0029168:	39 6e 04             	cmp    %ebp,0x4(%esi)
c002916b:	77 b9                	ja     c0029126 <hash_clear+0x1a>
          }

      list_init (bucket); 
    }    

  h->elem_cnt = 0;
c002916d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
c0029173:	83 c4 0c             	add    $0xc,%esp
c0029176:	5b                   	pop    %ebx
c0029177:	5e                   	pop    %esi
c0029178:	5f                   	pop    %edi
c0029179:	5d                   	pop    %ebp
c002917a:	c3                   	ret    

c002917b <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002917b:	53                   	push   %ebx
c002917c:	83 ec 14             	sub    $0x14,%esp
c002917f:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  h->elem_cnt = 0;
c0029183:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  h->bucket_cnt = 4;
c0029189:	c7 43 04 04 00 00 00 	movl   $0x4,0x4(%ebx)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c0029190:	6a 40                	push   $0x40
c0029192:	e8 d8 a2 ff ff       	call   c002346f <malloc>
c0029197:	89 c2                	mov    %eax,%edx
c0029199:	89 43 08             	mov    %eax,0x8(%ebx)
  h->hash = hash;
c002919c:	8b 44 24 24          	mov    0x24(%esp),%eax
c00291a0:	89 43 0c             	mov    %eax,0xc(%ebx)
  h->less = less;
c00291a3:	8b 44 24 28          	mov    0x28(%esp),%eax
c00291a7:	89 43 10             	mov    %eax,0x10(%ebx)
  h->aux = aux;
c00291aa:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c00291ae:	89 43 14             	mov    %eax,0x14(%ebx)

  if (h->buckets != NULL) 
c00291b1:	83 c4 10             	add    $0x10,%esp
    {
      hash_clear (h, NULL);
      return true;
    }
  else
    return false;
c00291b4:	b8 00 00 00 00       	mov    $0x0,%eax
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
  h->hash = hash;
  h->less = less;
  h->aux = aux;

  if (h->buckets != NULL) 
c00291b9:	85 d2                	test   %edx,%edx
c00291bb:	74 13                	je     c00291d0 <hash_init+0x55>
    {
      hash_clear (h, NULL);
c00291bd:	83 ec 08             	sub    $0x8,%esp
c00291c0:	6a 00                	push   $0x0
c00291c2:	53                   	push   %ebx
c00291c3:	e8 44 ff ff ff       	call   c002910c <hash_clear>
      return true;
c00291c8:	83 c4 10             	add    $0x10,%esp
c00291cb:	b8 01 00 00 00       	mov    $0x1,%eax
    }
  else
    return false;
}
c00291d0:	83 c4 08             	add    $0x8,%esp
c00291d3:	5b                   	pop    %ebx
c00291d4:	c3                   	ret    

c00291d5 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c00291d5:	53                   	push   %ebx
c00291d6:	83 ec 08             	sub    $0x8,%esp
c00291d9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00291dd:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c00291e1:	85 c0                	test   %eax,%eax
c00291e3:	74 0d                	je     c00291f2 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c00291e5:	83 ec 08             	sub    $0x8,%esp
c00291e8:	50                   	push   %eax
c00291e9:	53                   	push   %ebx
c00291ea:	e8 1d ff ff ff       	call   c002910c <hash_clear>
c00291ef:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c00291f2:	83 ec 0c             	sub    $0xc,%esp
c00291f5:	ff 73 08             	pushl  0x8(%ebx)
c00291f8:	e8 03 a4 ff ff       	call   c0023600 <free>
}
c00291fd:	83 c4 18             	add    $0x18,%esp
c0029200:	5b                   	pop    %ebx
c0029201:	c3                   	ret    

c0029202 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c0029202:	55                   	push   %ebp
c0029203:	57                   	push   %edi
c0029204:	56                   	push   %esi
c0029205:	53                   	push   %ebx
c0029206:	83 ec 0c             	sub    $0xc,%esp
c0029209:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c002920d:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c0029211:	89 f2                	mov    %esi,%edx
c0029213:	89 d8                	mov    %ebx,%eax
c0029215:	e8 15 fd ff ff       	call   c0028f2f <find_bucket>
c002921a:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c002921c:	89 f1                	mov    %esi,%ecx
c002921e:	89 c2                	mov    %eax,%edx
c0029220:	89 d8                	mov    %ebx,%eax
c0029222:	e8 28 fd ff ff       	call   c0028f4f <find_elem>
c0029227:	89 c7                	mov    %eax,%edi

  if (old == NULL) 
c0029229:	85 c0                	test   %eax,%eax
c002922b:	75 10                	jne    c002923d <hash_insert+0x3b>

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c002922d:	83 03 01             	addl   $0x1,(%ebx)
  list_push_front (bucket, &e->list_elem);
c0029230:	83 ec 08             	sub    $0x8,%esp
c0029233:	56                   	push   %esi
c0029234:	55                   	push   %ebp
c0029235:	e8 c1 ef ff ff       	call   c00281fb <list_push_front>
c002923a:	83 c4 10             	add    $0x10,%esp
  struct hash_elem *old = find_elem (h, bucket, new);

  if (old == NULL) 
    insert_elem (h, bucket, new);

  rehash (h);
c002923d:	89 d8                	mov    %ebx,%eax
c002923f:	e8 78 fd ff ff       	call   c0028fbc <rehash>

  return old; 
}
c0029244:	89 f8                	mov    %edi,%eax
c0029246:	83 c4 0c             	add    $0xc,%esp
c0029249:	5b                   	pop    %ebx
c002924a:	5e                   	pop    %esi
c002924b:	5f                   	pop    %edi
c002924c:	5d                   	pop    %ebp
c002924d:	c3                   	ret    

c002924e <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002924e:	55                   	push   %ebp
c002924f:	57                   	push   %edi
c0029250:	56                   	push   %esi
c0029251:	53                   	push   %ebx
c0029252:	83 ec 0c             	sub    $0xc,%esp
c0029255:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0029259:	8b 74 24 24          	mov    0x24(%esp),%esi
  struct list *bucket = find_bucket (h, new);
c002925d:	89 f2                	mov    %esi,%edx
c002925f:	89 d8                	mov    %ebx,%eax
c0029261:	e8 c9 fc ff ff       	call   c0028f2f <find_bucket>
c0029266:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem (h, bucket, new);
c0029268:	89 f1                	mov    %esi,%ecx
c002926a:	89 c2                	mov    %eax,%edx
c002926c:	89 d8                	mov    %ebx,%eax
c002926e:	e8 dc fc ff ff       	call   c0028f4f <find_elem>
c0029273:	89 c7                	mov    %eax,%edi

  if (old != NULL)
c0029275:	85 c0                	test   %eax,%eax
c0029277:	74 0f                	je     c0029288 <hash_replace+0x3a>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c0029279:	83 2b 01             	subl   $0x1,(%ebx)
  list_remove (&e->list_elem);
c002927c:	83 ec 0c             	sub    $0xc,%esp
c002927f:	50                   	push   %eax
c0029280:	e8 b0 ef ff ff       	call   c0028235 <list_remove>
c0029285:	83 c4 10             	add    $0x10,%esp

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  h->elem_cnt++;
c0029288:	83 03 01             	addl   $0x1,(%ebx)
  list_push_front (bucket, &e->list_elem);
c002928b:	83 ec 08             	sub    $0x8,%esp
c002928e:	56                   	push   %esi
c002928f:	55                   	push   %ebp
c0029290:	e8 66 ef ff ff       	call   c00281fb <list_push_front>

  if (old != NULL)
    remove_elem (h, old);
  insert_elem (h, bucket, new);

  rehash (h);
c0029295:	89 d8                	mov    %ebx,%eax
c0029297:	e8 20 fd ff ff       	call   c0028fbc <rehash>

  return old;
}
c002929c:	89 f8                	mov    %edi,%eax
c002929e:	83 c4 1c             	add    $0x1c,%esp
c00292a1:	5b                   	pop    %ebx
c00292a2:	5e                   	pop    %esi
c00292a3:	5f                   	pop    %edi
c00292a4:	5d                   	pop    %ebp
c00292a5:	c3                   	ret    

c00292a6 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c00292a6:	56                   	push   %esi
c00292a7:	53                   	push   %ebx
c00292a8:	83 ec 04             	sub    $0x4,%esp
c00292ab:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00292af:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem (h, find_bucket (h, e), e);
c00292b3:	89 f2                	mov    %esi,%edx
c00292b5:	89 d8                	mov    %ebx,%eax
c00292b7:	e8 73 fc ff ff       	call   c0028f2f <find_bucket>
c00292bc:	89 f1                	mov    %esi,%ecx
c00292be:	89 c2                	mov    %eax,%edx
c00292c0:	89 d8                	mov    %ebx,%eax
c00292c2:	e8 88 fc ff ff       	call   c0028f4f <find_elem>
}
c00292c7:	83 c4 04             	add    $0x4,%esp
c00292ca:	5b                   	pop    %ebx
c00292cb:	5e                   	pop    %esi
c00292cc:	c3                   	ret    

c00292cd <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c00292cd:	56                   	push   %esi
c00292ce:	53                   	push   %ebx
c00292cf:	83 ec 04             	sub    $0x4,%esp
c00292d2:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00292d6:	8b 74 24 14          	mov    0x14(%esp),%esi
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c00292da:	89 f2                	mov    %esi,%edx
c00292dc:	89 d8                	mov    %ebx,%eax
c00292de:	e8 4c fc ff ff       	call   c0028f2f <find_bucket>
c00292e3:	89 f1                	mov    %esi,%ecx
c00292e5:	89 c2                	mov    %eax,%edx
c00292e7:	89 d8                	mov    %ebx,%eax
c00292e9:	e8 61 fc ff ff       	call   c0028f4f <find_elem>
c00292ee:	89 c6                	mov    %eax,%esi
  if (found != NULL) 
c00292f0:	85 c0                	test   %eax,%eax
c00292f2:	74 16                	je     c002930a <hash_delete+0x3d>

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
  h->elem_cnt--;
c00292f4:	83 2b 01             	subl   $0x1,(%ebx)
  list_remove (&e->list_elem);
c00292f7:	83 ec 0c             	sub    $0xc,%esp
c00292fa:	50                   	push   %eax
c00292fb:	e8 35 ef ff ff       	call   c0028235 <list_remove>
{
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
  if (found != NULL) 
    {
      remove_elem (h, found);
      rehash (h); 
c0029300:	89 d8                	mov    %ebx,%eax
c0029302:	e8 b5 fc ff ff       	call   c0028fbc <rehash>
c0029307:	83 c4 10             	add    $0x10,%esp
    }
  return found;
}
c002930a:	89 f0                	mov    %esi,%eax
c002930c:	83 c4 04             	add    $0x4,%esp
c002930f:	5b                   	pop    %ebx
c0029310:	5e                   	pop    %esi
c0029311:	c3                   	ret    

c0029312 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c0029312:	55                   	push   %ebp
c0029313:	57                   	push   %edi
c0029314:	56                   	push   %esi
c0029315:	53                   	push   %ebx
c0029316:	83 ec 1c             	sub    $0x1c,%esp
c0029319:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  size_t i;
  
  ASSERT (action != NULL);
c002931d:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0029322:	74 10                	je     c0029334 <hash_apply+0x22>

  for (i = 0; i < h->bucket_cnt; i++) 
c0029324:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002932b:	00 
c002932c:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0029330:	75 23                	jne    c0029355 <hash_apply+0x43>
c0029332:	eb 74                	jmp    c00293a8 <hash_apply+0x96>
void
hash_apply (struct hash *h, hash_action_func *action) 
{
  size_t i;
  
  ASSERT (action != NULL);
c0029334:	83 ec 0c             	sub    $0xc,%esp
c0029337:	68 0e ef 02 c0       	push   $0xc002ef0e
c002933c:	68 3f d2 02 c0       	push   $0xc002d23f
c0029341:	68 d4 ce 02 c0       	push   $0xc002ced4
c0029346:	68 a7 00 00 00       	push   $0xa7
c002934b:	68 f6 ee 02 c0       	push   $0xc002eef6
c0029350:	e8 78 e9 ff ff       	call   c0027ccd <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];
c0029355:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0029359:	c1 e7 04             	shl    $0x4,%edi
c002935c:	03 7d 08             	add    0x8(%ebp),%edi
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002935f:	83 ec 0c             	sub    $0xc,%esp
c0029362:	57                   	push   %edi
c0029363:	e8 4f ea ff ff       	call   c0027db7 <list_begin>
c0029368:	89 c3                	mov    %eax,%ebx
c002936a:	83 c4 10             	add    $0x10,%esp
c002936d:	eb 1b                	jmp    c002938a <hash_apply+0x78>
        {
          next = list_next (elem);
c002936f:	83 ec 0c             	sub    $0xc,%esp
c0029372:	53                   	push   %ebx
c0029373:	e8 6f ea ff ff       	call   c0027de7 <list_next>
c0029378:	89 c6                	mov    %eax,%esi
          action (list_elem_to_hash_elem (elem), h->aux);
c002937a:	83 c4 08             	add    $0x8,%esp
c002937d:	ff 75 14             	pushl  0x14(%ebp)
c0029380:	53                   	push   %ebx
c0029381:	ff 54 24 44          	call   *0x44(%esp)
c0029385:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c0029388:	89 f3                	mov    %esi,%ebx
c002938a:	83 ec 0c             	sub    $0xc,%esp
c002938d:	57                   	push   %edi
c002938e:	e8 9a ea ff ff       	call   c0027e2d <list_end>
c0029393:	83 c4 10             	add    $0x10,%esp
c0029396:	39 c3                	cmp    %eax,%ebx
c0029398:	75 d5                	jne    c002936f <hash_apply+0x5d>
{
  size_t i;
  
  ASSERT (action != NULL);

  for (i = 0; i < h->bucket_cnt; i++) 
c002939a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002939f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00293a3:	39 45 04             	cmp    %eax,0x4(%ebp)
c00293a6:	77 ad                	ja     c0029355 <hash_apply+0x43>
        {
          next = list_next (elem);
          action (list_elem_to_hash_elem (elem), h->aux);
        }
    }
}
c00293a8:	83 c4 1c             	add    $0x1c,%esp
c00293ab:	5b                   	pop    %ebx
c00293ac:	5e                   	pop    %esi
c00293ad:	5f                   	pop    %edi
c00293ae:	5d                   	pop    %ebp
c00293af:	c3                   	ret    

c00293b0 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c00293b0:	53                   	push   %ebx
c00293b1:	83 ec 08             	sub    $0x8,%esp
c00293b4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00293b8:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT (i != NULL);
c00293bc:	85 db                	test   %ebx,%ebx
c00293be:	75 21                	jne    c00293e1 <hash_first+0x31>
c00293c0:	83 ec 0c             	sub    $0xc,%esp
c00293c3:	68 1d ef 02 c0       	push   $0xc002ef1d
c00293c8:	68 3f d2 02 c0       	push   $0xc002d23f
c00293cd:	68 c8 ce 02 c0       	push   $0xc002cec8
c00293d2:	68 ca 00 00 00       	push   $0xca
c00293d7:	68 f6 ee 02 c0       	push   $0xc002eef6
c00293dc:	e8 ec e8 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (h != NULL);
c00293e1:	85 c0                	test   %eax,%eax
c00293e3:	75 21                	jne    c0029406 <hash_first+0x56>
c00293e5:	83 ec 0c             	sub    $0xc,%esp
c00293e8:	68 ec ee 02 c0       	push   $0xc002eeec
c00293ed:	68 3f d2 02 c0       	push   $0xc002d23f
c00293f2:	68 c8 ce 02 c0       	push   $0xc002cec8
c00293f7:	68 cb 00 00 00       	push   $0xcb
c00293fc:	68 f6 ee 02 c0       	push   $0xc002eef6
c0029401:	e8 c7 e8 ff ff       	call   c0027ccd <debug_panic>

  i->hash = h;
c0029406:	89 03                	mov    %eax,(%ebx)
  i->bucket = i->hash->buckets;
c0029408:	8b 40 08             	mov    0x8(%eax),%eax
c002940b:	89 43 04             	mov    %eax,0x4(%ebx)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002940e:	83 ec 0c             	sub    $0xc,%esp
c0029411:	50                   	push   %eax
c0029412:	e8 1e ec ff ff       	call   c0028035 <list_head>
c0029417:	89 43 08             	mov    %eax,0x8(%ebx)
}
c002941a:	83 c4 18             	add    $0x18,%esp
c002941d:	5b                   	pop    %ebx
c002941e:	c3                   	ret    

c002941f <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002941f:	56                   	push   %esi
c0029420:	53                   	push   %ebx
c0029421:	83 ec 04             	sub    $0x4,%esp
c0029424:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  ASSERT (i != NULL);
c0029428:	85 db                	test   %ebx,%ebx
c002942a:	75 21                	jne    c002944d <hash_next+0x2e>
c002942c:	83 ec 0c             	sub    $0xc,%esp
c002942f:	68 1d ef 02 c0       	push   $0xc002ef1d
c0029434:	68 3f d2 02 c0       	push   $0xc002d23f
c0029439:	68 bc ce 02 c0       	push   $0xc002cebc
c002943e:	68 dd 00 00 00       	push   $0xdd
c0029443:	68 f6 ee 02 c0       	push   $0xc002eef6
c0029448:	e8 80 e8 ff ff       	call   c0027ccd <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002944d:	83 ec 0c             	sub    $0xc,%esp
c0029450:	ff 73 08             	pushl  0x8(%ebx)
c0029453:	e8 8f e9 ff ff       	call   c0027de7 <list_next>
c0029458:	89 43 08             	mov    %eax,0x8(%ebx)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002945b:	83 c4 10             	add    $0x10,%esp
c002945e:	eb 30                	jmp    c0029490 <hash_next+0x71>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c0029460:	8b 43 04             	mov    0x4(%ebx),%eax
c0029463:	8d 50 10             	lea    0x10(%eax),%edx
c0029466:	89 53 04             	mov    %edx,0x4(%ebx)
c0029469:	8b 0b                	mov    (%ebx),%ecx
c002946b:	8b 41 04             	mov    0x4(%ecx),%eax
c002946e:	c1 e0 04             	shl    $0x4,%eax
c0029471:	03 41 08             	add    0x8(%ecx),%eax
c0029474:	39 c2                	cmp    %eax,%edx
c0029476:	72 09                	jb     c0029481 <hash_next+0x62>
        {
          i->elem = NULL;
c0029478:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
          break;
c002947f:	eb 24                	jmp    c00294a5 <hash_next+0x86>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c0029481:	83 ec 0c             	sub    $0xc,%esp
c0029484:	52                   	push   %edx
c0029485:	e8 2d e9 ff ff       	call   c0027db7 <list_begin>
c002948a:	89 43 08             	mov    %eax,0x8(%ebx)
c002948d:	83 c4 10             	add    $0x10,%esp
hash_next (struct hash_iterator *i)
{
  ASSERT (i != NULL);

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c0029490:	8b 73 08             	mov    0x8(%ebx),%esi
c0029493:	83 ec 0c             	sub    $0xc,%esp
c0029496:	ff 73 04             	pushl  0x4(%ebx)
c0029499:	e8 8f e9 ff ff       	call   c0027e2d <list_end>
c002949e:	83 c4 10             	add    $0x10,%esp
c00294a1:	39 c6                	cmp    %eax,%esi
c00294a3:	74 bb                	je     c0029460 <hash_next+0x41>
          break;
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
    }
  
  return i->elem;
c00294a5:	8b 43 08             	mov    0x8(%ebx),%eax
}
c00294a8:	83 c4 04             	add    $0x4,%esp
c00294ab:	5b                   	pop    %ebx
c00294ac:	5e                   	pop    %esi
c00294ad:	c3                   	ret    

c00294ae <hash_cur>:
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
  return i->elem;
c00294ae:	8b 44 24 04          	mov    0x4(%esp),%eax
c00294b2:	8b 40 08             	mov    0x8(%eax),%eax
}
c00294b5:	c3                   	ret    

c00294b6 <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
  return h->elem_cnt;
c00294b6:	8b 44 24 04          	mov    0x4(%esp),%eax
c00294ba:	8b 00                	mov    (%eax),%eax
}
c00294bc:	c3                   	ret    

c00294bd <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
  return h->elem_cnt == 0;
c00294bd:	8b 44 24 04          	mov    0x4(%esp),%eax
c00294c1:	83 38 00             	cmpl   $0x0,(%eax)
c00294c4:	0f 94 c0             	sete   %al
}
c00294c7:	c3                   	ret    

c00294c8 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c00294c8:	53                   	push   %ebx
c00294c9:	83 ec 08             	sub    $0x8,%esp
c00294cc:	8b 54 24 10          	mov    0x10(%esp),%edx
c00294d0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
  unsigned hash;

  ASSERT (buf != NULL);
c00294d4:	85 d2                	test   %edx,%edx
c00294d6:	74 0e                	je     c00294e6 <hash_bytes+0x1e>
c00294d8:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx

  hash = FNV_32_BASIS;
  while (size-- > 0)
c00294db:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c00294e0:	85 c9                	test   %ecx,%ecx
c00294e2:	75 23                	jne    c0029507 <hash_bytes+0x3f>
c00294e4:	eb 34                	jmp    c002951a <hash_bytes+0x52>
{
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
  unsigned hash;

  ASSERT (buf != NULL);
c00294e6:	83 ec 0c             	sub    $0xc,%esp
c00294e9:	68 27 ef 02 c0       	push   $0xc002ef27
c00294ee:	68 3f d2 02 c0       	push   $0xc002d23f
c00294f3:	68 b0 ce 02 c0       	push   $0xc002ceb0
c00294f8:	68 10 01 00 00       	push   $0x110
c00294fd:	68 f6 ee 02 c0       	push   $0xc002eef6
c0029502:	e8 c6 e7 ff ff       	call   c0027ccd <debug_panic>

  hash = FNV_32_BASIS;
  while (size-- > 0)
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c0029507:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002950d:	83 c2 01             	add    $0x1,%edx
c0029510:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c0029514:	31 c8                	xor    %ecx,%eax
  unsigned hash;

  ASSERT (buf != NULL);

  hash = FNV_32_BASIS;
  while (size-- > 0)
c0029516:	39 da                	cmp    %ebx,%edx
c0029518:	75 ed                	jne    c0029507 <hash_bytes+0x3f>
    hash = (hash * FNV_32_PRIME) ^ *buf++;

  return hash;
} 
c002951a:	83 c4 08             	add    $0x8,%esp
c002951d:	5b                   	pop    %ebx
c002951e:	c3                   	ret    

c002951f <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002951f:	83 ec 0c             	sub    $0xc,%esp
c0029522:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  const unsigned char *s = (const unsigned char *) s_;
  unsigned hash;

  ASSERT (s != NULL);
c0029526:	85 c9                	test   %ecx,%ecx
c0029528:	74 0e                	je     c0029538 <hash_string+0x19>

  hash = FNV_32_BASIS;
  while (*s != '\0')
c002952a:	0f b6 11             	movzbl (%ecx),%edx
c002952d:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
c0029532:	84 d2                	test   %dl,%dl
c0029534:	75 23                	jne    c0029559 <hash_string+0x3a>
c0029536:	eb 36                	jmp    c002956e <hash_string+0x4f>
hash_string (const char *s_) 
{
  const unsigned char *s = (const unsigned char *) s_;
  unsigned hash;

  ASSERT (s != NULL);
c0029538:	83 ec 0c             	sub    $0xc,%esp
c002953b:	68 d2 ea 02 c0       	push   $0xc002ead2
c0029540:	68 3f d2 02 c0       	push   $0xc002d23f
c0029545:	68 a4 ce 02 c0       	push   $0xc002cea4
c002954a:	68 20 01 00 00       	push   $0x120
c002954f:	68 f6 ee 02 c0       	push   $0xc002eef6
c0029554:	e8 74 e7 ff ff       	call   c0027ccd <debug_panic>

  hash = FNV_32_BASIS;
  while (*s != '\0')
    hash = (hash * FNV_32_PRIME) ^ *s++;
c0029559:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002955f:	83 c1 01             	add    $0x1,%ecx
c0029562:	0f b6 d2             	movzbl %dl,%edx
c0029565:	31 d0                	xor    %edx,%eax
  unsigned hash;

  ASSERT (s != NULL);

  hash = FNV_32_BASIS;
  while (*s != '\0')
c0029567:	0f b6 11             	movzbl (%ecx),%edx
c002956a:	84 d2                	test   %dl,%dl
c002956c:	75 eb                	jne    c0029559 <hash_string+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *s++;

  return hash;
}
c002956e:	83 c4 0c             	add    $0xc,%esp
c0029571:	c3                   	ret    

c0029572 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c0029572:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes (&i, sizeof i);
c0029575:	6a 04                	push   $0x4
c0029577:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002957b:	50                   	push   %eax
c002957c:	e8 47 ff ff ff       	call   c00294c8 <hash_bytes>
}
c0029581:	83 c4 1c             	add    $0x1c,%esp
c0029584:	c3                   	ret    

c0029585 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c0029585:	53                   	push   %ebx
c0029586:	83 ec 08             	sub    $0x8,%esp
c0029589:	89 c3                	mov    %eax,%ebx
/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
c002958b:	e8 3f 83 ff ff       	call   c00218cf <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c0029590:	84 c0                	test   %al,%al
c0029592:	75 3e                	jne    c00295d2 <putchar_have_lock+0x4d>
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
          || !use_console_lock
c0029594:	80 3d 0c 96 03 c0 00 	cmpb   $0x0,0xc003960c
c002959b:	74 35                	je     c00295d2 <putchar_have_lock+0x4d>
          || lock_held_by_current_thread (&console_lock));
c002959d:	83 ec 0c             	sub    $0xc,%esp
c00295a0:	68 20 96 03 c0       	push   $0xc0039620
c00295a5:	e8 d7 93 ff ff       	call   c0022981 <lock_held_by_current_thread>
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
  ASSERT (console_locked_by_current_thread ());
c00295aa:	83 c4 10             	add    $0x10,%esp
c00295ad:	84 c0                	test   %al,%al
c00295af:	75 21                	jne    c00295d2 <putchar_have_lock+0x4d>
c00295b1:	83 ec 0c             	sub    $0xc,%esp
c00295b4:	68 34 ef 02 c0       	push   $0xc002ef34
c00295b9:	68 3f d2 02 c0       	push   $0xc002d23f
c00295be:	68 e8 ce 02 c0       	push   $0xc002cee8
c00295c3:	68 bb 00 00 00       	push   $0xbb
c00295c8:	68 79 ef 02 c0       	push   $0xc002ef79
c00295cd:	e8 fb e6 ff ff       	call   c0027ccd <debug_panic>
  write_cnt++;
c00295d2:	83 05 00 96 03 c0 01 	addl   $0x1,0xc0039600
c00295d9:	83 15 04 96 03 c0 00 	adcl   $0x0,0xc0039604
  serial_putc (c);
c00295e0:	0f b6 db             	movzbl %bl,%ebx
c00295e3:	83 ec 0c             	sub    $0xc,%esp
c00295e6:	53                   	push   %ebx
c00295e7:	e8 ef ac ff ff       	call   c00242db <serial_putc>
  vga_putc (c);
c00295ec:	89 1c 24             	mov    %ebx,(%esp)
c00295ef:	e8 28 a9 ff ff       	call   c0023f1c <vga_putc>
}
c00295f4:	83 c4 18             	add    $0x18,%esp
c00295f7:	5b                   	pop    %ebx
c00295f8:	c3                   	ret    

c00295f9 <vprintf_helper>:
}

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c00295f9:	83 ec 0c             	sub    $0xc,%esp
c00295fc:	8b 44 24 14          	mov    0x14(%esp),%eax
  int *char_cnt = char_cnt_;
  (*char_cnt)++;
c0029600:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock (c);
c0029603:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c0029608:	e8 78 ff ff ff       	call   c0029585 <putchar_have_lock>
}
c002960d:	83 c4 0c             	add    $0xc,%esp
c0029610:	c3                   	ret    

c0029611 <acquire_console>:
}

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c0029611:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c0029614:	e8 b6 82 ff ff       	call   c00218cf <intr_context>
c0029619:	84 c0                	test   %al,%al
c002961b:	75 36                	jne    c0029653 <acquire_console+0x42>
c002961d:	80 3d 0c 96 03 c0 00 	cmpb   $0x0,0xc003960c
c0029624:	74 2d                	je     c0029653 <acquire_console+0x42>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c0029626:	83 ec 0c             	sub    $0xc,%esp
c0029629:	68 20 96 03 c0       	push   $0xc0039620
c002962e:	e8 4e 93 ff ff       	call   c0022981 <lock_held_by_current_thread>
c0029633:	83 c4 10             	add    $0x10,%esp
c0029636:	84 c0                	test   %al,%al
c0029638:	74 09                	je     c0029643 <acquire_console+0x32>
        console_lock_depth++; 
c002963a:	83 05 08 96 03 c0 01 	addl   $0x1,0xc0039608
c0029641:	eb 10                	jmp    c0029653 <acquire_console+0x42>
      else
        lock_acquire (&console_lock); 
c0029643:	83 ec 0c             	sub    $0xc,%esp
c0029646:	68 20 96 03 c0       	push   $0xc0039620
c002964b:	e8 6f 93 ff ff       	call   c00229bf <lock_acquire>
c0029650:	83 c4 10             	add    $0x10,%esp
    }
}
c0029653:	83 c4 0c             	add    $0xc,%esp
c0029656:	c3                   	ret    

c0029657 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c0029657:	83 ec 0c             	sub    $0xc,%esp
  if (!intr_context () && use_console_lock) 
c002965a:	e8 70 82 ff ff       	call   c00218cf <intr_context>
c002965f:	84 c0                	test   %al,%al
c0029661:	75 2c                	jne    c002968f <release_console+0x38>
c0029663:	80 3d 0c 96 03 c0 00 	cmpb   $0x0,0xc003960c
c002966a:	74 23                	je     c002968f <release_console+0x38>
    {
      if (console_lock_depth > 0)
c002966c:	a1 08 96 03 c0       	mov    0xc0039608,%eax
c0029671:	85 c0                	test   %eax,%eax
c0029673:	7e 0a                	jle    c002967f <release_console+0x28>
        console_lock_depth--;
c0029675:	83 e8 01             	sub    $0x1,%eax
c0029678:	a3 08 96 03 c0       	mov    %eax,0xc0039608
c002967d:	eb 10                	jmp    c002968f <release_console+0x38>
      else
        lock_release (&console_lock); 
c002967f:	83 ec 0c             	sub    $0xc,%esp
c0029682:	68 20 96 03 c0       	push   $0xc0039620
c0029687:	e8 c3 94 ff ff       	call   c0022b4f <lock_release>
c002968c:	83 c4 10             	add    $0x10,%esp
    }
}
c002968f:	83 c4 0c             	add    $0xc,%esp
c0029692:	c3                   	ret    

c0029693 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c0029693:	83 ec 18             	sub    $0x18,%esp
  lock_init (&console_lock);
c0029696:	68 20 96 03 c0       	push   $0xc0039620
c002969b:	e8 9d 92 ff ff       	call   c002293d <lock_init>
  use_console_lock = true;
c00296a0:	c6 05 0c 96 03 c0 01 	movb   $0x1,0xc003960c
}
c00296a7:	83 c4 1c             	add    $0x1c,%esp
c00296aa:	c3                   	ret    

c00296ab <console_panic>:
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
  use_console_lock = false;
c00296ab:	c6 05 0c 96 03 c0 00 	movb   $0x0,0xc003960c
c00296b2:	c3                   	ret    

c00296b3 <console_print_stats>:
}

/* Prints console statistics. */
void
console_print_stats (void) 
{
c00296b3:	83 ec 10             	sub    $0x10,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c00296b6:	ff 35 04 96 03 c0    	pushl  0xc0039604
c00296bc:	ff 35 00 96 03 c0    	pushl  0xc0039600
c00296c2:	68 58 ef 02 c0       	push   $0xc002ef58
c00296c7:	e8 89 c9 ff ff       	call   c0026055 <printf>
}
c00296cc:	83 c4 1c             	add    $0x1c,%esp
c00296cf:	c3                   	ret    

c00296d0 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c00296d0:	83 ec 1c             	sub    $0x1c,%esp
  int char_cnt = 0;
c00296d3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00296da:	00 

  acquire_console ();
c00296db:	e8 31 ff ff ff       	call   c0029611 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c00296e0:	8d 44 24 0c          	lea    0xc(%esp),%eax
c00296e4:	50                   	push   %eax
c00296e5:	68 f9 95 02 c0       	push   $0xc00295f9
c00296ea:	ff 74 24 2c          	pushl  0x2c(%esp)
c00296ee:	ff 74 24 2c          	pushl  0x2c(%esp)
c00296f2:	e8 93 c9 ff ff       	call   c002608a <__vprintf>
  release_console ();
c00296f7:	e8 5b ff ff ff       	call   c0029657 <release_console>

  return char_cnt;
}
c00296fc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029700:	83 c4 2c             	add    $0x2c,%esp
c0029703:	c3                   	ret    

c0029704 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c0029704:	53                   	push   %ebx
c0029705:	83 ec 08             	sub    $0x8,%esp
c0029708:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002970c:	e8 00 ff ff ff       	call   c0029611 <acquire_console>
  while (*s != '\0')
c0029711:	0f b6 03             	movzbl (%ebx),%eax
c0029714:	84 c0                	test   %al,%al
c0029716:	74 12                	je     c002972a <puts+0x26>
    putchar_have_lock (*s++);
c0029718:	83 c3 01             	add    $0x1,%ebx
c002971b:	0f b6 c0             	movzbl %al,%eax
c002971e:	e8 62 fe ff ff       	call   c0029585 <putchar_have_lock>
   character. */
int
puts (const char *s) 
{
  acquire_console ();
  while (*s != '\0')
c0029723:	0f b6 03             	movzbl (%ebx),%eax
c0029726:	84 c0                	test   %al,%al
c0029728:	75 ee                	jne    c0029718 <puts+0x14>
    putchar_have_lock (*s++);
  putchar_have_lock ('\n');
c002972a:	b8 0a 00 00 00       	mov    $0xa,%eax
c002972f:	e8 51 fe ff ff       	call   c0029585 <putchar_have_lock>
  release_console ();
c0029734:	e8 1e ff ff ff       	call   c0029657 <release_console>

  return 0;
}
c0029739:	b8 00 00 00 00       	mov    $0x0,%eax
c002973e:	83 c4 08             	add    $0x8,%esp
c0029741:	5b                   	pop    %ebx
c0029742:	c3                   	ret    

c0029743 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c0029743:	56                   	push   %esi
c0029744:	53                   	push   %ebx
c0029745:	83 ec 04             	sub    $0x4,%esp
c0029748:	8b 74 24 10          	mov    0x10(%esp),%esi
c002974c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  acquire_console ();
c0029750:	e8 bc fe ff ff       	call   c0029611 <acquire_console>
  while (n-- > 0)
c0029755:	85 db                	test   %ebx,%ebx
c0029757:	74 11                	je     c002976a <putbuf+0x27>
    putchar_have_lock (*buffer++);
c0029759:	83 c6 01             	add    $0x1,%esi
c002975c:	0f b6 46 ff          	movzbl -0x1(%esi),%eax
c0029760:	e8 20 fe ff ff       	call   c0029585 <putchar_have_lock>
/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
  acquire_console ();
  while (n-- > 0)
c0029765:	83 eb 01             	sub    $0x1,%ebx
c0029768:	75 ef                	jne    c0029759 <putbuf+0x16>
    putchar_have_lock (*buffer++);
  release_console ();
c002976a:	e8 e8 fe ff ff       	call   c0029657 <release_console>
}
c002976f:	83 c4 04             	add    $0x4,%esp
c0029772:	5b                   	pop    %ebx
c0029773:	5e                   	pop    %esi
c0029774:	c3                   	ret    

c0029775 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c0029775:	53                   	push   %ebx
c0029776:	83 ec 08             	sub    $0x8,%esp
c0029779:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console ();
c002977d:	e8 8f fe ff ff       	call   c0029611 <acquire_console>
  putchar_have_lock (c);
c0029782:	0f b6 c3             	movzbl %bl,%eax
c0029785:	e8 fb fd ff ff       	call   c0029585 <putchar_have_lock>
  release_console ();
c002978a:	e8 c8 fe ff ff       	call   c0029657 <release_console>
  
  return c;
}
c002978f:	89 d8                	mov    %ebx,%eax
c0029791:	83 c4 08             	add    $0x8,%esp
c0029794:	5b                   	pop    %ebx
c0029795:	c3                   	ret    

c0029796 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c0029796:	83 ec 14             	sub    $0x14,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c0029799:	ff 35 40 96 03 c0    	pushl  0xc0039640
c002979f:	68 94 ef 02 c0       	push   $0xc002ef94
c00297a4:	e8 ac c8 ff ff       	call   c0026055 <printf>
  va_start (args, format);
c00297a9:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c00297ad:	83 c4 08             	add    $0x8,%esp
c00297b0:	50                   	push   %eax
c00297b1:	ff 74 24 1c          	pushl  0x1c(%esp)
c00297b5:	e8 16 ff ff ff       	call   c00296d0 <vprintf>
  va_end (args);
  putchar ('\n');
c00297ba:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c00297c1:	e8 af ff ff ff       	call   c0029775 <putchar>
}
c00297c6:	83 c4 1c             	add    $0x1c,%esp
c00297c9:	c3                   	ret    

c00297ca <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c00297ca:	56                   	push   %esi
c00297cb:	53                   	push   %ebx
c00297cc:	83 ec 04             	sub    $0x4,%esp
c00297cf:	8b 74 24 10          	mov    0x10(%esp),%esi
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c00297d3:	bb 20 cf 02 c0       	mov    $0xc002cf20,%ebx
    if (!strcmp (name, t->name))
c00297d8:	83 ec 08             	sub    $0x8,%esp
c00297db:	ff 33                	pushl  (%ebx)
c00297dd:	56                   	push   %esi
c00297de:	e8 81 d7 ff ff       	call   c0026f64 <strcmp>
c00297e3:	83 c4 10             	add    $0x10,%esp
c00297e6:	85 c0                	test   %eax,%eax
c00297e8:	75 27                	jne    c0029811 <run_test+0x47>
      {
        test_name = name;
c00297ea:	89 35 40 96 03 c0    	mov    %esi,0xc0039640
        msg ("begin");
c00297f0:	83 ec 0c             	sub    $0xc,%esp
c00297f3:	68 9a ef 02 c0       	push   $0xc002ef9a
c00297f8:	e8 99 ff ff ff       	call   c0029796 <msg>
        t->function ();
c00297fd:	ff 53 04             	call   *0x4(%ebx)
        msg ("end");
c0029800:	c7 04 24 a0 ef 02 c0 	movl   $0xc002efa0,(%esp)
c0029807:	e8 8a ff ff ff       	call   c0029796 <msg>
        return;
c002980c:	83 c4 10             	add    $0x10,%esp
c002980f:	eb 25                	jmp    c0029836 <run_test+0x6c>
void
run_test (const char *name) 
{
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c0029811:	83 c3 08             	add    $0x8,%ebx
c0029814:	81 fb f8 cf 02 c0    	cmp    $0xc002cff8,%ebx
c002981a:	75 bc                	jne    c00297d8 <run_test+0xe>
        msg ("begin");
        t->function ();
        msg ("end");
        return;
      }
  PANIC ("no test named \"%s\"", name);
c002981c:	83 ec 0c             	sub    $0xc,%esp
c002981f:	56                   	push   %esi
c0029820:	68 a4 ef 02 c0       	push   $0xc002efa4
c0029825:	68 08 cf 02 c0       	push   $0xc002cf08
c002982a:	6a 3c                	push   $0x3c
c002982c:	68 b7 ef 02 c0       	push   $0xc002efb7
c0029831:	e8 97 e4 ff ff       	call   c0027ccd <debug_panic>
}
c0029836:	83 c4 04             	add    $0x4,%esp
c0029839:	5b                   	pop    %ebx
c002983a:	5e                   	pop    %esi
c002983b:	c3                   	ret    

c002983c <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002983c:	83 ec 14             	sub    $0x14,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002983f:	ff 35 40 96 03 c0    	pushl  0xc0039640
c0029845:	68 d3 ef 02 c0       	push   $0xc002efd3
c002984a:	e8 06 c8 ff ff       	call   c0026055 <printf>
  va_start (args, format);
c002984f:	8d 44 24 24          	lea    0x24(%esp),%eax
  vprintf (format, args);
c0029853:	83 c4 08             	add    $0x8,%esp
c0029856:	50                   	push   %eax
c0029857:	ff 74 24 1c          	pushl  0x1c(%esp)
c002985b:	e8 70 fe ff ff       	call   c00296d0 <vprintf>
  va_end (args);
  putchar ('\n');
c0029860:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0029867:	e8 09 ff ff ff       	call   c0029775 <putchar>

  PANIC ("test failed");
c002986c:	68 df ef 02 c0       	push   $0xc002efdf
c0029871:	68 00 cf 02 c0       	push   $0xc002cf00
c0029876:	6a 5d                	push   $0x5d
c0029878:	68 b7 ef 02 c0       	push   $0xc002efb7
c002987d:	e8 4b e4 ff ff       	call   c0027ccd <debug_panic>

c0029882 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c0029882:	83 ec 14             	sub    $0x14,%esp
  printf ("(%s) PASS\n", test_name);
c0029885:	ff 35 40 96 03 c0    	pushl  0xc0039640
c002988b:	68 eb ef 02 c0       	push   $0xc002efeb
c0029890:	e8 c0 c7 ff ff       	call   c0026055 <printf>
}
c0029895:	83 c4 1c             	add    $0x1c,%esp
c0029898:	c3                   	ret    

c0029899 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c0029899:	55                   	push   %ebp
c002989a:	57                   	push   %edi
c002989b:	56                   	push   %esi
c002989c:	53                   	push   %ebx
c002989d:	83 ec 1c             	sub    $0x1c,%esp
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
c00298a0:	8b 44 24 30          	mov    0x30(%esp),%eax
c00298a4:	8b 18                	mov    (%eax),%ebx
  int i;

  for (i = 1; i <= test->iterations; i++) 
c00298a6:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c00298aa:	7e 64                	jle    c0029910 <sleeper+0x77>
c00298ac:	bd 01 00 00 00       	mov    $0x1,%ebp
    {
      int64_t sleep_until = test->start + i * t->duration;
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
c00298b1:	8d 43 0c             	lea    0xc(%ebx),%eax
c00298b4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  struct sleep_test *test = t->test;
  int i;

  for (i = 1; i <= test->iterations; i++) 
    {
      int64_t sleep_until = test->start + i * t->duration;
c00298b8:	89 e8                	mov    %ebp,%eax
c00298ba:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c00298be:	0f af 41 08          	imul   0x8(%ecx),%eax
c00298c2:	99                   	cltd   
c00298c3:	03 03                	add    (%ebx),%eax
c00298c5:	13 53 04             	adc    0x4(%ebx),%edx
c00298c8:	89 c6                	mov    %eax,%esi
c00298ca:	89 d7                	mov    %edx,%edi
      timer_sleep (sleep_until - timer_ticks ());
c00298cc:	e8 6c a1 ff ff       	call   c0023a3d <timer_ticks>
c00298d1:	83 ec 08             	sub    $0x8,%esp
c00298d4:	29 c6                	sub    %eax,%esi
c00298d6:	19 d7                	sbb    %edx,%edi
c00298d8:	57                   	push   %edi
c00298d9:	56                   	push   %esi
c00298da:	e8 a3 a1 ff ff       	call   c0023a82 <timer_sleep>
      lock_acquire (&test->output_lock);
c00298df:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c00298e3:	89 3c 24             	mov    %edi,(%esp)
c00298e6:	e8 d4 90 ff ff       	call   c00229bf <lock_acquire>
      *test->output_pos++ = t->id;
c00298eb:	8b 43 2c             	mov    0x2c(%ebx),%eax
c00298ee:	8d 50 04             	lea    0x4(%eax),%edx
c00298f1:	89 53 2c             	mov    %edx,0x2c(%ebx)
c00298f4:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c00298f8:	8b 51 04             	mov    0x4(%ecx),%edx
c00298fb:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c00298fd:	89 3c 24             	mov    %edi,(%esp)
c0029900:	e8 4a 92 ff ff       	call   c0022b4f <lock_release>
{
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
  int i;

  for (i = 1; i <= test->iterations; i++) 
c0029905:	83 c5 01             	add    $0x1,%ebp
c0029908:	83 c4 10             	add    $0x10,%esp
c002990b:	39 6b 08             	cmp    %ebp,0x8(%ebx)
c002990e:	7d a8                	jge    c00298b8 <sleeper+0x1f>
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
      *test->output_pos++ = t->id;
      lock_release (&test->output_lock);
    }
}
c0029910:	83 c4 1c             	add    $0x1c,%esp
c0029913:	5b                   	pop    %ebx
c0029914:	5e                   	pop    %esi
c0029915:	5f                   	pop    %edi
c0029916:	5d                   	pop    %ebp
c0029917:	c3                   	ret    

c0029918 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c0029918:	55                   	push   %ebp
c0029919:	57                   	push   %edi
c002991a:	56                   	push   %esi
c002991b:	53                   	push   %ebx
c002991c:	83 ec 5c             	sub    $0x5c,%esp
c002991f:	89 04 24             	mov    %eax,(%esp)
c0029922:	89 54 24 0c          	mov    %edx,0xc(%esp)
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0029926:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002992d:	74 1e                	je     c002994d <test_sleep+0x35>
c002992f:	83 ec 0c             	sub    $0xc,%esp
c0029932:	68 b4 f1 02 c0       	push   $0xc002f1b4
c0029937:	68 3f d2 02 c0       	push   $0xc002d23f
c002993c:	68 f8 cf 02 c0       	push   $0xc002cff8
c0029941:	6a 3c                	push   $0x3c
c0029943:	68 f8 f1 02 c0       	push   $0xc002f1f8
c0029948:	e8 80 e3 ff ff       	call   c0027ccd <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002994d:	83 ec 04             	sub    $0x4,%esp
c0029950:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0029954:	57                   	push   %edi
c0029955:	8b 74 24 08          	mov    0x8(%esp),%esi
c0029959:	56                   	push   %esi
c002995a:	68 1c f2 02 c0       	push   $0xc002f21c
c002995f:	e8 32 fe ff ff       	call   c0029796 <msg>
  msg ("Thread 0 sleeps 10 ticks each time,");
c0029964:	c7 04 24 48 f2 02 c0 	movl   $0xc002f248,(%esp)
c002996b:	e8 26 fe ff ff       	call   c0029796 <msg>
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c0029970:	c7 04 24 6c f2 02 c0 	movl   $0xc002f26c,(%esp)
c0029977:	e8 1a fe ff ff       	call   c0029796 <msg>
  msg ("If successful, product of iteration count and");
c002997c:	c7 04 24 9c f2 02 c0 	movl   $0xc002f29c,(%esp)
c0029983:	e8 0e fe ff ff       	call   c0029796 <msg>
  msg ("sleep duration will appear in nondescending order.");
c0029988:	c7 04 24 cc f2 02 c0 	movl   $0xc002f2cc,(%esp)
c002998f:	e8 02 fe ff ff       	call   c0029796 <msg>

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c0029994:	89 f0                	mov    %esi,%eax
c0029996:	c1 e0 04             	shl    $0x4,%eax
c0029999:	89 04 24             	mov    %eax,(%esp)
c002999c:	e8 ce 9a ff ff       	call   c002346f <malloc>
c00299a1:	89 c3                	mov    %eax,%ebx
c00299a3:	89 44 24 14          	mov    %eax,0x14(%esp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c00299a7:	8d 04 fd 00 00 00 00 	lea    0x0(,%edi,8),%eax
c00299ae:	0f af c6             	imul   %esi,%eax
c00299b1:	89 04 24             	mov    %eax,(%esp)
c00299b4:	e8 b6 9a ff ff       	call   c002346f <malloc>
c00299b9:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (threads == NULL || output == NULL)
c00299bd:	83 c4 10             	add    $0x10,%esp
c00299c0:	85 db                	test   %ebx,%ebx
c00299c2:	74 04                	je     c00299c8 <test_sleep+0xb0>
c00299c4:	85 c0                	test   %eax,%eax
c00299c6:	75 16                	jne    c00299de <test_sleep+0xc6>
    PANIC ("couldn't allocate memory for test");
c00299c8:	68 00 f3 02 c0       	push   $0xc002f300
c00299cd:	68 f8 cf 02 c0       	push   $0xc002cff8
c00299d2:	6a 48                	push   $0x48
c00299d4:	68 f8 f1 02 c0       	push   $0xc002f1f8
c00299d9:	e8 ef e2 ff ff       	call   c0027ccd <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c00299de:	e8 5a a0 ff ff       	call   c0023a3d <timer_ticks>
c00299e3:	83 c0 64             	add    $0x64,%eax
c00299e6:	83 d2 00             	adc    $0x0,%edx
c00299e9:	89 44 24 20          	mov    %eax,0x20(%esp)
c00299ed:	89 54 24 24          	mov    %edx,0x24(%esp)
  test.iterations = iterations;
c00299f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00299f5:	89 44 24 28          	mov    %eax,0x28(%esp)
  lock_init (&test.output_lock);
c00299f9:	83 ec 0c             	sub    $0xc,%esp
c00299fc:	8d 44 24 38          	lea    0x38(%esp),%eax
c0029a00:	50                   	push   %eax
c0029a01:	e8 37 8f ff ff       	call   c002293d <lock_init>
  test.output_pos = output;
c0029a06:	8b 44 24 18          	mov    0x18(%esp),%eax
c0029a0a:	89 44 24 5c          	mov    %eax,0x5c(%esp)

  /* Start threads. */
  ASSERT (output != NULL);
c0029a0e:	83 c4 10             	add    $0x10,%esp
c0029a11:	85 c0                	test   %eax,%eax
c0029a13:	74 1d                	je     c0029a32 <test_sleep+0x11a>
c0029a15:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  for (i = 0; i < thread_cnt; i++)
c0029a19:	bd 0a 00 00 00       	mov    $0xa,%ebp
c0029a1e:	b8 00 00 00 00       	mov    $0x0,%eax
      t->test = &test;
      t->id = i;
      t->duration = (i + 1) * 10;
      t->iterations = 0;

      snprintf (name, sizeof name, "thread %d", i);
c0029a23:	8d 7c 24 10          	lea    0x10(%esp),%edi
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c0029a27:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0029a2b:	7f 23                	jg     c0029a50 <test_sleep+0x138>
c0029a2d:	e9 60 01 00 00       	jmp    c0029b92 <test_sleep+0x27a>
  test.iterations = iterations;
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
c0029a32:	83 ec 0c             	sub    $0xc,%esp
c0029a35:	68 c2 f1 02 c0       	push   $0xc002f1c2
c0029a3a:	68 3f d2 02 c0       	push   $0xc002d23f
c0029a3f:	68 f8 cf 02 c0       	push   $0xc002cff8
c0029a44:	6a 51                	push   $0x51
c0029a46:	68 f8 f1 02 c0       	push   $0xc002f1f8
c0029a4b:	e8 7d e2 ff ff       	call   c0027ccd <debug_panic>
  for (i = 0; i < thread_cnt; i++)
    {
      struct sleep_thread *t = threads + i;
      char name[16];
      
      t->test = &test;
c0029a50:	8d 4c 24 20          	lea    0x20(%esp),%ecx
c0029a54:	89 0b                	mov    %ecx,(%ebx)
      t->id = i;
c0029a56:	89 43 04             	mov    %eax,0x4(%ebx)
      t->duration = (i + 1) * 10;
c0029a59:	8d 70 01             	lea    0x1(%eax),%esi
c0029a5c:	89 6b 08             	mov    %ebp,0x8(%ebx)
      t->iterations = 0;
c0029a5f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

      snprintf (name, sizeof name, "thread %d", i);
c0029a66:	50                   	push   %eax
c0029a67:	68 d1 f1 02 c0       	push   $0xc002f1d1
c0029a6c:	6a 10                	push   $0x10
c0029a6e:	57                   	push   %edi
c0029a6f:	e8 ee cc ff ff       	call   c0026762 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, t);
c0029a74:	53                   	push   %ebx
c0029a75:	68 99 98 02 c0       	push   $0xc0029899
c0029a7a:	6a 1f                	push   $0x1f
c0029a7c:	57                   	push   %edi
c0029a7d:	e8 3f 77 ff ff       	call   c00211c1 <thread_create>
c0029a82:	83 c3 10             	add    $0x10,%ebx
c0029a85:	83 c5 0a             	add    $0xa,%ebp
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c0029a88:	89 f0                	mov    %esi,%eax
c0029a8a:	83 c4 20             	add    $0x20,%esp
c0029a8d:	39 34 24             	cmp    %esi,(%esp)
c0029a90:	75 be                	jne    c0029a50 <test_sleep+0x138>
c0029a92:	e9 39 01 00 00       	jmp    c0029bd0 <test_sleep+0x2b8>
  for (op = output; op < test.output_pos; op++) 
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c0029a97:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029a9b:	8b 18                	mov    (%eax),%ebx
c0029a9d:	39 1c 24             	cmp    %ebx,(%esp)
c0029aa0:	7e 11                	jle    c0029ab3 <test_sleep+0x19b>
c0029aa2:	85 db                	test   %ebx,%ebx
c0029aa4:	79 2b                	jns    c0029ad1 <test_sleep+0x1b9>
c0029aa6:	eb 0b                	jmp    c0029ab3 <test_sleep+0x19b>
c0029aa8:	8b 1e                	mov    (%esi),%ebx
c0029aaa:	39 1c 24             	cmp    %ebx,(%esp)
c0029aad:	7e 04                	jle    c0029ab3 <test_sleep+0x19b>
c0029aaf:	85 db                	test   %ebx,%ebx
c0029ab1:	79 27                	jns    c0029ada <test_sleep+0x1c2>
c0029ab3:	83 ec 0c             	sub    $0xc,%esp
c0029ab6:	68 db f1 02 c0       	push   $0xc002f1db
c0029abb:	68 3f d2 02 c0       	push   $0xc002d23f
c0029ac0:	68 f8 cf 02 c0       	push   $0xc002cff8
c0029ac5:	6a 6e                	push   $0x6e
c0029ac7:	68 f8 f1 02 c0       	push   $0xc002f1f8
c0029acc:	e8 fc e1 ff ff       	call   c0027ccd <debug_panic>
c0029ad1:	8b 74 24 08          	mov    0x8(%esp),%esi
c0029ad5:	bd 00 00 00 00       	mov    $0x0,%ebp
      t = threads + *op;
c0029ada:	c1 e3 04             	shl    $0x4,%ebx
c0029add:	03 5c 24 04          	add    0x4(%esp),%ebx

      new_prod = ++t->iterations * t->duration;
c0029ae1:	8b 43 0c             	mov    0xc(%ebx),%eax
c0029ae4:	83 c0 01             	add    $0x1,%eax
c0029ae7:	89 43 0c             	mov    %eax,0xc(%ebx)
c0029aea:	8b 53 08             	mov    0x8(%ebx),%edx
c0029aed:	89 c7                	mov    %eax,%edi
c0029aef:	0f af fa             	imul   %edx,%edi
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c0029af2:	83 ec 0c             	sub    $0xc,%esp
c0029af5:	57                   	push   %edi
c0029af6:	50                   	push   %eax
c0029af7:	52                   	push   %edx
c0029af8:	ff 73 04             	pushl  0x4(%ebx)
c0029afb:	68 24 f3 02 c0       	push   $0xc002f324
c0029b00:	e8 91 fc ff ff       	call   c0029796 <msg>
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c0029b05:	83 c4 20             	add    $0x20,%esp
c0029b08:	39 ef                	cmp    %ebp,%edi
c0029b0a:	7d 14                	jge    c0029b20 <test_sleep+0x208>
        product = new_prod;
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c0029b0c:	57                   	push   %edi
c0029b0d:	55                   	push   %ebp
c0029b0e:	ff 73 04             	pushl  0x4(%ebx)
c0029b11:	68 58 f3 02 c0       	push   $0xc002f358
c0029b16:	e8 21 fd ff ff       	call   c002983c <fail>
c0029b1b:	83 c4 10             	add    $0x10,%esp
c0029b1e:	eb 02                	jmp    c0029b22 <test_sleep+0x20a>
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
        product = new_prod;
c0029b20:	89 fd                	mov    %edi,%ebp
     running. */
  lock_acquire (&test.output_lock);

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c0029b22:	83 c6 04             	add    $0x4,%esi
c0029b25:	39 74 24 4c          	cmp    %esi,0x4c(%esp)
c0029b29:	0f 87 79 ff ff ff    	ja     c0029aa8 <test_sleep+0x190>
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c0029b2f:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0029b33:	7e 33                	jle    c0029b68 <test_sleep+0x250>
c0029b35:	8b 44 24 04          	mov    0x4(%esp),%eax
c0029b39:	8d 70 0c             	lea    0xc(%eax),%esi
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
        product = new_prod;
c0029b3c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0029b41:	8b 2c 24             	mov    (%esp),%ebp
c0029b44:	8b 7c 24 0c          	mov    0xc(%esp),%edi
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
    if (threads[i].iterations != iterations)
c0029b48:	8b 06                	mov    (%esi),%eax
c0029b4a:	39 c7                	cmp    %eax,%edi
c0029b4c:	74 10                	je     c0029b5e <test_sleep+0x246>
      fail ("thread %d woke up %d times instead of %d",
c0029b4e:	57                   	push   %edi
c0029b4f:	50                   	push   %eax
c0029b50:	53                   	push   %ebx
c0029b51:	68 84 f3 02 c0       	push   $0xc002f384
c0029b56:	e8 e1 fc ff ff       	call   c002983c <fail>
c0029b5b:	83 c4 10             	add    $0x10,%esp
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c0029b5e:	83 c3 01             	add    $0x1,%ebx
c0029b61:	83 c6 10             	add    $0x10,%esi
c0029b64:	39 dd                	cmp    %ebx,%ebp
c0029b66:	7f e0                	jg     c0029b48 <test_sleep+0x230>
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
  
  lock_release (&test.output_lock);
c0029b68:	83 ec 0c             	sub    $0xc,%esp
c0029b6b:	8d 44 24 38          	lea    0x38(%esp),%eax
c0029b6f:	50                   	push   %eax
c0029b70:	e8 da 8f ff ff       	call   c0022b4f <lock_release>
  free (output);
c0029b75:	83 c4 04             	add    $0x4,%esp
c0029b78:	ff 74 24 14          	pushl  0x14(%esp)
c0029b7c:	e8 7f 9a ff ff       	call   c0023600 <free>
  free (threads);
c0029b81:	83 c4 04             	add    $0x4,%esp
c0029b84:	ff 74 24 10          	pushl  0x10(%esp)
c0029b88:	e8 73 9a ff ff       	call   c0023600 <free>
}
c0029b8d:	83 c4 10             	add    $0x10,%esp
c0029b90:	eb 7f                	jmp    c0029c11 <test_sleep+0x2f9>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, t);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c0029b92:	83 ec 08             	sub    $0x8,%esp
c0029b95:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029b99:	0f af 44 24 14       	imul   0x14(%esp),%eax
c0029b9e:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0029ba1:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c0029ba8:	99                   	cltd   
c0029ba9:	52                   	push   %edx
c0029baa:	50                   	push   %eax
c0029bab:	e8 d2 9e ff ff       	call   c0023a82 <timer_sleep>

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c0029bb0:	83 c4 04             	add    $0x4,%esp
c0029bb3:	8d 44 24 38          	lea    0x38(%esp),%eax
c0029bb7:	50                   	push   %eax
c0029bb8:	e8 02 8e ff ff       	call   c00229bf <lock_acquire>

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c0029bbd:	83 c4 10             	add    $0x10,%esp
c0029bc0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029bc4:	3b 44 24 4c          	cmp    0x4c(%esp),%eax
c0029bc8:	0f 82 c9 fe ff ff    	jb     c0029a97 <test_sleep+0x17f>
c0029bce:	eb 98                	jmp    c0029b68 <test_sleep+0x250>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, t);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c0029bd0:	83 ec 08             	sub    $0x8,%esp
c0029bd3:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029bd7:	0f af 44 24 14       	imul   0x14(%esp),%eax
c0029bdc:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0029bdf:	8d 84 00 c8 00 00 00 	lea    0xc8(%eax,%eax,1),%eax
c0029be6:	99                   	cltd   
c0029be7:	52                   	push   %edx
c0029be8:	50                   	push   %eax
c0029be9:	e8 94 9e ff ff       	call   c0023a82 <timer_sleep>

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c0029bee:	83 c4 04             	add    $0x4,%esp
c0029bf1:	8d 44 24 38          	lea    0x38(%esp),%eax
c0029bf5:	50                   	push   %eax
c0029bf6:	e8 c4 8d ff ff       	call   c00229bf <lock_acquire>

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c0029bfb:	83 c4 10             	add    $0x10,%esp
c0029bfe:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029c02:	3b 44 24 4c          	cmp    0x4c(%esp),%eax
c0029c06:	0f 82 8b fe ff ff    	jb     c0029a97 <test_sleep+0x17f>
c0029c0c:	e9 24 ff ff ff       	jmp    c0029b35 <test_sleep+0x21d>
            i, threads[i].iterations, iterations);
  
  lock_release (&test.output_lock);
  free (output);
  free (threads);
}
c0029c11:	83 c4 5c             	add    $0x5c,%esp
c0029c14:	5b                   	pop    %ebx
c0029c15:	5e                   	pop    %esi
c0029c16:	5f                   	pop    %edi
c0029c17:	5d                   	pop    %ebp
c0029c18:	c3                   	ret    

c0029c19 <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c0029c19:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 1);
c0029c1c:	ba 01 00 00 00       	mov    $0x1,%edx
c0029c21:	b8 05 00 00 00       	mov    $0x5,%eax
c0029c26:	e8 ed fc ff ff       	call   c0029918 <test_sleep>
}
c0029c2b:	83 c4 0c             	add    $0xc,%esp
c0029c2e:	c3                   	ret    

c0029c2f <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c0029c2f:	83 ec 0c             	sub    $0xc,%esp
  test_sleep (5, 7);
c0029c32:	ba 07 00 00 00       	mov    $0x7,%edx
c0029c37:	b8 05 00 00 00       	mov    $0x5,%eax
c0029c3c:	e8 d7 fc ff ff       	call   c0029918 <test_sleep>
}
c0029c41:	83 c4 0c             	add    $0xc,%esp
c0029c44:	c3                   	ret    

c0029c45 <sleeper>:
}

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c0029c45:	55                   	push   %ebp
c0029c46:	57                   	push   %edi
c0029c47:	56                   	push   %esi
c0029c48:	53                   	push   %ebx
c0029c49:	83 ec 24             	sub    $0x24,%esp
c0029c4c:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  struct sleep_test *test = test_;
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c0029c50:	6a 00                	push   $0x0
c0029c52:	6a 01                	push   $0x1
c0029c54:	e8 29 9e ff ff       	call   c0023a82 <timer_sleep>

  for (i = 1; i <= test->iterations; i++) 
c0029c59:	83 c4 10             	add    $0x10,%esp
c0029c5c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
c0029c60:	7e 56                	jle    c0029cb8 <sleeper+0x73>
c0029c62:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
c0029c69:	00 
c0029c6a:	be 01 00 00 00       	mov    $0x1,%esi
    {
      int64_t sleep_until = test->start + i * 10;
c0029c6f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0029c73:	99                   	cltd   
c0029c74:	03 03                	add    (%ebx),%eax
c0029c76:	13 53 04             	adc    0x4(%ebx),%edx
c0029c79:	89 c7                	mov    %eax,%edi
c0029c7b:	89 d5                	mov    %edx,%ebp
      timer_sleep (sleep_until - timer_ticks ());
c0029c7d:	e8 bb 9d ff ff       	call   c0023a3d <timer_ticks>
c0029c82:	83 ec 08             	sub    $0x8,%esp
c0029c85:	29 c7                	sub    %eax,%edi
c0029c87:	19 d5                	sbb    %edx,%ebp
c0029c89:	55                   	push   %ebp
c0029c8a:	57                   	push   %edi
c0029c8b:	e8 f2 9d ff ff       	call   c0023a82 <timer_sleep>
      *test->output_pos++ = timer_ticks () - test->start;
c0029c90:	8b 6b 0c             	mov    0xc(%ebx),%ebp
c0029c93:	8d 45 04             	lea    0x4(%ebp),%eax
c0029c96:	89 43 0c             	mov    %eax,0xc(%ebx)
c0029c99:	e8 9f 9d ff ff       	call   c0023a3d <timer_ticks>
c0029c9e:	2b 03                	sub    (%ebx),%eax
c0029ca0:	89 45 00             	mov    %eax,0x0(%ebp)
      thread_yield ();
c0029ca3:	e8 a1 74 ff ff       	call   c0021149 <thread_yield>
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);

  for (i = 1; i <= test->iterations; i++) 
c0029ca8:	83 c6 01             	add    $0x1,%esi
c0029cab:	83 44 24 1c 0a       	addl   $0xa,0x1c(%esp)
c0029cb0:	83 c4 10             	add    $0x10,%esp
c0029cb3:	39 73 08             	cmp    %esi,0x8(%ebx)
c0029cb6:	7d b7                	jge    c0029c6f <sleeper+0x2a>
      int64_t sleep_until = test->start + i * 10;
      timer_sleep (sleep_until - timer_ticks ());
      *test->output_pos++ = timer_ticks () - test->start;
      thread_yield ();
    }
}
c0029cb8:	83 c4 1c             	add    $0x1c,%esp
c0029cbb:	5b                   	pop    %ebx
c0029cbc:	5e                   	pop    %esi
c0029cbd:	5f                   	pop    %edi
c0029cbe:	5d                   	pop    %ebp
c0029cbf:	c3                   	ret    

c0029cc0 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c0029cc0:	55                   	push   %ebp
c0029cc1:	57                   	push   %edi
c0029cc2:	56                   	push   %esi
c0029cc3:	53                   	push   %ebx
c0029cc4:	83 ec 2c             	sub    $0x2c,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0029cc7:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0029cce:	74 1e                	je     c0029cee <test_alarm_simultaneous+0x2e>
c0029cd0:	83 ec 0c             	sub    $0xc,%esp
c0029cd3:	68 b4 f1 02 c0       	push   $0xc002f1b4
c0029cd8:	68 3f d2 02 c0       	push   $0xc002d23f
c0029cdd:	68 04 d0 02 c0       	push   $0xc002d004
c0029ce2:	6a 28                	push   $0x28
c0029ce4:	68 b0 f3 02 c0       	push   $0xc002f3b0
c0029ce9:	e8 df df ff ff       	call   c0027ccd <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c0029cee:	83 ec 04             	sub    $0x4,%esp
c0029cf1:	6a 05                	push   $0x5
c0029cf3:	6a 03                	push   $0x3
c0029cf5:	68 1c f2 02 c0       	push   $0xc002f21c
c0029cfa:	e8 97 fa ff ff       	call   c0029796 <msg>
  msg ("Each thread sleeps 10 ticks each time.");
c0029cff:	c7 04 24 dc f3 02 c0 	movl   $0xc002f3dc,(%esp)
c0029d06:	e8 8b fa ff ff       	call   c0029796 <msg>
  msg ("Within an iteration, all threads should wake up on the same tick.");
c0029d0b:	c7 04 24 04 f4 02 c0 	movl   $0xc002f404,(%esp)
c0029d12:	e8 7f fa ff ff       	call   c0029796 <msg>

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c0029d17:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
c0029d1e:	e8 4c 97 ff ff       	call   c002346f <malloc>
c0029d23:	89 c6                	mov    %eax,%esi
  if (output == NULL)
c0029d25:	83 c4 10             	add    $0x10,%esp
c0029d28:	85 c0                	test   %eax,%eax
c0029d2a:	75 16                	jne    c0029d42 <test_alarm_simultaneous+0x82>
    PANIC ("couldn't allocate memory for test");
c0029d2c:	68 00 f3 02 c0       	push   $0xc002f300
c0029d31:	68 04 d0 02 c0       	push   $0xc002d004
c0029d36:	6a 31                	push   $0x31
c0029d38:	68 b0 f3 02 c0       	push   $0xc002f3b0
c0029d3d:	e8 8b df ff ff       	call   c0027ccd <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c0029d42:	e8 f6 9c ff ff       	call   c0023a3d <timer_ticks>
c0029d47:	83 c0 64             	add    $0x64,%eax
c0029d4a:	83 d2 00             	adc    $0x0,%edx
c0029d4d:	89 04 24             	mov    %eax,(%esp)
c0029d50:	89 54 24 04          	mov    %edx,0x4(%esp)
  test.iterations = iterations;
c0029d54:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
c0029d5b:	00 
  test.output_pos = output;
c0029d5c:	89 74 24 0c          	mov    %esi,0xc(%esp)
c0029d60:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c0029d65:	8d 7c 24 10          	lea    0x10(%esp),%edi
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c0029d69:	89 e5                	mov    %esp,%ebp
  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c0029d6b:	53                   	push   %ebx
c0029d6c:	68 d1 f1 02 c0       	push   $0xc002f1d1
c0029d71:	6a 10                	push   $0x10
c0029d73:	57                   	push   %edi
c0029d74:	e8 e9 c9 ff ff       	call   c0026762 <snprintf>
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c0029d79:	55                   	push   %ebp
c0029d7a:	68 45 9c 02 c0       	push   $0xc0029c45
c0029d7f:	6a 1f                	push   $0x1f
c0029d81:	57                   	push   %edi
c0029d82:	e8 3a 74 ff ff       	call   c00211c1 <thread_create>
  test.iterations = iterations;
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c0029d87:	83 c3 01             	add    $0x1,%ebx
c0029d8a:	83 c4 20             	add    $0x20,%esp
c0029d8d:	83 fb 03             	cmp    $0x3,%ebx
c0029d90:	75 d9                	jne    c0029d6b <test_alarm_simultaneous+0xab>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, &test);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c0029d92:	83 ec 08             	sub    $0x8,%esp
c0029d95:	6a 00                	push   $0x0
c0029d97:	68 fa 00 00 00       	push   $0xfa
c0029d9c:	e8 e1 9c ff ff       	call   c0023a82 <timer_sleep>

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c0029da1:	83 c4 08             	add    $0x8,%esp
c0029da4:	ff 36                	pushl  (%esi)
c0029da6:	68 48 f4 02 c0       	push   $0xc002f448
c0029dab:	e8 e6 f9 ff ff       	call   c0029796 <msg>
  for (i = 1; i < test.output_pos - output; i++) 
c0029db0:	89 f7                	mov    %esi,%edi
c0029db2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029db6:	29 f0                	sub    %esi,%eax
c0029db8:	83 c4 10             	add    $0x10,%esp
c0029dbb:	83 f8 07             	cmp    $0x7,%eax
c0029dbe:	7e 43                	jle    c0029e03 <test_alarm_simultaneous+0x143>
c0029dc0:	bb 01 00 00 00       	mov    $0x1,%ebx
    msg ("iteration %d, thread %d: woke up %d ticks later",
c0029dc5:	bd 56 55 55 55       	mov    $0x55555556,%ebp
c0029dca:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
c0029dcd:	2b 44 9e fc          	sub    -0x4(%esi,%ebx,4),%eax
c0029dd1:	50                   	push   %eax
c0029dd2:	89 d8                	mov    %ebx,%eax
c0029dd4:	f7 ed                	imul   %ebp
c0029dd6:	89 d8                	mov    %ebx,%eax
c0029dd8:	c1 f8 1f             	sar    $0x1f,%eax
c0029ddb:	29 c2                	sub    %eax,%edx
c0029ddd:	8d 04 52             	lea    (%edx,%edx,2),%eax
c0029de0:	89 d9                	mov    %ebx,%ecx
c0029de2:	29 c1                	sub    %eax,%ecx
c0029de4:	51                   	push   %ecx
c0029de5:	52                   	push   %edx
c0029de6:	68 78 f4 02 c0       	push   $0xc002f478
c0029deb:	e8 a6 f9 ff ff       	call   c0029796 <msg>
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
c0029df0:	83 c3 01             	add    $0x1,%ebx
c0029df3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029df7:	29 f8                	sub    %edi,%eax
c0029df9:	c1 f8 02             	sar    $0x2,%eax
c0029dfc:	83 c4 10             	add    $0x10,%esp
c0029dff:	39 c3                	cmp    %eax,%ebx
c0029e01:	7c c7                	jl     c0029dca <test_alarm_simultaneous+0x10a>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
  
  free (output);
c0029e03:	83 ec 0c             	sub    $0xc,%esp
c0029e06:	56                   	push   %esi
c0029e07:	e8 f4 97 ff ff       	call   c0023600 <free>

void
test_alarm_simultaneous (void) 
{
  test_sleep (3, 5);
}
c0029e0c:	83 c4 3c             	add    $0x3c,%esp
c0029e0f:	5b                   	pop    %ebx
c0029e10:	5e                   	pop    %esi
c0029e11:	5f                   	pop    %edi
c0029e12:	5d                   	pop    %ebp
c0029e13:	c3                   	ret    

c0029e14 <alarm_priority_thread>:
    sema_down (&wait_sema);
}

static void
alarm_priority_thread (void *aux UNUSED) 
{
c0029e14:	57                   	push   %edi
c0029e15:	56                   	push   %esi
c0029e16:	83 ec 04             	sub    $0x4,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c0029e19:	e8 1f 9c ff ff       	call   c0023a3d <timer_ticks>
c0029e1e:	89 c6                	mov    %eax,%esi
c0029e20:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) == 0)
c0029e22:	83 ec 08             	sub    $0x8,%esp
c0029e25:	57                   	push   %edi
c0029e26:	56                   	push   %esi
c0029e27:	e8 3a 9c ff ff       	call   c0023a66 <timer_elapsed>
c0029e2c:	83 c4 10             	add    $0x10,%esp
c0029e2f:	09 c2                	or     %eax,%edx
c0029e31:	74 ef                	je     c0029e22 <alarm_priority_thread+0xe>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c0029e33:	8b 35 60 96 03 c0    	mov    0xc0039660,%esi
c0029e39:	8b 3d 64 96 03 c0    	mov    0xc0039664,%edi
c0029e3f:	e8 f9 9b ff ff       	call   c0023a3d <timer_ticks>
c0029e44:	83 ec 08             	sub    $0x8,%esp
c0029e47:	29 c6                	sub    %eax,%esi
c0029e49:	19 d7                	sbb    %edx,%edi
c0029e4b:	57                   	push   %edi
c0029e4c:	56                   	push   %esi
c0029e4d:	e8 30 9c ff ff       	call   c0023a82 <timer_sleep>

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c0029e52:	e8 a4 6e ff ff       	call   c0020cfb <thread_name>
c0029e57:	83 c4 08             	add    $0x8,%esp
c0029e5a:	50                   	push   %eax
c0029e5b:	68 a8 f4 02 c0       	push   $0xc002f4a8
c0029e60:	e8 31 f9 ff ff       	call   c0029796 <msg>

  sema_up (&wait_sema);
c0029e65:	c7 04 24 48 96 03 c0 	movl   $0xc0039648,(%esp)
c0029e6c:	e8 a0 89 ff ff       	call   c0022811 <sema_up>
}
c0029e71:	83 c4 14             	add    $0x14,%esp
c0029e74:	5e                   	pop    %esi
c0029e75:	5f                   	pop    %edi
c0029e76:	c3                   	ret    

c0029e77 <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c0029e77:	55                   	push   %ebp
c0029e78:	57                   	push   %edi
c0029e79:	56                   	push   %esi
c0029e7a:	53                   	push   %ebx
c0029e7b:	83 ec 1c             	sub    $0x1c,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0029e7e:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0029e85:	74 1e                	je     c0029ea5 <test_alarm_priority+0x2e>
c0029e87:	83 ec 0c             	sub    $0xc,%esp
c0029e8a:	68 b4 f1 02 c0       	push   $0xc002f1b4
c0029e8f:	68 3f d2 02 c0       	push   $0xc002d23f
c0029e94:	68 10 d0 02 c0       	push   $0xc002d010
c0029e99:	6a 16                	push   $0x16
c0029e9b:	68 c8 f4 02 c0       	push   $0xc002f4c8
c0029ea0:	e8 28 de ff ff       	call   c0027ccd <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c0029ea5:	e8 93 9b ff ff       	call   c0023a3d <timer_ticks>
c0029eaa:	05 f4 01 00 00       	add    $0x1f4,%eax
c0029eaf:	83 d2 00             	adc    $0x0,%edx
c0029eb2:	a3 60 96 03 c0       	mov    %eax,0xc0039660
c0029eb7:	89 15 64 96 03 c0    	mov    %edx,0xc0039664
  sema_init (&wait_sema, 0);
c0029ebd:	83 ec 08             	sub    $0x8,%esp
c0029ec0:	6a 00                	push   $0x0
c0029ec2:	68 48 96 03 c0       	push   $0xc0039648
c0029ec7:	e8 1b 88 ff ff       	call   c00226e7 <sema_init>
c0029ecc:	83 c4 10             	add    $0x10,%esp
c0029ecf:	bb 05 00 00 00       	mov    $0x5,%ebx
  
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c0029ed4:	bf 67 66 66 66       	mov    $0x66666667,%edi
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c0029ed9:	89 e6                	mov    %esp,%esi
  wake_time = timer_ticks () + 5 * TIMER_FREQ;
  sema_init (&wait_sema, 0);
  
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c0029edb:	89 d8                	mov    %ebx,%eax
c0029edd:	f7 ef                	imul   %edi
c0029edf:	c1 fa 02             	sar    $0x2,%edx
c0029ee2:	89 d8                	mov    %ebx,%eax
c0029ee4:	c1 f8 1f             	sar    $0x1f,%eax
c0029ee7:	29 c2                	sub    %eax,%edx
c0029ee9:	8d 04 92             	lea    (%edx,%edx,4),%eax
c0029eec:	01 c0                	add    %eax,%eax
c0029eee:	29 d8                	sub    %ebx,%eax
c0029ef0:	8d 68 1e             	lea    0x1e(%eax),%ebp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c0029ef3:	55                   	push   %ebp
c0029ef4:	68 bb f4 02 c0       	push   $0xc002f4bb
c0029ef9:	6a 10                	push   $0x10
c0029efb:	56                   	push   %esi
c0029efc:	e8 61 c8 ff ff       	call   c0026762 <snprintf>
      thread_create (name, priority, alarm_priority_thread, NULL);
c0029f01:	6a 00                	push   $0x0
c0029f03:	68 14 9e 02 c0       	push   $0xc0029e14
c0029f08:	55                   	push   %ebp
c0029f09:	56                   	push   %esi
c0029f0a:	e8 b2 72 ff ff       	call   c00211c1 <thread_create>
c0029f0f:	83 c3 01             	add    $0x1,%ebx
  ASSERT (!thread_mlfqs);

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
  sema_init (&wait_sema, 0);
  
  for (i = 0; i < 10; i++) 
c0029f12:	83 c4 20             	add    $0x20,%esp
c0029f15:	83 fb 0f             	cmp    $0xf,%ebx
c0029f18:	75 c1                	jne    c0029edb <test_alarm_priority+0x64>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);
c0029f1a:	83 ec 0c             	sub    $0xc,%esp
c0029f1d:	6a 00                	push   $0x0
c0029f1f:	e8 d1 73 ff ff       	call   c00212f5 <thread_set_priority>
c0029f24:	83 c4 10             	add    $0x10,%esp
c0029f27:	bb 0a 00 00 00       	mov    $0xa,%ebx

  for (i = 0; i < 10; i++)
    sema_down (&wait_sema);
c0029f2c:	83 ec 0c             	sub    $0xc,%esp
c0029f2f:	68 48 96 03 c0       	push   $0xc0039648
c0029f34:	e8 ed 87 ff ff       	call   c0022726 <sema_down>
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);

  for (i = 0; i < 10; i++)
c0029f39:	83 c4 10             	add    $0x10,%esp
c0029f3c:	83 eb 01             	sub    $0x1,%ebx
c0029f3f:	75 eb                	jne    c0029f2c <test_alarm_priority+0xb5>
    sema_down (&wait_sema);
}
c0029f41:	83 c4 1c             	add    $0x1c,%esp
c0029f44:	5b                   	pop    %ebx
c0029f45:	5e                   	pop    %esi
c0029f46:	5f                   	pop    %edi
c0029f47:	5d                   	pop    %ebp
c0029f48:	c3                   	ret    

c0029f49 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c0029f49:	83 ec 14             	sub    $0x14,%esp
  timer_sleep (0);
c0029f4c:	6a 00                	push   $0x0
c0029f4e:	6a 00                	push   $0x0
c0029f50:	e8 2d 9b ff ff       	call   c0023a82 <timer_sleep>
  pass ();
c0029f55:	e8 28 f9 ff ff       	call   c0029882 <pass>
}
c0029f5a:	83 c4 1c             	add    $0x1c,%esp
c0029f5d:	c3                   	ret    

c0029f5e <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c0029f5e:	83 ec 14             	sub    $0x14,%esp
  timer_sleep (-100);
c0029f61:	6a ff                	push   $0xffffffff
c0029f63:	6a 9c                	push   $0xffffff9c
c0029f65:	e8 18 9b ff ff       	call   c0023a82 <timer_sleep>
  pass ();
c0029f6a:	e8 13 f9 ff ff       	call   c0029882 <pass>
}
c0029f6f:	83 c4 1c             	add    $0x1c,%esp
c0029f72:	c3                   	ret    

c0029f73 <changing_thread>:
  msg ("Thread 2 should have just exited.");
}

static void
changing_thread (void *aux UNUSED) 
{
c0029f73:	83 ec 18             	sub    $0x18,%esp
  msg ("Thread 2 now lowering priority.");
c0029f76:	68 f0 f4 02 c0       	push   $0xc002f4f0
c0029f7b:	e8 16 f8 ff ff       	call   c0029796 <msg>
  thread_set_priority (PRI_DEFAULT - 1);
c0029f80:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c0029f87:	e8 69 73 ff ff       	call   c00212f5 <thread_set_priority>
  msg ("Thread 2 exiting.");
c0029f8c:	c7 04 24 ae f5 02 c0 	movl   $0xc002f5ae,(%esp)
c0029f93:	e8 fe f7 ff ff       	call   c0029796 <msg>
}
c0029f98:	83 c4 1c             	add    $0x1c,%esp
c0029f9b:	c3                   	ret    

c0029f9c <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c0029f9c:	83 ec 0c             	sub    $0xc,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c0029f9f:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c0029fa6:	74 1e                	je     c0029fc6 <test_priority_change+0x2a>
c0029fa8:	83 ec 0c             	sub    $0xc,%esp
c0029fab:	68 b4 f1 02 c0       	push   $0xc002f1b4
c0029fb0:	68 3f d2 02 c0       	push   $0xc002d23f
c0029fb5:	68 24 d0 02 c0       	push   $0xc002d024
c0029fba:	6a 10                	push   $0x10
c0029fbc:	68 10 f5 02 c0       	push   $0xc002f510
c0029fc1:	e8 07 dd ff ff       	call   c0027ccd <debug_panic>

  msg ("Creating a high-priority thread 2.");
c0029fc6:	83 ec 0c             	sub    $0xc,%esp
c0029fc9:	68 38 f5 02 c0       	push   $0xc002f538
c0029fce:	e8 c3 f7 ff ff       	call   c0029796 <msg>
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c0029fd3:	6a 00                	push   $0x0
c0029fd5:	68 73 9f 02 c0       	push   $0xc0029f73
c0029fda:	6a 20                	push   $0x20
c0029fdc:	68 c0 f5 02 c0       	push   $0xc002f5c0
c0029fe1:	e8 db 71 ff ff       	call   c00211c1 <thread_create>
  msg ("Thread 2 should have just lowered its priority.");
c0029fe6:	83 c4 14             	add    $0x14,%esp
c0029fe9:	68 5c f5 02 c0       	push   $0xc002f55c
c0029fee:	e8 a3 f7 ff ff       	call   c0029796 <msg>
  thread_set_priority (PRI_DEFAULT - 2);
c0029ff3:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c0029ffa:	e8 f6 72 ff ff       	call   c00212f5 <thread_set_priority>
  msg ("Thread 2 should have just exited.");
c0029fff:	c7 04 24 8c f5 02 c0 	movl   $0xc002f58c,(%esp)
c002a006:	e8 8b f7 ff ff       	call   c0029796 <msg>
}
c002a00b:	83 c4 1c             	add    $0x1c,%esp
c002a00e:	c3                   	ret    

c002a00f <acquire2_thread_func>:
  msg ("acquire1: done");
}

static void
acquire2_thread_func (void *lock_) 
{
c002a00f:	53                   	push   %ebx
c002a010:	83 ec 14             	sub    $0x14,%esp
c002a013:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a017:	53                   	push   %ebx
c002a018:	e8 a2 89 ff ff       	call   c00229bf <lock_acquire>
  msg ("acquire2: got the lock");
c002a01d:	c7 04 24 c9 f5 02 c0 	movl   $0xc002f5c9,(%esp)
c002a024:	e8 6d f7 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a029:	89 1c 24             	mov    %ebx,(%esp)
c002a02c:	e8 1e 8b ff ff       	call   c0022b4f <lock_release>
  msg ("acquire2: done");
c002a031:	c7 04 24 e0 f5 02 c0 	movl   $0xc002f5e0,(%esp)
c002a038:	e8 59 f7 ff ff       	call   c0029796 <msg>
}
c002a03d:	83 c4 18             	add    $0x18,%esp
c002a040:	5b                   	pop    %ebx
c002a041:	c3                   	ret    

c002a042 <acquire1_thread_func>:
  msg ("This should be the last line before finishing this test.");
}

static void
acquire1_thread_func (void *lock_) 
{
c002a042:	53                   	push   %ebx
c002a043:	83 ec 14             	sub    $0x14,%esp
c002a046:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a04a:	53                   	push   %ebx
c002a04b:	e8 6f 89 ff ff       	call   c00229bf <lock_acquire>
  msg ("acquire1: got the lock");
c002a050:	c7 04 24 ef f5 02 c0 	movl   $0xc002f5ef,(%esp)
c002a057:	e8 3a f7 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a05c:	89 1c 24             	mov    %ebx,(%esp)
c002a05f:	e8 eb 8a ff ff       	call   c0022b4f <lock_release>
  msg ("acquire1: done");
c002a064:	c7 04 24 06 f6 02 c0 	movl   $0xc002f606,(%esp)
c002a06b:	e8 26 f7 ff ff       	call   c0029796 <msg>
}
c002a070:	83 c4 18             	add    $0x18,%esp
c002a073:	5b                   	pop    %ebx
c002a074:	c3                   	ret    

c002a075 <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002a075:	53                   	push   %ebx
c002a076:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a079:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a080:	74 1e                	je     c002a0a0 <test_priority_donate_one+0x2b>
c002a082:	83 ec 0c             	sub    $0xc,%esp
c002a085:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a08a:	68 3f d2 02 c0       	push   $0xc002d23f
c002a08f:	68 3c d0 02 c0       	push   $0xc002d03c
c002a094:	6a 1b                	push   $0x1b
c002a096:	68 28 f6 02 c0       	push   $0xc002f628
c002a09b:	e8 2d dc ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a0a0:	e8 eb 6c ff ff       	call   c0020d90 <thread_get_priority>
c002a0a5:	83 f8 1f             	cmp    $0x1f,%eax
c002a0a8:	74 1e                	je     c002a0c8 <test_priority_donate_one+0x53>
c002a0aa:	83 ec 0c             	sub    $0xc,%esp
c002a0ad:	68 54 f6 02 c0       	push   $0xc002f654
c002a0b2:	68 3f d2 02 c0       	push   $0xc002d23f
c002a0b7:	68 3c d0 02 c0       	push   $0xc002d03c
c002a0bc:	6a 1e                	push   $0x1e
c002a0be:	68 28 f6 02 c0       	push   $0xc002f628
c002a0c3:	e8 05 dc ff ff       	call   c0027ccd <debug_panic>

  lock_init (&lock);
c002a0c8:	83 ec 0c             	sub    $0xc,%esp
c002a0cb:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c002a0cf:	53                   	push   %ebx
c002a0d0:	e8 68 88 ff ff       	call   c002293d <lock_init>
  lock_acquire (&lock);
c002a0d5:	89 1c 24             	mov    %ebx,(%esp)
c002a0d8:	e8 e2 88 ff ff       	call   c00229bf <lock_acquire>
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002a0dd:	53                   	push   %ebx
c002a0de:	68 42 a0 02 c0       	push   $0xc002a042
c002a0e3:	6a 20                	push   $0x20
c002a0e5:	68 15 f6 02 c0       	push   $0xc002f615
c002a0ea:	e8 d2 70 ff ff       	call   c00211c1 <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002a0ef:	83 c4 20             	add    $0x20,%esp
c002a0f2:	e8 99 6c ff ff       	call   c0020d90 <thread_get_priority>
c002a0f7:	83 ec 04             	sub    $0x4,%esp
c002a0fa:	50                   	push   %eax
c002a0fb:	6a 20                	push   $0x20
c002a0fd:	68 7c f6 02 c0       	push   $0xc002f67c
c002a102:	e8 8f f6 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002a107:	53                   	push   %ebx
c002a108:	68 0f a0 02 c0       	push   $0xc002a00f
c002a10d:	6a 21                	push   $0x21
c002a10f:	68 1e f6 02 c0       	push   $0xc002f61e
c002a114:	e8 a8 70 ff ff       	call   c00211c1 <thread_create>
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002a119:	83 c4 20             	add    $0x20,%esp
c002a11c:	e8 6f 6c ff ff       	call   c0020d90 <thread_get_priority>
c002a121:	83 ec 04             	sub    $0x4,%esp
c002a124:	50                   	push   %eax
c002a125:	6a 21                	push   $0x21
c002a127:	68 7c f6 02 c0       	push   $0xc002f67c
c002a12c:	e8 65 f6 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002a131:	89 1c 24             	mov    %ebx,(%esp)
c002a134:	e8 16 8a ff ff       	call   c0022b4f <lock_release>
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002a139:	c7 04 24 b8 f6 02 c0 	movl   $0xc002f6b8,(%esp)
c002a140:	e8 51 f6 ff ff       	call   c0029796 <msg>
  msg ("This should be the last line before finishing this test.");
c002a145:	c7 04 24 f8 f6 02 c0 	movl   $0xc002f6f8,(%esp)
c002a14c:	e8 45 f6 ff ff       	call   c0029796 <msg>
}
c002a151:	83 c4 38             	add    $0x38,%esp
c002a154:	5b                   	pop    %ebx
c002a155:	c3                   	ret    

c002a156 <b_thread_func>:
  msg ("Thread a finished.");
}

static void
b_thread_func (void *lock_) 
{
c002a156:	53                   	push   %ebx
c002a157:	83 ec 14             	sub    $0x14,%esp
c002a15a:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a15e:	53                   	push   %ebx
c002a15f:	e8 5b 88 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread b acquired lock b.");
c002a164:	c7 04 24 31 f7 02 c0 	movl   $0xc002f731,(%esp)
c002a16b:	e8 26 f6 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a170:	89 1c 24             	mov    %ebx,(%esp)
c002a173:	e8 d7 89 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread b finished.");
c002a178:	c7 04 24 4b f7 02 c0 	movl   $0xc002f74b,(%esp)
c002a17f:	e8 12 f6 ff ff       	call   c0029796 <msg>
}
c002a184:	83 c4 18             	add    $0x18,%esp
c002a187:	5b                   	pop    %ebx
c002a188:	c3                   	ret    

c002a189 <a_thread_func>:
       PRI_DEFAULT, thread_get_priority ());
}

static void
a_thread_func (void *lock_) 
{
c002a189:	53                   	push   %ebx
c002a18a:	83 ec 14             	sub    $0x14,%esp
c002a18d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a191:	53                   	push   %ebx
c002a192:	e8 28 88 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread a acquired lock a.");
c002a197:	c7 04 24 5e f7 02 c0 	movl   $0xc002f75e,(%esp)
c002a19e:	e8 f3 f5 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a1a3:	89 1c 24             	mov    %ebx,(%esp)
c002a1a6:	e8 a4 89 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread a finished.");
c002a1ab:	c7 04 24 78 f7 02 c0 	movl   $0xc002f778,(%esp)
c002a1b2:	e8 df f5 ff ff       	call   c0029796 <msg>
}
c002a1b7:	83 c4 18             	add    $0x18,%esp
c002a1ba:	5b                   	pop    %ebx
c002a1bb:	c3                   	ret    

c002a1bc <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002a1bc:	56                   	push   %esi
c002a1bd:	53                   	push   %ebx
c002a1be:	83 ec 44             	sub    $0x44,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a1c1:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a1c8:	74 1e                	je     c002a1e8 <test_priority_donate_multiple+0x2c>
c002a1ca:	83 ec 0c             	sub    $0xc,%esp
c002a1cd:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a1d2:	68 3f d2 02 c0       	push   $0xc002d23f
c002a1d7:	68 58 d0 02 c0       	push   $0xc002d058
c002a1dc:	6a 1b                	push   $0x1b
c002a1de:	68 8c f7 02 c0       	push   $0xc002f78c
c002a1e3:	e8 e5 da ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a1e8:	e8 a3 6b ff ff       	call   c0020d90 <thread_get_priority>
c002a1ed:	83 f8 1f             	cmp    $0x1f,%eax
c002a1f0:	74 1e                	je     c002a210 <test_priority_donate_multiple+0x54>
c002a1f2:	83 ec 0c             	sub    $0xc,%esp
c002a1f5:	68 54 f6 02 c0       	push   $0xc002f654
c002a1fa:	68 3f d2 02 c0       	push   $0xc002d23f
c002a1ff:	68 58 d0 02 c0       	push   $0xc002d058
c002a204:	6a 1e                	push   $0x1e
c002a206:	68 8c f7 02 c0       	push   $0xc002f78c
c002a20b:	e8 bd da ff ff       	call   c0027ccd <debug_panic>

  lock_init (&a);
c002a210:	83 ec 0c             	sub    $0xc,%esp
c002a213:	8d 5c 24 2c          	lea    0x2c(%esp),%ebx
c002a217:	53                   	push   %ebx
c002a218:	e8 20 87 ff ff       	call   c002293d <lock_init>
  lock_init (&b);
c002a21d:	83 c4 04             	add    $0x4,%esp
c002a220:	8d 74 24 0c          	lea    0xc(%esp),%esi
c002a224:	56                   	push   %esi
c002a225:	e8 13 87 ff ff       	call   c002293d <lock_init>

  lock_acquire (&a);
c002a22a:	89 1c 24             	mov    %ebx,(%esp)
c002a22d:	e8 8d 87 ff ff       	call   c00229bf <lock_acquire>
  lock_acquire (&b);
c002a232:	89 34 24             	mov    %esi,(%esp)
c002a235:	e8 85 87 ff ff       	call   c00229bf <lock_acquire>

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002a23a:	53                   	push   %ebx
c002a23b:	68 89 a1 02 c0       	push   $0xc002a189
c002a240:	6a 20                	push   $0x20
c002a242:	68 2b e3 02 c0       	push   $0xc002e32b
c002a247:	e8 75 6f ff ff       	call   c00211c1 <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a24c:	83 c4 20             	add    $0x20,%esp
c002a24f:	e8 3c 6b ff ff       	call   c0020d90 <thread_get_priority>
c002a254:	83 ec 04             	sub    $0x4,%esp
c002a257:	50                   	push   %eax
c002a258:	6a 20                	push   $0x20
c002a25a:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a25f:	e8 32 f5 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002a264:	56                   	push   %esi
c002a265:	68 56 a1 02 c0       	push   $0xc002a156
c002a26a:	6a 21                	push   $0x21
c002a26c:	68 f5 ec 02 c0       	push   $0xc002ecf5
c002a271:	e8 4b 6f ff ff       	call   c00211c1 <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a276:	83 c4 20             	add    $0x20,%esp
c002a279:	e8 12 6b ff ff       	call   c0020d90 <thread_get_priority>
c002a27e:	83 ec 04             	sub    $0x4,%esp
c002a281:	50                   	push   %eax
c002a282:	6a 21                	push   $0x21
c002a284:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a289:	e8 08 f5 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002a28e:	89 34 24             	mov    %esi,(%esp)
c002a291:	e8 b9 88 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread b should have just finished.");
c002a296:	c7 04 24 f8 f7 02 c0 	movl   $0xc002f7f8,(%esp)
c002a29d:	e8 f4 f4 ff ff       	call   c0029796 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a2a2:	e8 e9 6a ff ff       	call   c0020d90 <thread_get_priority>
c002a2a7:	83 c4 0c             	add    $0xc,%esp
c002a2aa:	50                   	push   %eax
c002a2ab:	6a 20                	push   $0x20
c002a2ad:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a2b2:	e8 df f4 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002a2b7:	89 1c 24             	mov    %ebx,(%esp)
c002a2ba:	e8 90 88 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread a should have just finished.");
c002a2bf:	c7 04 24 1c f8 02 c0 	movl   $0xc002f81c,(%esp)
c002a2c6:	e8 cb f4 ff ff       	call   c0029796 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a2cb:	e8 c0 6a ff ff       	call   c0020d90 <thread_get_priority>
c002a2d0:	83 c4 0c             	add    $0xc,%esp
c002a2d3:	50                   	push   %eax
c002a2d4:	6a 1f                	push   $0x1f
c002a2d6:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a2db:	e8 b6 f4 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT, thread_get_priority ());
}
c002a2e0:	83 c4 54             	add    $0x54,%esp
c002a2e3:	5b                   	pop    %ebx
c002a2e4:	5e                   	pop    %esi
c002a2e5:	c3                   	ret    

c002a2e6 <c_thread_func>:
  msg ("Thread b finished.");
}

static void
c_thread_func (void *a_ UNUSED) 
{
c002a2e6:	83 ec 18             	sub    $0x18,%esp
  msg ("Thread c finished.");
c002a2e9:	68 40 f8 02 c0       	push   $0xc002f840
c002a2ee:	e8 a3 f4 ff ff       	call   c0029796 <msg>
}
c002a2f3:	83 c4 1c             	add    $0x1c,%esp
c002a2f6:	c3                   	ret    

c002a2f7 <b_thread_func>:
  msg ("Thread a finished.");
}

static void
b_thread_func (void *lock_) 
{
c002a2f7:	53                   	push   %ebx
c002a2f8:	83 ec 14             	sub    $0x14,%esp
c002a2fb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a2ff:	53                   	push   %ebx
c002a300:	e8 ba 86 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread b acquired lock b.");
c002a305:	c7 04 24 31 f7 02 c0 	movl   $0xc002f731,(%esp)
c002a30c:	e8 85 f4 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a311:	89 1c 24             	mov    %ebx,(%esp)
c002a314:	e8 36 88 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread b finished.");
c002a319:	c7 04 24 4b f7 02 c0 	movl   $0xc002f74b,(%esp)
c002a320:	e8 71 f4 ff ff       	call   c0029796 <msg>
}
c002a325:	83 c4 18             	add    $0x18,%esp
c002a328:	5b                   	pop    %ebx
c002a329:	c3                   	ret    

c002a32a <a_thread_func>:
       PRI_DEFAULT, thread_get_priority ());
}

static void
a_thread_func (void *lock_) 
{
c002a32a:	53                   	push   %ebx
c002a32b:	83 ec 14             	sub    $0x14,%esp
c002a32e:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a332:	53                   	push   %ebx
c002a333:	e8 87 86 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread a acquired lock a.");
c002a338:	c7 04 24 5e f7 02 c0 	movl   $0xc002f75e,(%esp)
c002a33f:	e8 52 f4 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a344:	89 1c 24             	mov    %ebx,(%esp)
c002a347:	e8 03 88 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread a finished.");
c002a34c:	c7 04 24 78 f7 02 c0 	movl   $0xc002f778,(%esp)
c002a353:	e8 3e f4 ff ff       	call   c0029796 <msg>
}
c002a358:	83 c4 18             	add    $0x18,%esp
c002a35b:	5b                   	pop    %ebx
c002a35c:	c3                   	ret    

c002a35d <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002a35d:	56                   	push   %esi
c002a35e:	53                   	push   %ebx
c002a35f:	83 ec 44             	sub    $0x44,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a362:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a369:	74 1e                	je     c002a389 <test_priority_donate_multiple2+0x2c>
c002a36b:	83 ec 0c             	sub    $0xc,%esp
c002a36e:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a373:	68 3f d2 02 c0       	push   $0xc002d23f
c002a378:	68 78 d0 02 c0       	push   $0xc002d078
c002a37d:	6a 21                	push   $0x21
c002a37f:	68 54 f8 02 c0       	push   $0xc002f854
c002a384:	e8 44 d9 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a389:	e8 02 6a ff ff       	call   c0020d90 <thread_get_priority>
c002a38e:	83 f8 1f             	cmp    $0x1f,%eax
c002a391:	74 1e                	je     c002a3b1 <test_priority_donate_multiple2+0x54>
c002a393:	83 ec 0c             	sub    $0xc,%esp
c002a396:	68 54 f6 02 c0       	push   $0xc002f654
c002a39b:	68 3f d2 02 c0       	push   $0xc002d23f
c002a3a0:	68 78 d0 02 c0       	push   $0xc002d078
c002a3a5:	6a 24                	push   $0x24
c002a3a7:	68 54 f8 02 c0       	push   $0xc002f854
c002a3ac:	e8 1c d9 ff ff       	call   c0027ccd <debug_panic>

  lock_init (&a);
c002a3b1:	83 ec 0c             	sub    $0xc,%esp
c002a3b4:	8d 74 24 2c          	lea    0x2c(%esp),%esi
c002a3b8:	56                   	push   %esi
c002a3b9:	e8 7f 85 ff ff       	call   c002293d <lock_init>
  lock_init (&b);
c002a3be:	83 c4 04             	add    $0x4,%esp
c002a3c1:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c002a3c5:	53                   	push   %ebx
c002a3c6:	e8 72 85 ff ff       	call   c002293d <lock_init>

  lock_acquire (&a);
c002a3cb:	89 34 24             	mov    %esi,(%esp)
c002a3ce:	e8 ec 85 ff ff       	call   c00229bf <lock_acquire>
  lock_acquire (&b);
c002a3d3:	89 1c 24             	mov    %ebx,(%esp)
c002a3d6:	e8 e4 85 ff ff       	call   c00229bf <lock_acquire>

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002a3db:	56                   	push   %esi
c002a3dc:	68 2a a3 02 c0       	push   $0xc002a32a
c002a3e1:	6a 22                	push   $0x22
c002a3e3:	68 2b e3 02 c0       	push   $0xc002e32b
c002a3e8:	e8 d4 6d ff ff       	call   c00211c1 <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a3ed:	83 c4 20             	add    $0x20,%esp
c002a3f0:	e8 9b 69 ff ff       	call   c0020d90 <thread_get_priority>
c002a3f5:	83 ec 04             	sub    $0x4,%esp
c002a3f8:	50                   	push   %eax
c002a3f9:	6a 22                	push   $0x22
c002a3fb:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a400:	e8 91 f3 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002a405:	6a 00                	push   $0x0
c002a407:	68 e6 a2 02 c0       	push   $0xc002a2e6
c002a40c:	6a 20                	push   $0x20
c002a40e:	68 16 e7 02 c0       	push   $0xc002e716
c002a413:	e8 a9 6d ff ff       	call   c00211c1 <thread_create>

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002a418:	83 c4 20             	add    $0x20,%esp
c002a41b:	53                   	push   %ebx
c002a41c:	68 f7 a2 02 c0       	push   $0xc002a2f7
c002a421:	6a 24                	push   $0x24
c002a423:	68 f5 ec 02 c0       	push   $0xc002ecf5
c002a428:	e8 94 6d ff ff       	call   c00211c1 <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a42d:	e8 5e 69 ff ff       	call   c0020d90 <thread_get_priority>
c002a432:	83 c4 0c             	add    $0xc,%esp
c002a435:	50                   	push   %eax
c002a436:	6a 24                	push   $0x24
c002a438:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a43d:	e8 54 f3 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002a442:	89 34 24             	mov    %esi,(%esp)
c002a445:	e8 05 87 ff ff       	call   c0022b4f <lock_release>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a44a:	e8 41 69 ff ff       	call   c0020d90 <thread_get_priority>
c002a44f:	83 c4 0c             	add    $0xc,%esp
c002a452:	50                   	push   %eax
c002a453:	6a 24                	push   $0x24
c002a455:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a45a:	e8 37 f3 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002a45f:	89 1c 24             	mov    %ebx,(%esp)
c002a462:	e8 e8 86 ff ff       	call   c0022b4f <lock_release>
  msg ("Threads b, a, c should have just finished, in that order.");
c002a467:	c7 04 24 84 f8 02 c0 	movl   $0xc002f884,(%esp)
c002a46e:	e8 23 f3 ff ff       	call   c0029796 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a473:	e8 18 69 ff ff       	call   c0020d90 <thread_get_priority>
c002a478:	83 c4 0c             	add    $0xc,%esp
c002a47b:	50                   	push   %eax
c002a47c:	6a 1f                	push   $0x1f
c002a47e:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a483:	e8 0e f3 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT, thread_get_priority ());
}
c002a488:	83 c4 54             	add    $0x54,%esp
c002a48b:	5b                   	pop    %ebx
c002a48c:	5e                   	pop    %esi
c002a48d:	c3                   	ret    

c002a48e <high_thread_func>:
  msg ("Middle thread finished.");
}

static void
high_thread_func (void *lock_) 
{
c002a48e:	53                   	push   %ebx
c002a48f:	83 ec 14             	sub    $0x14,%esp
c002a492:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a496:	53                   	push   %ebx
c002a497:	e8 23 85 ff ff       	call   c00229bf <lock_acquire>
  msg ("High thread got the lock.");
c002a49c:	c7 04 24 be f8 02 c0 	movl   $0xc002f8be,(%esp)
c002a4a3:	e8 ee f2 ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a4a8:	89 1c 24             	mov    %ebx,(%esp)
c002a4ab:	e8 9f 86 ff ff       	call   c0022b4f <lock_release>
  msg ("High thread finished.");
c002a4b0:	c7 04 24 d8 f8 02 c0 	movl   $0xc002f8d8,(%esp)
c002a4b7:	e8 da f2 ff ff       	call   c0029796 <msg>
}
c002a4bc:	83 c4 18             	add    $0x18,%esp
c002a4bf:	5b                   	pop    %ebx
c002a4c0:	c3                   	ret    

c002a4c1 <medium_thread_func>:
       PRI_DEFAULT, thread_get_priority ());
}

static void
medium_thread_func (void *locks_) 
{
c002a4c1:	53                   	push   %ebx
c002a4c2:	83 ec 14             	sub    $0x14,%esp
c002a4c5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct locks *locks = locks_;

  lock_acquire (locks->b);
c002a4c9:	ff 73 04             	pushl  0x4(%ebx)
c002a4cc:	e8 ee 84 ff ff       	call   c00229bf <lock_acquire>
  lock_acquire (locks->a);
c002a4d1:	83 c4 04             	add    $0x4,%esp
c002a4d4:	ff 33                	pushl  (%ebx)
c002a4d6:	e8 e4 84 ff ff       	call   c00229bf <lock_acquire>

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002a4db:	e8 b0 68 ff ff       	call   c0020d90 <thread_get_priority>
c002a4e0:	83 c4 0c             	add    $0xc,%esp
c002a4e3:	50                   	push   %eax
c002a4e4:	6a 21                	push   $0x21
c002a4e6:	68 30 f9 02 c0       	push   $0xc002f930
c002a4eb:	e8 a6 f2 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002a4f0:	c7 04 24 ee f8 02 c0 	movl   $0xc002f8ee,(%esp)
c002a4f7:	e8 9a f2 ff ff       	call   c0029796 <msg>

  lock_release (locks->a);
c002a4fc:	83 c4 04             	add    $0x4,%esp
c002a4ff:	ff 33                	pushl  (%ebx)
c002a501:	e8 49 86 ff ff       	call   c0022b4f <lock_release>
  thread_yield ();
c002a506:	e8 3e 6c ff ff       	call   c0021149 <thread_yield>

  lock_release (locks->b);
c002a50b:	83 c4 04             	add    $0x4,%esp
c002a50e:	ff 73 04             	pushl  0x4(%ebx)
c002a511:	e8 39 86 ff ff       	call   c0022b4f <lock_release>
  thread_yield ();
c002a516:	e8 2e 6c ff ff       	call   c0021149 <thread_yield>

  msg ("High thread should have just finished.");
c002a51b:	c7 04 24 70 f9 02 c0 	movl   $0xc002f970,(%esp)
c002a522:	e8 6f f2 ff ff       	call   c0029796 <msg>
  msg ("Middle thread finished.");
c002a527:	c7 04 24 0a f9 02 c0 	movl   $0xc002f90a,(%esp)
c002a52e:	e8 63 f2 ff ff       	call   c0029796 <msg>
}
c002a533:	83 c4 18             	add    $0x18,%esp
c002a536:	5b                   	pop    %ebx
c002a537:	c3                   	ret    

c002a538 <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002a538:	56                   	push   %esi
c002a539:	53                   	push   %ebx
c002a53a:	83 ec 54             	sub    $0x54,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a53d:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a544:	74 1e                	je     c002a564 <test_priority_donate_nest+0x2c>
c002a546:	83 ec 0c             	sub    $0xc,%esp
c002a549:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a54e:	68 3f d2 02 c0       	push   $0xc002d23f
c002a553:	68 98 d0 02 c0       	push   $0xc002d098
c002a558:	6a 22                	push   $0x22
c002a55a:	68 98 f9 02 c0       	push   $0xc002f998
c002a55f:	e8 69 d7 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a564:	e8 27 68 ff ff       	call   c0020d90 <thread_get_priority>
c002a569:	83 f8 1f             	cmp    $0x1f,%eax
c002a56c:	74 1e                	je     c002a58c <test_priority_donate_nest+0x54>
c002a56e:	83 ec 0c             	sub    $0xc,%esp
c002a571:	68 54 f6 02 c0       	push   $0xc002f654
c002a576:	68 3f d2 02 c0       	push   $0xc002d23f
c002a57b:	68 98 d0 02 c0       	push   $0xc002d098
c002a580:	6a 25                	push   $0x25
c002a582:	68 98 f9 02 c0       	push   $0xc002f998
c002a587:	e8 41 d7 ff ff       	call   c0027ccd <debug_panic>

  lock_init (&a);
c002a58c:	83 ec 0c             	sub    $0xc,%esp
c002a58f:	8d 5c 24 3c          	lea    0x3c(%esp),%ebx
c002a593:	53                   	push   %ebx
c002a594:	e8 a4 83 ff ff       	call   c002293d <lock_init>
  lock_init (&b);
c002a599:	83 c4 04             	add    $0x4,%esp
c002a59c:	8d 74 24 1c          	lea    0x1c(%esp),%esi
c002a5a0:	56                   	push   %esi
c002a5a1:	e8 97 83 ff ff       	call   c002293d <lock_init>

  lock_acquire (&a);
c002a5a6:	89 1c 24             	mov    %ebx,(%esp)
c002a5a9:	e8 11 84 ff ff       	call   c00229bf <lock_acquire>

  locks.a = &a;
c002a5ae:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  locks.b = &b;
c002a5b2:	89 74 24 1c          	mov    %esi,0x1c(%esp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002a5b6:	8d 44 24 18          	lea    0x18(%esp),%eax
c002a5ba:	50                   	push   %eax
c002a5bb:	68 c1 a4 02 c0       	push   $0xc002a4c1
c002a5c0:	6a 20                	push   $0x20
c002a5c2:	68 22 f9 02 c0       	push   $0xc002f922
c002a5c7:	e8 f5 6b ff ff       	call   c00211c1 <thread_create>
  thread_yield ();
c002a5cc:	83 c4 20             	add    $0x20,%esp
c002a5cf:	e8 75 6b ff ff       	call   c0021149 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002a5d4:	e8 b7 67 ff ff       	call   c0020d90 <thread_get_priority>
c002a5d9:	83 ec 04             	sub    $0x4,%esp
c002a5dc:	50                   	push   %eax
c002a5dd:	6a 20                	push   $0x20
c002a5df:	68 c4 f9 02 c0       	push   $0xc002f9c4
c002a5e4:	e8 ad f1 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002a5e9:	56                   	push   %esi
c002a5ea:	68 8e a4 02 c0       	push   $0xc002a48e
c002a5ef:	6a 21                	push   $0x21
c002a5f1:	68 29 f9 02 c0       	push   $0xc002f929
c002a5f6:	e8 c6 6b ff ff       	call   c00211c1 <thread_create>
  thread_yield ();
c002a5fb:	83 c4 20             	add    $0x20,%esp
c002a5fe:	e8 46 6b ff ff       	call   c0021149 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002a603:	e8 88 67 ff ff       	call   c0020d90 <thread_get_priority>
c002a608:	83 ec 04             	sub    $0x4,%esp
c002a60b:	50                   	push   %eax
c002a60c:	6a 21                	push   $0x21
c002a60e:	68 c4 f9 02 c0       	push   $0xc002f9c4
c002a613:	e8 7e f1 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002a618:	89 1c 24             	mov    %ebx,(%esp)
c002a61b:	e8 2f 85 ff ff       	call   c0022b4f <lock_release>
  thread_yield ();
c002a620:	e8 24 6b ff ff       	call   c0021149 <thread_yield>
  msg ("Medium thread should just have finished.");
c002a625:	c7 04 24 00 fa 02 c0 	movl   $0xc002fa00,(%esp)
c002a62c:	e8 65 f1 ff ff       	call   c0029796 <msg>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002a631:	e8 5a 67 ff ff       	call   c0020d90 <thread_get_priority>
c002a636:	83 c4 0c             	add    $0xc,%esp
c002a639:	50                   	push   %eax
c002a63a:	6a 1f                	push   $0x1f
c002a63c:	68 c4 f9 02 c0       	push   $0xc002f9c4
c002a641:	e8 50 f1 ff ff       	call   c0029796 <msg>
       PRI_DEFAULT, thread_get_priority ());
}
c002a646:	83 c4 64             	add    $0x64,%esp
c002a649:	5b                   	pop    %ebx
c002a64a:	5e                   	pop    %esi
c002a64b:	c3                   	ret    

c002a64c <h_thread_func>:
  msg ("Thread M finished.");
}

static void
h_thread_func (void *ls_) 
{
c002a64c:	53                   	push   %ebx
c002a64d:	83 ec 14             	sub    $0x14,%esp
c002a650:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock_and_sema *ls = ls_;

  lock_acquire (&ls->lock);
c002a654:	53                   	push   %ebx
c002a655:	e8 65 83 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread H acquired lock.");
c002a65a:	c7 04 24 29 fa 02 c0 	movl   $0xc002fa29,(%esp)
c002a661:	e8 30 f1 ff ff       	call   c0029796 <msg>

  sema_up (&ls->sema);
c002a666:	8d 43 20             	lea    0x20(%ebx),%eax
c002a669:	89 04 24             	mov    %eax,(%esp)
c002a66c:	e8 a0 81 ff ff       	call   c0022811 <sema_up>
  lock_release (&ls->lock);
c002a671:	89 1c 24             	mov    %ebx,(%esp)
c002a674:	e8 d6 84 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread H finished.");
c002a679:	c7 04 24 41 fa 02 c0 	movl   $0xc002fa41,(%esp)
c002a680:	e8 11 f1 ff ff       	call   c0029796 <msg>
}
c002a685:	83 c4 18             	add    $0x18,%esp
c002a688:	5b                   	pop    %ebx
c002a689:	c3                   	ret    

c002a68a <m_thread_func>:
  msg ("Thread L finished.");
}

static void
m_thread_func (void *ls_) 
{
c002a68a:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;

  sema_down (&ls->sema);
c002a68d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002a691:	83 c0 20             	add    $0x20,%eax
c002a694:	50                   	push   %eax
c002a695:	e8 8c 80 ff ff       	call   c0022726 <sema_down>
  msg ("Thread M finished.");
c002a69a:	c7 04 24 54 fa 02 c0 	movl   $0xc002fa54,(%esp)
c002a6a1:	e8 f0 f0 ff ff       	call   c0029796 <msg>
}
c002a6a6:	83 c4 1c             	add    $0x1c,%esp
c002a6a9:	c3                   	ret    

c002a6aa <l_thread_func>:
  msg ("Main thread finished.");
}

static void
l_thread_func (void *ls_) 
{
c002a6aa:	53                   	push   %ebx
c002a6ab:	83 ec 14             	sub    $0x14,%esp
c002a6ae:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock_and_sema *ls = ls_;

  lock_acquire (&ls->lock);
c002a6b2:	53                   	push   %ebx
c002a6b3:	e8 07 83 ff ff       	call   c00229bf <lock_acquire>
  msg ("Thread L acquired lock.");
c002a6b8:	c7 04 24 67 fa 02 c0 	movl   $0xc002fa67,(%esp)
c002a6bf:	e8 d2 f0 ff ff       	call   c0029796 <msg>
  sema_down (&ls->sema);
c002a6c4:	8d 43 20             	lea    0x20(%ebx),%eax
c002a6c7:	89 04 24             	mov    %eax,(%esp)
c002a6ca:	e8 57 80 ff ff       	call   c0022726 <sema_down>
  msg ("Thread L downed semaphore.");
c002a6cf:	c7 04 24 7f fa 02 c0 	movl   $0xc002fa7f,(%esp)
c002a6d6:	e8 bb f0 ff ff       	call   c0029796 <msg>
  lock_release (&ls->lock);
c002a6db:	89 1c 24             	mov    %ebx,(%esp)
c002a6de:	e8 6c 84 ff ff       	call   c0022b4f <lock_release>
  msg ("Thread L finished.");
c002a6e3:	c7 04 24 9a fa 02 c0 	movl   $0xc002fa9a,(%esp)
c002a6ea:	e8 a7 f0 ff ff       	call   c0029796 <msg>
}
c002a6ef:	83 c4 18             	add    $0x18,%esp
c002a6f2:	5b                   	pop    %ebx
c002a6f3:	c3                   	ret    

c002a6f4 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002a6f4:	56                   	push   %esi
c002a6f5:	53                   	push   %ebx
c002a6f6:	83 ec 44             	sub    $0x44,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a6f9:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a700:	74 1e                	je     c002a720 <test_priority_donate_sema+0x2c>
c002a702:	83 ec 0c             	sub    $0xc,%esp
c002a705:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a70a:	68 3f d2 02 c0       	push   $0xc002d23f
c002a70f:	68 b4 d0 02 c0       	push   $0xc002d0b4
c002a714:	6a 23                	push   $0x23
c002a716:	68 cc fa 02 c0       	push   $0xc002facc
c002a71b:	e8 ad d5 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a720:	e8 6b 66 ff ff       	call   c0020d90 <thread_get_priority>
c002a725:	83 f8 1f             	cmp    $0x1f,%eax
c002a728:	74 1e                	je     c002a748 <test_priority_donate_sema+0x54>
c002a72a:	83 ec 0c             	sub    $0xc,%esp
c002a72d:	68 54 f6 02 c0       	push   $0xc002f654
c002a732:	68 3f d2 02 c0       	push   $0xc002d23f
c002a737:	68 b4 d0 02 c0       	push   $0xc002d0b4
c002a73c:	6a 26                	push   $0x26
c002a73e:	68 cc fa 02 c0       	push   $0xc002facc
c002a743:	e8 85 d5 ff ff       	call   c0027ccd <debug_panic>

  lock_init (&ls.lock);
c002a748:	83 ec 0c             	sub    $0xc,%esp
c002a74b:	8d 5c 24 18          	lea    0x18(%esp),%ebx
c002a74f:	53                   	push   %ebx
c002a750:	e8 e8 81 ff ff       	call   c002293d <lock_init>
  sema_init (&ls.sema, 0);
c002a755:	83 c4 08             	add    $0x8,%esp
c002a758:	6a 00                	push   $0x0
c002a75a:	8d 74 24 38          	lea    0x38(%esp),%esi
c002a75e:	56                   	push   %esi
c002a75f:	e8 83 7f ff ff       	call   c00226e7 <sema_init>
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002a764:	53                   	push   %ebx
c002a765:	68 aa a6 02 c0       	push   $0xc002a6aa
c002a76a:	6a 20                	push   $0x20
c002a76c:	68 ad fa 02 c0       	push   $0xc002faad
c002a771:	e8 4b 6a ff ff       	call   c00211c1 <thread_create>
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002a776:	83 c4 20             	add    $0x20,%esp
c002a779:	53                   	push   %ebx
c002a77a:	68 8a a6 02 c0       	push   $0xc002a68a
c002a77f:	6a 22                	push   $0x22
c002a781:	68 b1 fa 02 c0       	push   $0xc002fab1
c002a786:	e8 36 6a ff ff       	call   c00211c1 <thread_create>
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002a78b:	53                   	push   %ebx
c002a78c:	68 4c a6 02 c0       	push   $0xc002a64c
c002a791:	6a 24                	push   $0x24
c002a793:	68 29 f9 02 c0       	push   $0xc002f929
c002a798:	e8 24 6a ff ff       	call   c00211c1 <thread_create>
  sema_up (&ls.sema);
c002a79d:	83 c4 14             	add    $0x14,%esp
c002a7a0:	56                   	push   %esi
c002a7a1:	e8 6b 80 ff ff       	call   c0022811 <sema_up>
  msg ("Main thread finished.");
c002a7a6:	c7 04 24 b5 fa 02 c0 	movl   $0xc002fab5,(%esp)
c002a7ad:	e8 e4 ef ff ff       	call   c0029796 <msg>
}
c002a7b2:	83 c4 54             	add    $0x54,%esp
c002a7b5:	5b                   	pop    %ebx
c002a7b6:	5e                   	pop    %esi
c002a7b7:	c3                   	ret    

c002a7b8 <acquire_thread_func>:
       PRI_DEFAULT - 10, thread_get_priority ());
}

static void
acquire_thread_func (void *lock_) 
{
c002a7b8:	53                   	push   %ebx
c002a7b9:	83 ec 14             	sub    $0x14,%esp
c002a7bc:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  struct lock *lock = lock_;

  lock_acquire (lock);
c002a7c0:	53                   	push   %ebx
c002a7c1:	e8 f9 81 ff ff       	call   c00229bf <lock_acquire>
  msg ("acquire: got the lock");
c002a7c6:	c7 04 24 f7 fa 02 c0 	movl   $0xc002faf7,(%esp)
c002a7cd:	e8 c4 ef ff ff       	call   c0029796 <msg>
  lock_release (lock);
c002a7d2:	89 1c 24             	mov    %ebx,(%esp)
c002a7d5:	e8 75 83 ff ff       	call   c0022b4f <lock_release>
  msg ("acquire: done");
c002a7da:	c7 04 24 0d fb 02 c0 	movl   $0xc002fb0d,(%esp)
c002a7e1:	e8 b0 ef ff ff       	call   c0029796 <msg>
}
c002a7e6:	83 c4 18             	add    $0x18,%esp
c002a7e9:	5b                   	pop    %ebx
c002a7ea:	c3                   	ret    

c002a7eb <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002a7eb:	53                   	push   %ebx
c002a7ec:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a7ef:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a7f6:	74 1e                	je     c002a816 <test_priority_donate_lower+0x2b>
c002a7f8:	83 ec 0c             	sub    $0xc,%esp
c002a7fb:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a800:	68 3f d2 02 c0       	push   $0xc002d23f
c002a805:	68 d0 d0 02 c0       	push   $0xc002d0d0
c002a80a:	6a 15                	push   $0x15
c002a80c:	68 40 fb 02 c0       	push   $0xc002fb40
c002a811:	e8 b7 d4 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a816:	e8 75 65 ff ff       	call   c0020d90 <thread_get_priority>
c002a81b:	83 f8 1f             	cmp    $0x1f,%eax
c002a81e:	74 1e                	je     c002a83e <test_priority_donate_lower+0x53>
c002a820:	83 ec 0c             	sub    $0xc,%esp
c002a823:	68 54 f6 02 c0       	push   $0xc002f654
c002a828:	68 3f d2 02 c0       	push   $0xc002d23f
c002a82d:	68 d0 d0 02 c0       	push   $0xc002d0d0
c002a832:	6a 18                	push   $0x18
c002a834:	68 40 fb 02 c0       	push   $0xc002fb40
c002a839:	e8 8f d4 ff ff       	call   c0027ccd <debug_panic>

  lock_init (&lock);
c002a83e:	83 ec 0c             	sub    $0xc,%esp
c002a841:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c002a845:	53                   	push   %ebx
c002a846:	e8 f2 80 ff ff       	call   c002293d <lock_init>
  lock_acquire (&lock);
c002a84b:	89 1c 24             	mov    %ebx,(%esp)
c002a84e:	e8 6c 81 ff ff       	call   c00229bf <lock_acquire>
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002a853:	53                   	push   %ebx
c002a854:	68 b8 a7 02 c0       	push   $0xc002a7b8
c002a859:	6a 29                	push   $0x29
c002a85b:	68 1b fb 02 c0       	push   $0xc002fb1b
c002a860:	e8 5c 69 ff ff       	call   c00211c1 <thread_create>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a865:	83 c4 20             	add    $0x20,%esp
c002a868:	e8 23 65 ff ff       	call   c0020d90 <thread_get_priority>
c002a86d:	83 ec 04             	sub    $0x4,%esp
c002a870:	50                   	push   %eax
c002a871:	6a 29                	push   $0x29
c002a873:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a878:	e8 19 ef ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002a87d:	c7 04 24 23 fb 02 c0 	movl   $0xc002fb23,(%esp)
c002a884:	e8 0d ef ff ff       	call   c0029796 <msg>
  thread_set_priority (PRI_DEFAULT - 10);
c002a889:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c002a890:	e8 60 6a ff ff       	call   c00212f5 <thread_set_priority>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a895:	e8 f6 64 ff ff       	call   c0020d90 <thread_get_priority>
c002a89a:	83 c4 0c             	add    $0xc,%esp
c002a89d:	50                   	push   %eax
c002a89e:	6a 29                	push   $0x29
c002a8a0:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a8a5:	e8 ec ee ff ff       	call   c0029796 <msg>
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002a8aa:	89 1c 24             	mov    %ebx,(%esp)
c002a8ad:	e8 9d 82 ff ff       	call   c0022b4f <lock_release>
  msg ("acquire must already have finished.");
c002a8b2:	c7 04 24 6c fb 02 c0 	movl   $0xc002fb6c,(%esp)
c002a8b9:	e8 d8 ee ff ff       	call   c0029796 <msg>
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002a8be:	e8 cd 64 ff ff       	call   c0020d90 <thread_get_priority>
c002a8c3:	83 c4 0c             	add    $0xc,%esp
c002a8c6:	50                   	push   %eax
c002a8c7:	6a 15                	push   $0x15
c002a8c9:	68 bc f7 02 c0       	push   $0xc002f7bc
c002a8ce:	e8 c3 ee ff ff       	call   c0029796 <msg>
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002a8d3:	83 c4 38             	add    $0x38,%esp
c002a8d6:	5b                   	pop    %ebx
c002a8d7:	c3                   	ret    

c002a8d8 <simple_thread_func>:
    }
}

static void 
simple_thread_func (void *data_) 
{
c002a8d8:	56                   	push   %esi
c002a8d9:	53                   	push   %ebx
c002a8da:	83 ec 04             	sub    $0x4,%esp
c002a8dd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002a8e1:	be 10 00 00 00       	mov    $0x10,%esi
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
    {
      lock_acquire (data->lock);
c002a8e6:	83 ec 0c             	sub    $0xc,%esp
c002a8e9:	ff 73 08             	pushl  0x8(%ebx)
c002a8ec:	e8 ce 80 ff ff       	call   c00229bf <lock_acquire>
      *(*data->op)++ = data->id;
c002a8f1:	8b 53 0c             	mov    0xc(%ebx),%edx
c002a8f4:	8b 02                	mov    (%edx),%eax
c002a8f6:	8d 48 04             	lea    0x4(%eax),%ecx
c002a8f9:	89 0a                	mov    %ecx,(%edx)
c002a8fb:	8b 13                	mov    (%ebx),%edx
c002a8fd:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002a8ff:	83 c4 04             	add    $0x4,%esp
c002a902:	ff 73 08             	pushl  0x8(%ebx)
c002a905:	e8 45 82 ff ff       	call   c0022b4f <lock_release>
      thread_yield ();
c002a90a:	e8 3a 68 ff ff       	call   c0021149 <thread_yield>
simple_thread_func (void *data_) 
{
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002a90f:	83 c4 10             	add    $0x10,%esp
c002a912:	83 ee 01             	sub    $0x1,%esi
c002a915:	75 cf                	jne    c002a8e6 <simple_thread_func+0xe>
      lock_acquire (data->lock);
      *(*data->op)++ = data->id;
      lock_release (data->lock);
      thread_yield ();
    }
}
c002a917:	83 c4 04             	add    $0x4,%esp
c002a91a:	5b                   	pop    %ebx
c002a91b:	5e                   	pop    %esi
c002a91c:	c3                   	ret    

c002a91d <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002a91d:	55                   	push   %ebp
c002a91e:	57                   	push   %edi
c002a91f:	56                   	push   %esi
c002a920:	53                   	push   %ebx
c002a921:	81 ec 4c 01 00 00    	sub    $0x14c,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002a927:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002a92e:	74 1e                	je     c002a94e <test_priority_fifo+0x31>
c002a930:	83 ec 0c             	sub    $0xc,%esp
c002a933:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002a938:	68 3f d2 02 c0       	push   $0xc002d23f
c002a93d:	68 ec d0 02 c0       	push   $0xc002d0ec
c002a942:	6a 28                	push   $0x28
c002a944:	68 c0 fb 02 c0       	push   $0xc002fbc0
c002a949:	e8 7f d3 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002a94e:	e8 3d 64 ff ff       	call   c0020d90 <thread_get_priority>
c002a953:	83 f8 1f             	cmp    $0x1f,%eax
c002a956:	74 1e                	je     c002a976 <test_priority_fifo+0x59>
c002a958:	83 ec 0c             	sub    $0xc,%esp
c002a95b:	68 54 f6 02 c0       	push   $0xc002f654
c002a960:	68 3f d2 02 c0       	push   $0xc002d23f
c002a965:	68 ec d0 02 c0       	push   $0xc002d0ec
c002a96a:	6a 2b                	push   $0x2b
c002a96c:	68 c0 fb 02 c0       	push   $0xc002fbc0
c002a971:	e8 57 d3 ff ff       	call   c0027ccd <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002a976:	83 ec 04             	sub    $0x4,%esp
c002a979:	6a 10                	push   $0x10
c002a97b:	6a 10                	push   $0x10
c002a97d:	68 e4 fb 02 c0       	push   $0xc002fbe4
c002a982:	e8 0f ee ff ff       	call   c0029796 <msg>
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002a987:	c7 04 24 24 fc 02 c0 	movl   $0xc002fc24,(%esp)
c002a98e:	e8 03 ee ff ff       	call   c0029796 <msg>

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002a993:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
c002a99a:	e8 d0 8a ff ff       	call   c002346f <malloc>
c002a99f:	89 c6                	mov    %eax,%esi
c002a9a1:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  ASSERT (output != NULL);
c002a9a5:	83 c4 10             	add    $0x10,%esp
c002a9a8:	85 c0                	test   %eax,%eax
c002a9aa:	75 1e                	jne    c002a9ca <test_priority_fifo+0xad>
c002a9ac:	83 ec 0c             	sub    $0xc,%esp
c002a9af:	68 c2 f1 02 c0       	push   $0xc002f1c2
c002a9b4:	68 3f d2 02 c0       	push   $0xc002d23f
c002a9b9:	68 ec d0 02 c0       	push   $0xc002d0ec
c002a9be:	6a 32                	push   $0x32
c002a9c0:	68 c0 fb 02 c0       	push   $0xc002fbc0
c002a9c5:	e8 03 d3 ff ff       	call   c0027ccd <debug_panic>
  lock_init (&lock);
c002a9ca:	83 ec 0c             	sub    $0xc,%esp
c002a9cd:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002a9d1:	50                   	push   %eax
c002a9d2:	e8 66 7f ff ff       	call   c002293d <lock_init>

  thread_set_priority (PRI_DEFAULT + 2);
c002a9d7:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c002a9de:	e8 12 69 ff ff       	call   c00212f5 <thread_set_priority>
c002a9e3:	8d 5c 24 50          	lea    0x50(%esp),%ebx
c002a9e7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002a9ea:	bf 00 00 00 00       	mov    $0x0,%edi
    {
      char name[16];
      struct simple_thread_data *d = data + i;
      snprintf (name, sizeof name, "%d", i);
c002a9ef:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002a9f3:	57                   	push   %edi
c002a9f4:	68 d8 f1 02 c0       	push   $0xc002f1d8
c002a9f9:	6a 10                	push   $0x10
c002a9fb:	55                   	push   %ebp
c002a9fc:	e8 61 bd ff ff       	call   c0026762 <snprintf>
      d->id = i;
c002aa01:	89 3b                	mov    %edi,(%ebx)
      d->iterations = 0;
c002aa03:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
      d->lock = &lock;
c002aa0a:	8d 44 24 30          	lea    0x30(%esp),%eax
c002aa0e:	89 43 08             	mov    %eax,0x8(%ebx)
      d->op = &op;
c002aa11:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002aa15:	89 43 0c             	mov    %eax,0xc(%ebx)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002aa18:	53                   	push   %ebx
c002aa19:	68 d8 a8 02 c0       	push   $0xc002a8d8
c002aa1e:	6a 20                	push   $0x20
c002aa20:	55                   	push   %ebp
c002aa21:	e8 9b 67 ff ff       	call   c00211c1 <thread_create>
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
  ASSERT (output != NULL);
  lock_init (&lock);

  thread_set_priority (PRI_DEFAULT + 2);
  for (i = 0; i < THREAD_CNT; i++) 
c002aa26:	83 c7 01             	add    $0x1,%edi
c002aa29:	83 c3 10             	add    $0x10,%ebx
c002aa2c:	83 c4 20             	add    $0x20,%esp
c002aa2f:	83 ff 10             	cmp    $0x10,%edi
c002aa32:	75 bf                	jne    c002a9f3 <test_priority_fifo+0xd6>
      d->lock = &lock;
      d->op = &op;
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
    }

  thread_set_priority (PRI_DEFAULT);
c002aa34:	83 ec 0c             	sub    $0xc,%esp
c002aa37:	6a 1f                	push   $0x1f
c002aa39:	e8 b7 68 ff ff       	call   c00212f5 <thread_set_priority>
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002aa3e:	83 c4 10             	add    $0x10,%esp
c002aa41:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002aa46:	75 13                	jne    c002aa5b <test_priority_fifo+0x13e>

  cnt = 0;
  for (; output < op; output++) 
c002aa48:	3b 74 24 1c          	cmp    0x1c(%esp),%esi
c002aa4c:	0f 83 ad 00 00 00    	jae    c002aaff <test_priority_fifo+0x1e2>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002aa52:	8b 1e                	mov    (%esi),%ebx
c002aa54:	83 fb 0f             	cmp    $0xf,%ebx
c002aa57:	76 45                	jbe    c002aa9e <test_priority_fifo+0x181>
c002aa59:	eb 25                	jmp    c002aa80 <test_priority_fifo+0x163>
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
    }

  thread_set_priority (PRI_DEFAULT);
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002aa5b:	83 ec 0c             	sub    $0xc,%esp
c002aa5e:	68 90 fb 02 c0       	push   $0xc002fb90
c002aa63:	68 3f d2 02 c0       	push   $0xc002d23f
c002aa68:	68 ec d0 02 c0       	push   $0xc002d0ec
c002aa6d:	6a 44                	push   $0x44
c002aa6f:	68 c0 fb 02 c0       	push   $0xc002fbc0
c002aa74:	e8 54 d2 ff ff       	call   c0027ccd <debug_panic>
  cnt = 0;
  for (; output < op; output++) 
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002aa79:	8b 1e                	mov    (%esi),%ebx
c002aa7b:	83 fb 0f             	cmp    $0xf,%ebx
c002aa7e:	76 23                	jbe    c002aaa3 <test_priority_fifo+0x186>
c002aa80:	83 ec 0c             	sub    $0xc,%esp
c002aa83:	68 50 fc 02 c0       	push   $0xc002fc50
c002aa88:	68 3f d2 02 c0       	push   $0xc002d23f
c002aa8d:	68 ec d0 02 c0       	push   $0xc002d0ec
c002aa92:	6a 4b                	push   $0x4b
c002aa94:	68 c0 fb 02 c0       	push   $0xc002fbc0
c002aa99:	e8 2f d2 ff ff       	call   c0027ccd <debug_panic>
c002aa9e:	bf 00 00 00 00       	mov    $0x0,%edi
      d = data + *output;
c002aaa3:	c1 e3 04             	shl    $0x4,%ebx
c002aaa6:	8d 44 24 40          	lea    0x40(%esp),%eax
c002aaaa:	01 c3                	add    %eax,%ebx
      if (cnt % THREAD_CNT == 0)
c002aaac:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002aab2:	75 10                	jne    c002aac4 <test_priority_fifo+0x1a7>
        printf ("(priority-fifo) iteration:");
c002aab4:	83 ec 0c             	sub    $0xc,%esp
c002aab7:	68 a4 fb 02 c0       	push   $0xc002fba4
c002aabc:	e8 94 b5 ff ff       	call   c0026055 <printf>
c002aac1:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002aac4:	83 ec 08             	sub    $0x8,%esp
c002aac7:	ff 33                	pushl  (%ebx)
c002aac9:	68 d7 f1 02 c0       	push   $0xc002f1d7
c002aace:	e8 82 b5 ff ff       	call   c0026055 <printf>
      if (++cnt % THREAD_CNT == 0)
c002aad3:	83 c7 01             	add    $0x1,%edi
c002aad6:	83 c4 10             	add    $0x10,%esp
c002aad9:	f7 c7 0f 00 00 00    	test   $0xf,%edi
c002aadf:	75 0d                	jne    c002aaee <test_priority_fifo+0x1d1>
        printf ("\n");
c002aae1:	83 ec 0c             	sub    $0xc,%esp
c002aae4:	6a 0a                	push   $0xa
c002aae6:	e8 8a ec ff ff       	call   c0029775 <putchar>
c002aaeb:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002aaee:	83 43 04 01          	addl   $0x1,0x4(%ebx)
  thread_set_priority (PRI_DEFAULT);
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);

  cnt = 0;
  for (; output < op; output++) 
c002aaf2:	83 c6 04             	add    $0x4,%esi
c002aaf5:	39 74 24 1c          	cmp    %esi,0x1c(%esp)
c002aaf9:	0f 87 7a ff ff ff    	ja     c002aa79 <test_priority_fifo+0x15c>
      printf (" %d", d->id);
      if (++cnt % THREAD_CNT == 0)
        printf ("\n");
      d->iterations++;
    }
}
c002aaff:	81 c4 4c 01 00 00    	add    $0x14c,%esp
c002ab05:	5b                   	pop    %ebx
c002ab06:	5e                   	pop    %esi
c002ab07:	5f                   	pop    %edi
c002ab08:	5d                   	pop    %ebp
c002ab09:	c3                   	ret    

c002ab0a <simple_thread_func>:
  msg ("The high-priority thread should have already completed.");
}

static void 
simple_thread_func (void *aux UNUSED) 
{
c002ab0a:	53                   	push   %ebx
c002ab0b:	83 ec 08             	sub    $0x8,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002ab0e:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002ab13:	e8 e3 61 ff ff       	call   c0020cfb <thread_name>
c002ab18:	83 ec 04             	sub    $0x4,%esp
c002ab1b:	53                   	push   %ebx
c002ab1c:	50                   	push   %eax
c002ab1d:	68 75 fc 02 c0       	push   $0xc002fc75
c002ab22:	e8 6f ec ff ff       	call   c0029796 <msg>
      thread_yield ();
c002ab27:	e8 1d 66 ff ff       	call   c0021149 <thread_yield>
static void 
simple_thread_func (void *aux UNUSED) 
{
  int i;
  
  for (i = 0; i < 5; i++) 
c002ab2c:	83 c3 01             	add    $0x1,%ebx
c002ab2f:	83 c4 10             	add    $0x10,%esp
c002ab32:	83 fb 05             	cmp    $0x5,%ebx
c002ab35:	75 dc                	jne    c002ab13 <simple_thread_func+0x9>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
      thread_yield ();
    }
  msg ("Thread %s done!", thread_name ());
c002ab37:	e8 bf 61 ff ff       	call   c0020cfb <thread_name>
c002ab3c:	83 ec 08             	sub    $0x8,%esp
c002ab3f:	50                   	push   %eax
c002ab40:	68 8c fc 02 c0       	push   $0xc002fc8c
c002ab45:	e8 4c ec ff ff       	call   c0029796 <msg>
}
c002ab4a:	83 c4 18             	add    $0x18,%esp
c002ab4d:	5b                   	pop    %ebx
c002ab4e:	c3                   	ret    

c002ab4f <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002ab4f:	83 ec 0c             	sub    $0xc,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ab52:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002ab59:	74 1e                	je     c002ab79 <test_priority_preempt+0x2a>
c002ab5b:	83 ec 0c             	sub    $0xc,%esp
c002ab5e:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002ab63:	68 3f d2 02 c0       	push   $0xc002d23f
c002ab68:	68 00 d1 02 c0       	push   $0xc002d100
c002ab6d:	6a 15                	push   $0x15
c002ab6f:	68 ac fc 02 c0       	push   $0xc002fcac
c002ab74:	e8 54 d1 ff ff       	call   c0027ccd <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ab79:	e8 12 62 ff ff       	call   c0020d90 <thread_get_priority>
c002ab7e:	83 f8 1f             	cmp    $0x1f,%eax
c002ab81:	74 1e                	je     c002aba1 <test_priority_preempt+0x52>
c002ab83:	83 ec 0c             	sub    $0xc,%esp
c002ab86:	68 54 f6 02 c0       	push   $0xc002f654
c002ab8b:	68 3f d2 02 c0       	push   $0xc002d23f
c002ab90:	68 00 d1 02 c0       	push   $0xc002d100
c002ab95:	6a 18                	push   $0x18
c002ab97:	68 ac fc 02 c0       	push   $0xc002fcac
c002ab9c:	e8 2c d1 ff ff       	call   c0027ccd <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002aba1:	6a 00                	push   $0x0
c002aba3:	68 0a ab 02 c0       	push   $0xc002ab0a
c002aba8:	6a 20                	push   $0x20
c002abaa:	68 9c fc 02 c0       	push   $0xc002fc9c
c002abaf:	e8 0d 66 ff ff       	call   c00211c1 <thread_create>
  msg ("The high-priority thread should have already completed.");
c002abb4:	c7 04 24 d4 fc 02 c0 	movl   $0xc002fcd4,(%esp)
c002abbb:	e8 d6 eb ff ff       	call   c0029796 <msg>
}
c002abc0:	83 c4 1c             	add    $0x1c,%esp
c002abc3:	c3                   	ret    

c002abc4 <priority_sema_thread>:
    }
}

static void
priority_sema_thread (void *aux UNUSED) 
{
c002abc4:	83 ec 18             	sub    $0x18,%esp
  sema_down (&sema);
c002abc7:	68 68 96 03 c0       	push   $0xc0039668
c002abcc:	e8 55 7b ff ff       	call   c0022726 <sema_down>
  msg ("Thread %s woke up.", thread_name ());
c002abd1:	e8 25 61 ff ff       	call   c0020cfb <thread_name>
c002abd6:	83 c4 08             	add    $0x8,%esp
c002abd9:	50                   	push   %eax
c002abda:	68 a8 f4 02 c0       	push   $0xc002f4a8
c002abdf:	e8 b2 eb ff ff       	call   c0029796 <msg>
}
c002abe4:	83 c4 1c             	add    $0x1c,%esp
c002abe7:	c3                   	ret    

c002abe8 <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002abe8:	55                   	push   %ebp
c002abe9:	57                   	push   %edi
c002abea:	56                   	push   %esi
c002abeb:	53                   	push   %ebx
c002abec:	83 ec 1c             	sub    $0x1c,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002abef:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002abf6:	74 1e                	je     c002ac16 <test_priority_sema+0x2e>
c002abf8:	83 ec 0c             	sub    $0xc,%esp
c002abfb:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002ac00:	68 3f d2 02 c0       	push   $0xc002d23f
c002ac05:	68 18 d1 02 c0       	push   $0xc002d118
c002ac0a:	6a 15                	push   $0x15
c002ac0c:	68 24 fd 02 c0       	push   $0xc002fd24
c002ac11:	e8 b7 d0 ff ff       	call   c0027ccd <debug_panic>

  sema_init (&sema, 0);
c002ac16:	83 ec 08             	sub    $0x8,%esp
c002ac19:	6a 00                	push   $0x0
c002ac1b:	68 68 96 03 c0       	push   $0xc0039668
c002ac20:	e8 c2 7a ff ff       	call   c00226e7 <sema_init>
  thread_set_priority (PRI_MIN);
c002ac25:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002ac2c:	e8 c4 66 ff ff       	call   c00212f5 <thread_set_priority>
c002ac31:	83 c4 10             	add    $0x10,%esp
c002ac34:	bb 03 00 00 00       	mov    $0x3,%ebx
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002ac39:	bf 67 66 66 66       	mov    $0x66666667,%edi
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ac3e:	89 e6                	mov    %esp,%esi

  sema_init (&sema, 0);
  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002ac40:	89 d8                	mov    %ebx,%eax
c002ac42:	f7 ef                	imul   %edi
c002ac44:	c1 fa 02             	sar    $0x2,%edx
c002ac47:	89 d8                	mov    %ebx,%eax
c002ac49:	c1 f8 1f             	sar    $0x1f,%eax
c002ac4c:	29 c2                	sub    %eax,%edx
c002ac4e:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002ac51:	01 c0                	add    %eax,%eax
c002ac53:	29 d8                	sub    %ebx,%eax
c002ac55:	8d 68 1e             	lea    0x1e(%eax),%ebp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ac58:	55                   	push   %ebp
c002ac59:	68 bb f4 02 c0       	push   $0xc002f4bb
c002ac5e:	6a 10                	push   $0x10
c002ac60:	56                   	push   %esi
c002ac61:	e8 fc ba ff ff       	call   c0026762 <snprintf>
      thread_create (name, priority, priority_sema_thread, NULL);
c002ac66:	6a 00                	push   $0x0
c002ac68:	68 c4 ab 02 c0       	push   $0xc002abc4
c002ac6d:	55                   	push   %ebp
c002ac6e:	56                   	push   %esi
c002ac6f:	e8 4d 65 ff ff       	call   c00211c1 <thread_create>
c002ac74:	83 c3 01             	add    $0x1,%ebx
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  sema_init (&sema, 0);
  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002ac77:	83 c4 20             	add    $0x20,%esp
c002ac7a:	83 fb 0d             	cmp    $0xd,%ebx
c002ac7d:	75 c1                	jne    c002ac40 <test_priority_sema+0x58>
c002ac7f:	bb 0a 00 00 00       	mov    $0xa,%ebx
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
    {
      sema_up (&sema);
c002ac84:	83 ec 0c             	sub    $0xc,%esp
c002ac87:	68 68 96 03 c0       	push   $0xc0039668
c002ac8c:	e8 80 7b ff ff       	call   c0022811 <sema_up>
      msg ("Back in main thread."); 
c002ac91:	c7 04 24 0c fd 02 c0 	movl   $0xc002fd0c,(%esp)
c002ac98:	e8 f9 ea ff ff       	call   c0029796 <msg>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002ac9d:	83 c4 10             	add    $0x10,%esp
c002aca0:	83 eb 01             	sub    $0x1,%ebx
c002aca3:	75 df                	jne    c002ac84 <test_priority_sema+0x9c>
    {
      sema_up (&sema);
      msg ("Back in main thread."); 
    }
}
c002aca5:	83 c4 1c             	add    $0x1c,%esp
c002aca8:	5b                   	pop    %ebx
c002aca9:	5e                   	pop    %esi
c002acaa:	5f                   	pop    %edi
c002acab:	5d                   	pop    %ebp
c002acac:	c3                   	ret    

c002acad <priority_condvar_thread>:
    }
}

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002acad:	83 ec 0c             	sub    $0xc,%esp
  msg ("Thread %s starting.", thread_name ());
c002acb0:	e8 46 60 ff ff       	call   c0020cfb <thread_name>
c002acb5:	83 ec 08             	sub    $0x8,%esp
c002acb8:	50                   	push   %eax
c002acb9:	68 48 fd 02 c0       	push   $0xc002fd48
c002acbe:	e8 d3 ea ff ff       	call   c0029796 <msg>
  lock_acquire (&lock);
c002acc3:	c7 04 24 a0 96 03 c0 	movl   $0xc00396a0,(%esp)
c002acca:	e8 f0 7c ff ff       	call   c00229bf <lock_acquire>
  cond_wait (&condition, &lock);
c002accf:	83 c4 08             	add    $0x8,%esp
c002acd2:	68 a0 96 03 c0       	push   $0xc00396a0
c002acd7:	68 80 96 03 c0       	push   $0xc0039680
c002acdc:	e8 18 80 ff ff       	call   c0022cf9 <cond_wait>
  msg ("Thread %s woke up.", thread_name ());
c002ace1:	e8 15 60 ff ff       	call   c0020cfb <thread_name>
c002ace6:	83 c4 08             	add    $0x8,%esp
c002ace9:	50                   	push   %eax
c002acea:	68 a8 f4 02 c0       	push   $0xc002f4a8
c002acef:	e8 a2 ea ff ff       	call   c0029796 <msg>
  lock_release (&lock);
c002acf4:	c7 04 24 a0 96 03 c0 	movl   $0xc00396a0,(%esp)
c002acfb:	e8 4f 7e ff ff       	call   c0022b4f <lock_release>
}
c002ad00:	83 c4 1c             	add    $0x1c,%esp
c002ad03:	c3                   	ret    

c002ad04 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002ad04:	55                   	push   %ebp
c002ad05:	57                   	push   %edi
c002ad06:	56                   	push   %esi
c002ad07:	53                   	push   %ebx
c002ad08:	83 ec 1c             	sub    $0x1c,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ad0b:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002ad12:	74 1e                	je     c002ad32 <test_priority_condvar+0x2e>
c002ad14:	83 ec 0c             	sub    $0xc,%esp
c002ad17:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002ad1c:	68 3f d2 02 c0       	push   $0xc002d23f
c002ad21:	68 2c d1 02 c0       	push   $0xc002d12c
c002ad26:	6a 16                	push   $0x16
c002ad28:	68 6c fd 02 c0       	push   $0xc002fd6c
c002ad2d:	e8 9b cf ff ff       	call   c0027ccd <debug_panic>

  lock_init (&lock);
c002ad32:	83 ec 0c             	sub    $0xc,%esp
c002ad35:	68 a0 96 03 c0       	push   $0xc00396a0
c002ad3a:	e8 fe 7b ff ff       	call   c002293d <lock_init>
  cond_init (&condition);
c002ad3f:	c7 04 24 80 96 03 c0 	movl   $0xc0039680,(%esp)
c002ad46:	e8 75 7f ff ff       	call   c0022cc0 <cond_init>

  thread_set_priority (PRI_MIN);
c002ad4b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002ad52:	e8 9e 65 ff ff       	call   c00212f5 <thread_set_priority>
c002ad57:	83 c4 10             	add    $0x10,%esp
c002ad5a:	bb 07 00 00 00       	mov    $0x7,%ebx
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002ad5f:	bf 67 66 66 66       	mov    $0x66666667,%edi
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ad64:	89 e6                	mov    %esp,%esi
  cond_init (&condition);

  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002ad66:	89 d8                	mov    %ebx,%eax
c002ad68:	f7 ef                	imul   %edi
c002ad6a:	c1 fa 02             	sar    $0x2,%edx
c002ad6d:	89 d8                	mov    %ebx,%eax
c002ad6f:	c1 f8 1f             	sar    $0x1f,%eax
c002ad72:	29 c2                	sub    %eax,%edx
c002ad74:	8d 04 92             	lea    (%edx,%edx,4),%eax
c002ad77:	01 c0                	add    %eax,%eax
c002ad79:	29 d8                	sub    %ebx,%eax
c002ad7b:	8d 68 1e             	lea    0x1e(%eax),%ebp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002ad7e:	55                   	push   %ebp
c002ad7f:	68 bb f4 02 c0       	push   $0xc002f4bb
c002ad84:	6a 10                	push   $0x10
c002ad86:	56                   	push   %esi
c002ad87:	e8 d6 b9 ff ff       	call   c0026762 <snprintf>
      thread_create (name, priority, priority_condvar_thread, NULL);
c002ad8c:	6a 00                	push   $0x0
c002ad8e:	68 ad ac 02 c0       	push   $0xc002acad
c002ad93:	55                   	push   %ebp
c002ad94:	56                   	push   %esi
c002ad95:	e8 27 64 ff ff       	call   c00211c1 <thread_create>
c002ad9a:	83 c3 01             	add    $0x1,%ebx

  lock_init (&lock);
  cond_init (&condition);

  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002ad9d:	83 c4 20             	add    $0x20,%esp
c002ada0:	83 fb 11             	cmp    $0x11,%ebx
c002ada3:	75 c1                	jne    c002ad66 <test_priority_condvar+0x62>
c002ada5:	bb 0a 00 00 00       	mov    $0xa,%ebx
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
    {
      lock_acquire (&lock);
c002adaa:	83 ec 0c             	sub    $0xc,%esp
c002adad:	68 a0 96 03 c0       	push   $0xc00396a0
c002adb2:	e8 08 7c ff ff       	call   c00229bf <lock_acquire>
      msg ("Signaling...");
c002adb7:	c7 04 24 5c fd 02 c0 	movl   $0xc002fd5c,(%esp)
c002adbe:	e8 d3 e9 ff ff       	call   c0029796 <msg>
      cond_signal (&condition, &lock);
c002adc3:	83 c4 08             	add    $0x8,%esp
c002adc6:	68 a0 96 03 c0       	push   $0xc00396a0
c002adcb:	68 80 96 03 c0       	push   $0xc0039680
c002add0:	e8 23 80 ff ff       	call   c0022df8 <cond_signal>
      lock_release (&lock);
c002add5:	c7 04 24 a0 96 03 c0 	movl   $0xc00396a0,(%esp)
c002addc:	e8 6e 7d ff ff       	call   c0022b4f <lock_release>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002ade1:	83 c4 10             	add    $0x10,%esp
c002ade4:	83 eb 01             	sub    $0x1,%ebx
c002ade7:	75 c1                	jne    c002adaa <test_priority_condvar+0xa6>
      lock_acquire (&lock);
      msg ("Signaling...");
      cond_signal (&condition, &lock);
      lock_release (&lock);
    }
}
c002ade9:	83 c4 1c             	add    $0x1c,%esp
c002adec:	5b                   	pop    %ebx
c002aded:	5e                   	pop    %esi
c002adee:	5f                   	pop    %edi
c002adef:	5d                   	pop    %ebp
c002adf0:	c3                   	ret    

c002adf1 <interloper_thread_func>:
                                         thread_get_priority ());
}

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002adf1:	83 ec 0c             	sub    $0xc,%esp
  msg ("%s finished.", thread_name ());
c002adf4:	e8 02 5f ff ff       	call   c0020cfb <thread_name>
c002adf9:	83 ec 08             	sub    $0x8,%esp
c002adfc:	50                   	push   %eax
c002adfd:	68 93 fd 02 c0       	push   $0xc002fd93
c002ae02:	e8 8f e9 ff ff       	call   c0029796 <msg>
}
c002ae07:	83 c4 1c             	add    $0x1c,%esp
c002ae0a:	c3                   	ret    

c002ae0b <donor_thread_func>:
                                         thread_get_priority ());
}

static void
donor_thread_func (void *locks_) 
{
c002ae0b:	56                   	push   %esi
c002ae0c:	53                   	push   %ebx
c002ae0d:	83 ec 04             	sub    $0x4,%esp
c002ae10:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  struct lock_pair *locks = locks_;

  if (locks->first)
c002ae14:	8b 43 04             	mov    0x4(%ebx),%eax
c002ae17:	85 c0                	test   %eax,%eax
c002ae19:	74 0c                	je     c002ae27 <donor_thread_func+0x1c>
    lock_acquire (locks->first);
c002ae1b:	83 ec 0c             	sub    $0xc,%esp
c002ae1e:	50                   	push   %eax
c002ae1f:	e8 9b 7b ff ff       	call   c00229bf <lock_acquire>
c002ae24:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002ae27:	83 ec 0c             	sub    $0xc,%esp
c002ae2a:	ff 33                	pushl  (%ebx)
c002ae2c:	e8 8e 7b ff ff       	call   c00229bf <lock_acquire>
  msg ("%s got lock", thread_name ());
c002ae31:	e8 c5 5e ff ff       	call   c0020cfb <thread_name>
c002ae36:	83 c4 08             	add    $0x8,%esp
c002ae39:	50                   	push   %eax
c002ae3a:	68 a0 fd 02 c0       	push   $0xc002fda0
c002ae3f:	e8 52 e9 ff ff       	call   c0029796 <msg>

  lock_release (locks->second);
c002ae44:	83 c4 04             	add    $0x4,%esp
c002ae47:	ff 33                	pushl  (%ebx)
c002ae49:	e8 01 7d ff ff       	call   c0022b4f <lock_release>
  msg ("%s should have priority %d. Actual priority: %d", 
c002ae4e:	e8 3d 5f ff ff       	call   c0020d90 <thread_get_priority>
c002ae53:	89 c6                	mov    %eax,%esi
c002ae55:	e8 a1 5e ff ff       	call   c0020cfb <thread_name>
c002ae5a:	56                   	push   %esi
c002ae5b:	6a 15                	push   $0x15
c002ae5d:	50                   	push   %eax
c002ae5e:	68 c8 fd 02 c0       	push   $0xc002fdc8
c002ae63:	e8 2e e9 ff ff       	call   c0029796 <msg>
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002ae68:	8b 43 04             	mov    0x4(%ebx),%eax
c002ae6b:	83 c4 20             	add    $0x20,%esp
c002ae6e:	85 c0                	test   %eax,%eax
c002ae70:	74 0c                	je     c002ae7e <donor_thread_func+0x73>
    lock_release (locks->first);
c002ae72:	83 ec 0c             	sub    $0xc,%esp
c002ae75:	50                   	push   %eax
c002ae76:	e8 d4 7c ff ff       	call   c0022b4f <lock_release>
c002ae7b:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002ae7e:	e8 0d 5f ff ff       	call   c0020d90 <thread_get_priority>
c002ae83:	89 c3                	mov    %eax,%ebx
c002ae85:	e8 71 5e ff ff       	call   c0020cfb <thread_name>
c002ae8a:	83 ec 04             	sub    $0x4,%esp
c002ae8d:	53                   	push   %ebx
c002ae8e:	50                   	push   %eax
c002ae8f:	68 f8 fd 02 c0       	push   $0xc002fdf8
c002ae94:	e8 fd e8 ff ff       	call   c0029796 <msg>
                                         thread_get_priority ());
}
c002ae99:	83 c4 14             	add    $0x14,%esp
c002ae9c:	5b                   	pop    %ebx
c002ae9d:	5e                   	pop    %esi
c002ae9e:	c3                   	ret    

c002ae9f <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002ae9f:	55                   	push   %ebp
c002aea0:	57                   	push   %edi
c002aea1:	56                   	push   %esi
c002aea2:	53                   	push   %ebx
c002aea3:	81 ec 4c 01 00 00    	sub    $0x14c,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002aea9:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002aeb0:	74 1e                	je     c002aed0 <test_priority_donate_chain+0x31>
c002aeb2:	83 ec 0c             	sub    $0xc,%esp
c002aeb5:	68 b4 f1 02 c0       	push   $0xc002f1b4
c002aeba:	68 3f d2 02 c0       	push   $0xc002d23f
c002aebf:	68 44 d1 02 c0       	push   $0xc002d144
c002aec4:	6a 34                	push   $0x34
c002aec6:	68 18 fe 02 c0       	push   $0xc002fe18
c002aecb:	e8 fd cd ff ff       	call   c0027ccd <debug_panic>

  thread_set_priority (PRI_MIN);
c002aed0:	83 ec 0c             	sub    $0xc,%esp
c002aed3:	6a 00                	push   $0x0
c002aed5:	e8 1b 64 ff ff       	call   c00212f5 <thread_set_priority>
c002aeda:	8d 5c 24 70          	lea    0x70(%esp),%ebx
c002aede:	8d b4 24 50 01 00 00 	lea    0x150(%esp),%esi
c002aee5:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
    lock_init (&locks[i]);
c002aee8:	83 ec 0c             	sub    $0xc,%esp
c002aeeb:	53                   	push   %ebx
c002aeec:	e8 4c 7a ff ff       	call   c002293d <lock_init>
c002aef1:	83 c3 20             	add    $0x20,%ebx
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  thread_set_priority (PRI_MIN);

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002aef4:	83 c4 10             	add    $0x10,%esp
c002aef7:	39 f3                	cmp    %esi,%ebx
c002aef9:	75 ed                	jne    c002aee8 <test_priority_donate_chain+0x49>
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
c002aefb:	83 ec 0c             	sub    $0xc,%esp
c002aefe:	8d 44 24 6c          	lea    0x6c(%esp),%eax
c002af02:	50                   	push   %eax
c002af03:	e8 b7 7a ff ff       	call   c00229bf <lock_acquire>
  msg ("%s got lock.", thread_name ());
c002af08:	e8 ee 5d ff ff       	call   c0020cfb <thread_name>
c002af0d:	83 c4 08             	add    $0x8,%esp
c002af10:	50                   	push   %eax
c002af11:	68 ac fd 02 c0       	push   $0xc002fdac
c002af16:	e8 7b e8 ff ff       	call   c0029796 <msg>
c002af1b:	8d bc 24 90 00 00 00 	lea    0x90(%esp),%edi
c002af22:	8d 74 24 38          	lea    0x38(%esp),%esi
c002af26:	83 c4 10             	add    $0x10,%esp
c002af29:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c002af30:	00 

  for (i = 1; i < NESTING_DEPTH; i++)
c002af31:	bb 01 00 00 00       	mov    $0x1,%ebx
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002af36:	8d 6c 24 10          	lea    0x10(%esp),%ebp
c002af3a:	53                   	push   %ebx
c002af3b:	68 d1 f1 02 c0       	push   $0xc002f1d1
c002af40:	6a 10                	push   $0x10
c002af42:	55                   	push   %ebp
c002af43:	e8 1a b8 ff ff       	call   c0026762 <snprintf>
      thread_priority = PRI_MIN + i * 3;
c002af48:	8b 44 24 14          	mov    0x14(%esp),%eax
c002af4c:	89 c2                	mov    %eax,%edx
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002af4e:	83 c4 10             	add    $0x10,%esp
c002af51:	83 fb 06             	cmp    $0x6,%ebx
c002af54:	b9 00 00 00 00       	mov    $0x0,%ecx
c002af59:	0f 4e cf             	cmovle %edi,%ecx
c002af5c:	89 4e 04             	mov    %ecx,0x4(%esi)
      lock_pairs[i].second = locks + i - 1;
c002af5f:	8d 47 e0             	lea    -0x20(%edi),%eax
c002af62:	89 06                	mov    %eax,(%esi)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002af64:	56                   	push   %esi
c002af65:	68 0b ae 02 c0       	push   $0xc002ae0b
c002af6a:	89 54 24 10          	mov    %edx,0x10(%esp)
c002af6e:	52                   	push   %edx
c002af6f:	55                   	push   %ebp
c002af70:	e8 4c 62 ff ff       	call   c00211c1 <thread_create>
      msg ("%s should have priority %d.  Actual priority: %d.",
c002af75:	e8 16 5e ff ff       	call   c0020d90 <thread_get_priority>
c002af7a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002af7e:	e8 78 5d ff ff       	call   c0020cfb <thread_name>
c002af83:	ff 74 24 1c          	pushl  0x1c(%esp)
c002af87:	ff 74 24 1c          	pushl  0x1c(%esp)
c002af8b:	50                   	push   %eax
c002af8c:	68 44 fe 02 c0       	push   $0xc002fe44
c002af91:	e8 00 e8 ff ff       	call   c0029796 <msg>
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002af96:	83 c4 20             	add    $0x20,%esp
c002af99:	53                   	push   %ebx
c002af9a:	68 b9 fd 02 c0       	push   $0xc002fdb9
c002af9f:	6a 10                	push   $0x10
c002afa1:	55                   	push   %ebp
c002afa2:	e8 bb b7 ff ff       	call   c0026762 <snprintf>
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002afa7:	6a 00                	push   $0x0
c002afa9:	68 f1 ad 02 c0       	push   $0xc002adf1
c002afae:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002afb2:	83 e8 01             	sub    $0x1,%eax
c002afb5:	50                   	push   %eax
c002afb6:	55                   	push   %ebp
c002afb7:	e8 05 62 ff ff       	call   c00211c1 <thread_create>
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
  msg ("%s got lock.", thread_name ());

  for (i = 1; i < NESTING_DEPTH; i++)
c002afbc:	83 c3 01             	add    $0x1,%ebx
c002afbf:	83 c7 20             	add    $0x20,%edi
c002afc2:	83 c6 08             	add    $0x8,%esi
c002afc5:	83 44 24 24 03       	addl   $0x3,0x24(%esp)
c002afca:	83 c4 20             	add    $0x20,%esp
c002afcd:	83 fb 08             	cmp    $0x8,%ebx
c002afd0:	0f 85 64 ff ff ff    	jne    c002af3a <test_priority_donate_chain+0x9b>

      snprintf (name, sizeof name, "interloper %d", i);
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
    }

  lock_release (&locks[0]);
c002afd6:	83 ec 0c             	sub    $0xc,%esp
c002afd9:	8d 44 24 6c          	lea    0x6c(%esp),%eax
c002afdd:	50                   	push   %eax
c002afde:	e8 6c 7b ff ff       	call   c0022b4f <lock_release>
  msg ("%s finishing with priority %d.", thread_name (),
c002afe3:	e8 a8 5d ff ff       	call   c0020d90 <thread_get_priority>
c002afe8:	89 c3                	mov    %eax,%ebx
c002afea:	e8 0c 5d ff ff       	call   c0020cfb <thread_name>
c002afef:	83 c4 0c             	add    $0xc,%esp
c002aff2:	53                   	push   %ebx
c002aff3:	50                   	push   %eax
c002aff4:	68 f8 fd 02 c0       	push   $0xc002fdf8
c002aff9:	e8 98 e7 ff ff       	call   c0029796 <msg>
                                         thread_get_priority ());
}
c002affe:	81 c4 5c 01 00 00    	add    $0x15c,%esp
c002b004:	5b                   	pop    %ebx
c002b005:	5e                   	pop    %esi
c002b006:	5f                   	pop    %edi
c002b007:	5d                   	pop    %ebp
c002b008:	c3                   	ret    

c002b009 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002b009:	55                   	push   %ebp
c002b00a:	57                   	push   %edi
c002b00b:	56                   	push   %esi
c002b00c:	53                   	push   %ebx
c002b00d:	83 ec 0c             	sub    $0xc,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002b010:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b017:	75 1e                	jne    c002b037 <test_mlfqs_load_1+0x2e>
c002b019:	83 ec 0c             	sub    $0xc,%esp
c002b01c:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b021:	68 3f d2 02 c0       	push   $0xc002d23f
c002b026:	68 60 d1 02 c0       	push   $0xc002d160
c002b02b:	6a 18                	push   $0x18
c002b02d:	68 a0 fe 02 c0       	push   $0xc002fea0
c002b032:	e8 96 cc ff ff       	call   c0027ccd <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002b037:	83 ec 0c             	sub    $0xc,%esp
c002b03a:	68 c4 fe 02 c0       	push   $0xc002fec4
c002b03f:	e8 52 e7 ff ff       	call   c0029796 <msg>

  start_time = timer_ticks ();
c002b044:	e8 f4 89 ff ff       	call   c0023a3d <timer_ticks>
c002b049:	89 c6                	mov    %eax,%esi
c002b04b:	89 d7                	mov    %edx,%edi
c002b04d:	83 c4 10             	add    $0x10,%esp
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002b050:	e8 59 5d ff ff       	call   c0020dae <thread_get_load_avg>
c002b055:	89 c3                	mov    %eax,%ebx
      ASSERT (load_avg >= 0);
c002b057:	85 c0                	test   %eax,%eax
c002b059:	79 1e                	jns    c002b079 <test_mlfqs_load_1+0x70>
c002b05b:	83 ec 0c             	sub    $0xc,%esp
c002b05e:	68 76 fe 02 c0       	push   $0xc002fe76
c002b063:	68 3f d2 02 c0       	push   $0xc002d23f
c002b068:	68 60 d1 02 c0       	push   $0xc002d160
c002b06d:	6a 20                	push   $0x20
c002b06f:	68 a0 fe 02 c0       	push   $0xc002fea0
c002b074:	e8 54 cc ff ff       	call   c0027ccd <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002b079:	83 ec 08             	sub    $0x8,%esp
c002b07c:	57                   	push   %edi
c002b07d:	56                   	push   %esi
c002b07e:	e8 e3 89 ff ff       	call   c0023a66 <timer_elapsed>
c002b083:	6a 00                	push   $0x0
c002b085:	6a 64                	push   $0x64
c002b087:	52                   	push   %edx
c002b088:	50                   	push   %eax
c002b089:	e8 73 c6 ff ff       	call   c0027701 <__divdi3>
c002b08e:	89 c5                	mov    %eax,%ebp
      if (load_avg > 100)
c002b090:	83 c4 20             	add    $0x20,%esp
c002b093:	83 fb 64             	cmp    $0x64,%ebx
c002b096:	7e 28                	jle    c002b0c0 <test_mlfqs_load_1+0xb7>
        fail ("load average is %d.%02d "
c002b098:	50                   	push   %eax
c002b099:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b09e:	f7 eb                	imul   %ebx
c002b0a0:	c1 fa 05             	sar    $0x5,%edx
c002b0a3:	89 d8                	mov    %ebx,%eax
c002b0a5:	c1 f8 1f             	sar    $0x1f,%eax
c002b0a8:	29 c2                	sub    %eax,%edx
c002b0aa:	6b c2 64             	imul   $0x64,%edx,%eax
c002b0ad:	29 c3                	sub    %eax,%ebx
c002b0af:	53                   	push   %ebx
c002b0b0:	52                   	push   %edx
c002b0b1:	68 f4 fe 02 c0       	push   $0xc002fef4
c002b0b6:	e8 81 e7 ff ff       	call   c002983c <fail>
c002b0bb:	83 c4 10             	add    $0x10,%esp
c002b0be:	eb 90                	jmp    c002b050 <test_mlfqs_load_1+0x47>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002b0c0:	83 fb 32             	cmp    $0x32,%ebx
c002b0c3:	7f 1a                	jg     c002b0df <test_mlfqs_load_1+0xd6>
        break;
      else if (elapsed > 45)
c002b0c5:	83 f8 2d             	cmp    $0x2d,%eax
c002b0c8:	7e 86                	jle    c002b050 <test_mlfqs_load_1+0x47>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002b0ca:	83 ec 0c             	sub    $0xc,%esp
c002b0cd:	68 40 ff 02 c0       	push   $0xc002ff40
c002b0d2:	e8 65 e7 ff ff       	call   c002983c <fail>
c002b0d7:	83 c4 10             	add    $0x10,%esp
c002b0da:	e9 71 ff ff ff       	jmp    c002b050 <test_mlfqs_load_1+0x47>
    }

  if (elapsed < 38)
c002b0df:	83 f8 25             	cmp    $0x25,%eax
c002b0e2:	7f 11                	jg     c002b0f5 <test_mlfqs_load_1+0xec>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002b0e4:	83 ec 08             	sub    $0x8,%esp
c002b0e7:	50                   	push   %eax
c002b0e8:	68 78 ff 02 c0       	push   $0xc002ff78
c002b0ed:	e8 4a e7 ff ff       	call   c002983c <fail>
c002b0f2:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002b0f5:	83 ec 08             	sub    $0x8,%esp
c002b0f8:	55                   	push   %ebp
c002b0f9:	68 ac ff 02 c0       	push   $0xc002ffac
c002b0fe:	e8 93 e6 ff ff       	call   c0029796 <msg>

  msg ("sleeping for another 10 seconds, please wait...");
c002b103:	c7 04 24 d8 ff 02 c0 	movl   $0xc002ffd8,(%esp)
c002b10a:	e8 87 e6 ff ff       	call   c0029796 <msg>
  timer_sleep (TIMER_FREQ * 10);
c002b10f:	83 c4 08             	add    $0x8,%esp
c002b112:	6a 00                	push   $0x0
c002b114:	68 e8 03 00 00       	push   $0x3e8
c002b119:	e8 64 89 ff ff       	call   c0023a82 <timer_sleep>

  load_avg = thread_get_load_avg ();
c002b11e:	e8 8b 5c ff ff       	call   c0020dae <thread_get_load_avg>
c002b123:	89 c3                	mov    %eax,%ebx
  if (load_avg < 0)
c002b125:	83 c4 10             	add    $0x10,%esp
c002b128:	85 c0                	test   %eax,%eax
c002b12a:	79 10                	jns    c002b13c <test_mlfqs_load_1+0x133>
    fail ("load average fell below 0");
c002b12c:	83 ec 0c             	sub    $0xc,%esp
c002b12f:	68 84 fe 02 c0       	push   $0xc002fe84
c002b134:	e8 03 e7 ff ff       	call   c002983c <fail>
c002b139:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002b13c:	83 fb 32             	cmp    $0x32,%ebx
c002b13f:	7e 10                	jle    c002b151 <test_mlfqs_load_1+0x148>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002b141:	83 ec 0c             	sub    $0xc,%esp
c002b144:	68 08 00 03 c0       	push   $0xc0030008
c002b149:	e8 ee e6 ff ff       	call   c002983c <fail>
c002b14e:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002b151:	83 ec 04             	sub    $0x4,%esp
c002b154:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002b159:	89 d8                	mov    %ebx,%eax
c002b15b:	f7 ea                	imul   %edx
c002b15d:	c1 fa 05             	sar    $0x5,%edx
c002b160:	89 d8                	mov    %ebx,%eax
c002b162:	c1 f8 1f             	sar    $0x1f,%eax
c002b165:	29 c2                	sub    %eax,%edx
c002b167:	6b c2 64             	imul   $0x64,%edx,%eax
c002b16a:	29 c3                	sub    %eax,%ebx
c002b16c:	53                   	push   %ebx
c002b16d:	52                   	push   %edx
c002b16e:	68 40 00 03 c0       	push   $0xc0030040
c002b173:	e8 1e e6 ff ff       	call   c0029796 <msg>
       load_avg / 100, load_avg % 100);

  pass ();
c002b178:	e8 05 e7 ff ff       	call   c0029882 <pass>
}
c002b17d:	83 c4 1c             	add    $0x1c,%esp
c002b180:	5b                   	pop    %ebx
c002b181:	5e                   	pop    %esi
c002b182:	5f                   	pop    %edi
c002b183:	5d                   	pop    %ebp
c002b184:	c3                   	ret    

c002b185 <load_thread>:
    }
}

static void
load_thread (void *aux UNUSED) 
{
c002b185:	53                   	push   %ebx
c002b186:	83 ec 14             	sub    $0x14,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
c002b189:	6a 14                	push   $0x14
c002b18b:	e8 a0 61 ff ff       	call   c0021330 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002b190:	83 c4 08             	add    $0x8,%esp
c002b193:	ff 35 c4 96 03 c0    	pushl  0xc00396c4
c002b199:	ff 35 c0 96 03 c0    	pushl  0xc00396c0
c002b19f:	e8 c2 88 ff ff       	call   c0023a66 <timer_elapsed>
c002b1a4:	83 c4 08             	add    $0x8,%esp
c002b1a7:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002b1ac:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b1b1:	29 c1                	sub    %eax,%ecx
c002b1b3:	19 d3                	sbb    %edx,%ebx
c002b1b5:	53                   	push   %ebx
c002b1b6:	51                   	push   %ecx
c002b1b7:	e8 c6 88 ff ff       	call   c0023a82 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002b1bc:	83 c4 10             	add    $0x10,%esp
c002b1bf:	83 ec 08             	sub    $0x8,%esp
c002b1c2:	ff 35 c4 96 03 c0    	pushl  0xc00396c4
c002b1c8:	ff 35 c0 96 03 c0    	pushl  0xc00396c0
c002b1ce:	e8 93 88 ff ff       	call   c0023a66 <timer_elapsed>
c002b1d3:	83 c4 10             	add    $0x10,%esp
c002b1d6:	85 d2                	test   %edx,%edx
c002b1d8:	78 e5                	js     c002b1bf <load_thread+0x3a>
c002b1da:	85 d2                	test   %edx,%edx
c002b1dc:	7f 07                	jg     c002b1e5 <load_thread+0x60>
c002b1de:	3d 57 1b 00 00       	cmp    $0x1b57,%eax
c002b1e3:	76 da                	jbe    c002b1bf <load_thread+0x3a>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002b1e5:	83 ec 08             	sub    $0x8,%esp
c002b1e8:	ff 35 c4 96 03 c0    	pushl  0xc00396c4
c002b1ee:	ff 35 c0 96 03 c0    	pushl  0xc00396c0
c002b1f4:	e8 6d 88 ff ff       	call   c0023a66 <timer_elapsed>
c002b1f9:	83 c4 08             	add    $0x8,%esp
c002b1fc:	b9 c8 32 00 00       	mov    $0x32c8,%ecx
c002b201:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b206:	29 c1                	sub    %eax,%ecx
c002b208:	19 d3                	sbb    %edx,%ebx
c002b20a:	53                   	push   %ebx
c002b20b:	51                   	push   %ecx
c002b20c:	e8 71 88 ff ff       	call   c0023a82 <timer_sleep>
}
c002b211:	83 c4 18             	add    $0x18,%esp
c002b214:	5b                   	pop    %ebx
c002b215:	c3                   	ret    

c002b216 <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002b216:	55                   	push   %ebp
c002b217:	57                   	push   %edi
c002b218:	56                   	push   %esi
c002b219:	53                   	push   %ebx
c002b21a:	83 ec 2c             	sub    $0x2c,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002b21d:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b224:	75 1e                	jne    c002b244 <test_mlfqs_load_60+0x2e>
c002b226:	83 ec 0c             	sub    $0xc,%esp
c002b229:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b22e:	68 3f d2 02 c0       	push   $0xc002d23f
c002b233:	68 74 d1 02 c0       	push   $0xc002d174
c002b238:	6a 77                	push   $0x77
c002b23a:	68 78 00 03 c0       	push   $0xc0030078
c002b23f:	e8 89 ca ff ff       	call   c0027ccd <debug_panic>

  start_time = timer_ticks ();
c002b244:	e8 f4 87 ff ff       	call   c0023a3d <timer_ticks>
c002b249:	a3 c0 96 03 c0       	mov    %eax,0xc00396c0
c002b24e:	89 15 c4 96 03 c0    	mov    %edx,0xc00396c4
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002b254:	83 ec 08             	sub    $0x8,%esp
c002b257:	6a 3c                	push   $0x3c
c002b259:	68 9c 00 03 c0       	push   $0xc003009c
c002b25e:	e8 33 e5 ff ff       	call   c0029796 <msg>
c002b263:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002b266:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002b26b:	8d 74 24 10          	lea    0x10(%esp),%esi
c002b26f:	53                   	push   %ebx
c002b270:	68 6e 00 03 c0       	push   $0xc003006e
c002b275:	6a 10                	push   $0x10
c002b277:	56                   	push   %esi
c002b278:	e8 e5 b4 ff ff       	call   c0026762 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002b27d:	6a 00                	push   $0x0
c002b27f:	68 85 b1 02 c0       	push   $0xc002b185
c002b284:	6a 1f                	push   $0x1f
c002b286:	56                   	push   %esi
c002b287:	e8 35 5f ff ff       	call   c00211c1 <thread_create>
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d niced load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002b28c:	83 c3 01             	add    $0x1,%ebx
c002b28f:	83 c4 20             	add    $0x20,%esp
c002b292:	83 fb 3c             	cmp    $0x3c,%ebx
c002b295:	75 d8                	jne    c002b26f <test_mlfqs_load_60+0x59>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002b297:	83 ec 08             	sub    $0x8,%esp
c002b29a:	ff 35 c4 96 03 c0    	pushl  0xc00396c4
c002b2a0:	ff 35 c0 96 03 c0    	pushl  0xc00396c0
c002b2a6:	e8 bb 87 ff ff       	call   c0023a66 <timer_elapsed>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
c002b2ab:	6a 00                	push   $0x0
c002b2ad:	6a 64                	push   $0x64
c002b2af:	52                   	push   %edx
c002b2b0:	50                   	push   %eax
c002b2b1:	e8 4b c4 ff ff       	call   c0027701 <__divdi3>
c002b2b6:	83 c4 1c             	add    $0x1c,%esp
c002b2b9:	52                   	push   %edx
c002b2ba:	50                   	push   %eax
c002b2bb:	68 c0 00 03 c0       	push   $0xc00300c0
c002b2c0:	e8 d1 e4 ff ff       	call   c0029796 <msg>
c002b2c5:	83 c4 10             	add    $0x10,%esp
c002b2c8:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b2cd:	be e8 03 00 00       	mov    $0x3e8,%esi
c002b2d2:	bf 00 00 00 00       	mov    $0x0,%edi
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
c002b2d7:	bd 1f 85 eb 51       	mov    $0x51eb851f,%ebp
c002b2dc:	89 74 24 08          	mov    %esi,0x8(%esp)
c002b2e0:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002b2e4:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b2e8:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002b2ec:	03 05 c0 96 03 c0    	add    0xc00396c0,%eax
c002b2f2:	13 15 c4 96 03 c0    	adc    0xc00396c4,%edx
c002b2f8:	89 c6                	mov    %eax,%esi
c002b2fa:	89 d7                	mov    %edx,%edi
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002b2fc:	e8 3c 87 ff ff       	call   c0023a3d <timer_ticks>
c002b301:	83 ec 08             	sub    $0x8,%esp
c002b304:	29 c6                	sub    %eax,%esi
c002b306:	19 d7                	sbb    %edx,%edi
c002b308:	57                   	push   %edi
c002b309:	56                   	push   %esi
c002b30a:	e8 73 87 ff ff       	call   c0023a82 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002b30f:	e8 9a 5a ff ff       	call   c0020dae <thread_get_load_avg>
c002b314:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002b316:	f7 ed                	imul   %ebp
c002b318:	c1 fa 05             	sar    $0x5,%edx
c002b31b:	89 c8                	mov    %ecx,%eax
c002b31d:	c1 f8 1f             	sar    $0x1f,%eax
c002b320:	29 c2                	sub    %eax,%edx
c002b322:	6b c2 64             	imul   $0x64,%edx,%eax
c002b325:	29 c1                	sub    %eax,%ecx
c002b327:	51                   	push   %ecx
c002b328:	52                   	push   %edx
c002b329:	53                   	push   %ebx
c002b32a:	68 e4 00 03 c0       	push   $0xc00300e4
c002b32f:	e8 62 e4 ff ff       	call   c0029796 <msg>
c002b334:	81 44 24 28 c8 00 00 	addl   $0xc8,0x28(%esp)
c002b33b:	00 
c002b33c:	83 54 24 2c 00       	adcl   $0x0,0x2c(%esp)
c002b341:	83 c3 02             	add    $0x2,%ebx
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002b344:	83 c4 20             	add    $0x20,%esp
c002b347:	81 fb b4 00 00 00    	cmp    $0xb4,%ebx
c002b34d:	75 95                	jne    c002b2e4 <test_mlfqs_load_60+0xce>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002b34f:	83 c4 2c             	add    $0x2c,%esp
c002b352:	5b                   	pop    %ebx
c002b353:	5e                   	pop    %esi
c002b354:	5f                   	pop    %edi
c002b355:	5d                   	pop    %ebp
c002b356:	c3                   	ret    

c002b357 <load_thread>:
    }
}

static void
load_thread (void *seq_no_) 
{
c002b357:	57                   	push   %edi
c002b358:	56                   	push   %esi
c002b359:	53                   	push   %ebx
  int seq_no = (int) seq_no_;
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002b35a:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b35e:	8d 70 0a             	lea    0xa(%eax),%esi
c002b361:	6b f6 64             	imul   $0x64,%esi,%esi
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002b364:	8d 9e 70 17 00 00    	lea    0x1770(%esi),%ebx
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002b36a:	83 ec 08             	sub    $0x8,%esp
c002b36d:	ff 35 cc 96 03 c0    	pushl  0xc00396cc
c002b373:	ff 35 c8 96 03 c0    	pushl  0xc00396c8
c002b379:	e8 e8 86 ff ff       	call   c0023a66 <timer_elapsed>
c002b37e:	83 c4 08             	add    $0x8,%esp
c002b381:	89 f7                	mov    %esi,%edi
c002b383:	c1 ff 1f             	sar    $0x1f,%edi
c002b386:	29 c6                	sub    %eax,%esi
c002b388:	19 d7                	sbb    %edx,%edi
c002b38a:	57                   	push   %edi
c002b38b:	56                   	push   %esi
c002b38c:	e8 f1 86 ff ff       	call   c0023a82 <timer_sleep>
  while (timer_elapsed (start_time) < spin_time)
c002b391:	83 c4 10             	add    $0x10,%esp
c002b394:	89 df                	mov    %ebx,%edi
c002b396:	c1 ff 1f             	sar    $0x1f,%edi
c002b399:	83 ec 08             	sub    $0x8,%esp
c002b39c:	ff 35 cc 96 03 c0    	pushl  0xc00396cc
c002b3a2:	ff 35 c8 96 03 c0    	pushl  0xc00396c8
c002b3a8:	e8 b9 86 ff ff       	call   c0023a66 <timer_elapsed>
c002b3ad:	83 c4 10             	add    $0x10,%esp
c002b3b0:	39 fa                	cmp    %edi,%edx
c002b3b2:	7c e5                	jl     c002b399 <load_thread+0x42>
c002b3b4:	7f 04                	jg     c002b3ba <load_thread+0x63>
c002b3b6:	39 d8                	cmp    %ebx,%eax
c002b3b8:	72 df                	jb     c002b399 <load_thread+0x42>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002b3ba:	83 ec 08             	sub    $0x8,%esp
c002b3bd:	ff 35 cc 96 03 c0    	pushl  0xc00396cc
c002b3c3:	ff 35 c8 96 03 c0    	pushl  0xc00396c8
c002b3c9:	e8 98 86 ff ff       	call   c0023a66 <timer_elapsed>
c002b3ce:	83 c4 08             	add    $0x8,%esp
c002b3d1:	b9 e0 2e 00 00       	mov    $0x2ee0,%ecx
c002b3d6:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b3db:	29 c1                	sub    %eax,%ecx
c002b3dd:	19 d3                	sbb    %edx,%ebx
c002b3df:	53                   	push   %ebx
c002b3e0:	51                   	push   %ecx
c002b3e1:	e8 9c 86 ff ff       	call   c0023a82 <timer_sleep>
}
c002b3e6:	83 c4 10             	add    $0x10,%esp
c002b3e9:	5b                   	pop    %ebx
c002b3ea:	5e                   	pop    %esi
c002b3eb:	5f                   	pop    %edi
c002b3ec:	c3                   	ret    

c002b3ed <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002b3ed:	55                   	push   %ebp
c002b3ee:	57                   	push   %edi
c002b3ef:	56                   	push   %esi
c002b3f0:	53                   	push   %ebx
c002b3f1:	83 ec 2c             	sub    $0x2c,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002b3f4:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b3fb:	75 21                	jne    c002b41e <test_mlfqs_load_avg+0x31>
c002b3fd:	83 ec 0c             	sub    $0xc,%esp
c002b400:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b405:	68 3f d2 02 c0       	push   $0xc002d23f
c002b40a:	68 88 d1 02 c0       	push   $0xc002d188
c002b40f:	68 82 00 00 00       	push   $0x82
c002b414:	68 28 01 03 c0       	push   $0xc0030128
c002b419:	e8 af c8 ff ff       	call   c0027ccd <debug_panic>

  start_time = timer_ticks ();
c002b41e:	e8 1a 86 ff ff       	call   c0023a3d <timer_ticks>
c002b423:	a3 c8 96 03 c0       	mov    %eax,0xc00396c8
c002b428:	89 15 cc 96 03 c0    	mov    %edx,0xc00396cc
  msg ("Starting %d load threads...", THREAD_CNT);
c002b42e:	83 ec 08             	sub    $0x8,%esp
c002b431:	6a 3c                	push   $0x3c
c002b433:	68 0c 01 03 c0       	push   $0xc003010c
c002b438:	e8 59 e3 ff ff       	call   c0029796 <msg>
c002b43d:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002b440:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002b445:	8d 74 24 10          	lea    0x10(%esp),%esi
c002b449:	53                   	push   %ebx
c002b44a:	68 6e 00 03 c0       	push   $0xc003006e
c002b44f:	6a 10                	push   $0x10
c002b451:	56                   	push   %esi
c002b452:	e8 0b b3 ff ff       	call   c0026762 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002b457:	53                   	push   %ebx
c002b458:	68 57 b3 02 c0       	push   $0xc002b357
c002b45d:	6a 1f                	push   $0x1f
c002b45f:	56                   	push   %esi
c002b460:	e8 5c 5d ff ff       	call   c00211c1 <thread_create>
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002b465:	83 c3 01             	add    $0x1,%ebx
c002b468:	83 c4 20             	add    $0x20,%esp
c002b46b:	83 fb 3c             	cmp    $0x3c,%ebx
c002b46e:	75 d9                	jne    c002b449 <test_mlfqs_load_avg+0x5c>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002b470:	83 ec 08             	sub    $0x8,%esp
c002b473:	ff 35 cc 96 03 c0    	pushl  0xc00396cc
c002b479:	ff 35 c8 96 03 c0    	pushl  0xc00396c8
c002b47f:	e8 e2 85 ff ff       	call   c0023a66 <timer_elapsed>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
c002b484:	6a 00                	push   $0x0
c002b486:	6a 64                	push   $0x64
c002b488:	52                   	push   %edx
c002b489:	50                   	push   %eax
c002b48a:	e8 72 c2 ff ff       	call   c0027701 <__divdi3>
c002b48f:	83 c4 1c             	add    $0x1c,%esp
c002b492:	52                   	push   %edx
c002b493:	50                   	push   %eax
c002b494:	68 c0 00 03 c0       	push   $0xc00300c0
c002b499:	e8 f8 e2 ff ff       	call   c0029796 <msg>
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);
c002b49e:	c7 04 24 ec ff ff ff 	movl   $0xffffffec,(%esp)
c002b4a5:	e8 86 5e ff ff       	call   c0021330 <thread_set_nice>
c002b4aa:	83 c4 10             	add    $0x10,%esp
c002b4ad:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b4b2:	be e8 03 00 00       	mov    $0x3e8,%esi
c002b4b7:	bf 00 00 00 00       	mov    $0x0,%edi
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
c002b4bc:	bd 1f 85 eb 51       	mov    $0x51eb851f,%ebp
c002b4c1:	89 74 24 08          	mov    %esi,0x8(%esp)
c002b4c5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);

  for (i = 0; i < 90; i++) 
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002b4c9:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b4cd:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002b4d1:	03 05 c8 96 03 c0    	add    0xc00396c8,%eax
c002b4d7:	13 15 cc 96 03 c0    	adc    0xc00396cc,%edx
c002b4dd:	89 c6                	mov    %eax,%esi
c002b4df:	89 d7                	mov    %edx,%edi
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002b4e1:	e8 57 85 ff ff       	call   c0023a3d <timer_ticks>
c002b4e6:	83 ec 08             	sub    $0x8,%esp
c002b4e9:	29 c6                	sub    %eax,%esi
c002b4eb:	19 d7                	sbb    %edx,%edi
c002b4ed:	57                   	push   %edi
c002b4ee:	56                   	push   %esi
c002b4ef:	e8 8e 85 ff ff       	call   c0023a82 <timer_sleep>
      load_avg = thread_get_load_avg ();
c002b4f4:	e8 b5 58 ff ff       	call   c0020dae <thread_get_load_avg>
c002b4f9:	89 c1                	mov    %eax,%ecx
      msg ("After %d seconds, load average=%d.%02d.",
c002b4fb:	f7 ed                	imul   %ebp
c002b4fd:	c1 fa 05             	sar    $0x5,%edx
c002b500:	89 c8                	mov    %ecx,%eax
c002b502:	c1 f8 1f             	sar    $0x1f,%eax
c002b505:	29 c2                	sub    %eax,%edx
c002b507:	6b c2 64             	imul   $0x64,%edx,%eax
c002b50a:	29 c1                	sub    %eax,%ecx
c002b50c:	51                   	push   %ecx
c002b50d:	52                   	push   %edx
c002b50e:	53                   	push   %ebx
c002b50f:	68 e4 00 03 c0       	push   $0xc00300e4
c002b514:	e8 7d e2 ff ff       	call   c0029796 <msg>
c002b519:	81 44 24 28 c8 00 00 	addl   $0xc8,0x28(%esp)
c002b520:	00 
c002b521:	83 54 24 2c 00       	adcl   $0x0,0x2c(%esp)
c002b526:	83 c3 02             	add    $0x2,%ebx
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);

  for (i = 0; i < 90; i++) 
c002b529:	83 c4 20             	add    $0x20,%esp
c002b52c:	81 fb b4 00 00 00    	cmp    $0xb4,%ebx
c002b532:	75 95                	jne    c002b4c9 <test_mlfqs_load_avg+0xdc>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002b534:	83 c4 2c             	add    $0x2c,%esp
c002b537:	5b                   	pop    %ebx
c002b538:	5e                   	pop    %esi
c002b539:	5f                   	pop    %edi
c002b53a:	5d                   	pop    %ebp
c002b53b:	c3                   	ret    

c002b53c <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002b53c:	55                   	push   %ebp
c002b53d:	57                   	push   %edi
c002b53e:	56                   	push   %esi
c002b53f:	53                   	push   %ebx
c002b540:	83 ec 1c             	sub    $0x1c,%esp
  int64_t start_time;
  int last_elapsed = 0;
  
  ASSERT (thread_mlfqs);
c002b543:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b54a:	75 1e                	jne    c002b56a <test_mlfqs_recent_1+0x2e>
c002b54c:	83 ec 0c             	sub    $0xc,%esp
c002b54f:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b554:	68 3f d2 02 c0       	push   $0xc002d23f
c002b559:	68 9c d1 02 c0       	push   $0xc002d19c
c002b55e:	6a 73                	push   $0x73
c002b560:	68 50 01 03 c0       	push   $0xc0030150
c002b565:	e8 63 c7 ff ff       	call   c0027ccd <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002b56a:	83 ec 0c             	sub    $0xc,%esp
c002b56d:	68 78 01 03 c0       	push   $0xc0030178
c002b572:	e8 1f e2 ff ff       	call   c0029796 <msg>
      start_time = timer_ticks ();
c002b577:	e8 c1 84 ff ff       	call   c0023a3d <timer_ticks>
c002b57c:	89 c6                	mov    %eax,%esi
c002b57e:	89 d7                	mov    %edx,%edi
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002b580:	83 c0 63             	add    $0x63,%eax
c002b583:	83 d2 00             	adc    $0x0,%edx
c002b586:	6a 00                	push   $0x0
c002b588:	6a 64                	push   $0x64
c002b58a:	52                   	push   %edx
c002b58b:	50                   	push   %eax
c002b58c:	e8 70 c1 ff ff       	call   c0027701 <__divdi3>
c002b591:	83 c4 18             	add    $0x18,%esp
c002b594:	29 f0                	sub    %esi,%eax
c002b596:	19 fa                	sbb    %edi,%edx
c002b598:	05 e8 03 00 00       	add    $0x3e8,%eax
c002b59d:	83 d2 00             	adc    $0x0,%edx
c002b5a0:	52                   	push   %edx
c002b5a1:	50                   	push   %eax
c002b5a2:	e8 db 84 ff ff       	call   c0023a82 <timer_sleep>
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002b5a7:	e8 6d 58 ff ff       	call   c0020e19 <thread_get_recent_cpu>
c002b5ac:	83 c4 10             	add    $0x10,%esp
c002b5af:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002b5b4:	7f b4                	jg     c002b56a <test_mlfqs_recent_1+0x2e>

  start_time = timer_ticks ();
c002b5b6:	e8 82 84 ff ff       	call   c0023a3d <timer_ticks>
c002b5bb:	89 c6                	mov    %eax,%esi
c002b5bd:	89 d7                	mov    %edx,%edi

void
test_mlfqs_recent_1 (void) 
{
  int64_t start_time;
  int last_elapsed = 0;
c002b5bf:	bd 00 00 00 00       	mov    $0x0,%ebp
c002b5c4:	eb 02                	jmp    c002b5c8 <test_mlfqs_recent_1+0x8c>
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002b5c6:	89 dd                	mov    %ebx,%ebp
  while (thread_get_recent_cpu () > 700);

  start_time = timer_ticks ();
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002b5c8:	83 ec 08             	sub    $0x8,%esp
c002b5cb:	57                   	push   %edi
c002b5cc:	56                   	push   %esi
c002b5cd:	e8 94 84 ff ff       	call   c0023a66 <timer_elapsed>
c002b5d2:	89 c3                	mov    %eax,%ebx
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002b5d4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b5d9:	f7 eb                	imul   %ebx
c002b5db:	c1 fa 06             	sar    $0x6,%edx
c002b5de:	89 d8                	mov    %ebx,%eax
c002b5e0:	c1 f8 1f             	sar    $0x1f,%eax
c002b5e3:	29 c2                	sub    %eax,%edx
c002b5e5:	69 d2 c8 00 00 00    	imul   $0xc8,%edx,%edx
c002b5eb:	83 c4 10             	add    $0x10,%esp
c002b5ee:	39 d3                	cmp    %edx,%ebx
c002b5f0:	75 d4                	jne    c002b5c6 <test_mlfqs_recent_1+0x8a>
c002b5f2:	39 dd                	cmp    %ebx,%ebp
c002b5f4:	7d d0                	jge    c002b5c6 <test_mlfqs_recent_1+0x8a>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002b5f6:	e8 1e 58 ff ff       	call   c0020e19 <thread_get_recent_cpu>
c002b5fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
          int load_avg = thread_get_load_avg ();
c002b5ff:	e8 aa 57 ff ff       	call   c0020dae <thread_get_load_avg>
c002b604:	89 c1                	mov    %eax,%ecx
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002b606:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b60b:	f7 eb                	imul   %ebx
c002b60d:	c1 fa 05             	sar    $0x5,%edx
c002b610:	89 dd                	mov    %ebx,%ebp
c002b612:	c1 fd 1f             	sar    $0x1f,%ebp
c002b615:	29 ea                	sub    %ebp,%edx
c002b617:	89 d5                	mov    %edx,%ebp
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002b619:	83 ec 08             	sub    $0x8,%esp
c002b61c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b621:	f7 e9                	imul   %ecx
c002b623:	c1 fa 05             	sar    $0x5,%edx
c002b626:	89 c8                	mov    %ecx,%eax
c002b628:	c1 f8 1f             	sar    $0x1f,%eax
c002b62b:	29 c2                	sub    %eax,%edx
c002b62d:	6b c2 64             	imul   $0x64,%edx,%eax
c002b630:	29 c1                	sub    %eax,%ecx
c002b632:	51                   	push   %ecx
c002b633:	52                   	push   %edx
c002b634:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002b639:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002b63d:	f7 e9                	imul   %ecx
c002b63f:	c1 fa 05             	sar    $0x5,%edx
c002b642:	89 c8                	mov    %ecx,%eax
c002b644:	c1 f8 1f             	sar    $0x1f,%eax
c002b647:	29 c2                	sub    %eax,%edx
c002b649:	6b c2 64             	imul   $0x64,%edx,%eax
c002b64c:	29 c1                	sub    %eax,%ecx
c002b64e:	51                   	push   %ecx
c002b64f:	52                   	push   %edx
c002b650:	55                   	push   %ebp
c002b651:	68 bc 01 03 c0       	push   $0xc00301bc
c002b656:	e8 3b e1 ff ff       	call   c0029796 <msg>
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002b65b:	83 c4 20             	add    $0x20,%esp
c002b65e:	81 fd b3 00 00 00    	cmp    $0xb3,%ebp
c002b664:	0f 8e 5c ff ff ff    	jle    c002b5c6 <test_mlfqs_recent_1+0x8a>
            break;
        } 
      last_elapsed = elapsed;
    }
}
c002b66a:	83 c4 1c             	add    $0x1c,%esp
c002b66d:	5b                   	pop    %ebx
c002b66e:	5e                   	pop    %esi
c002b66f:	5f                   	pop    %edi
c002b670:	5d                   	pop    %ebp
c002b671:	c3                   	ret    

c002b672 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002b672:	55                   	push   %ebp
c002b673:	57                   	push   %edi
c002b674:	56                   	push   %esi
c002b675:	53                   	push   %ebx
c002b676:	81 ec 6c 01 00 00    	sub    $0x16c,%esp
c002b67c:	89 44 24 04          	mov    %eax,0x4(%esp)
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002b680:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b687:	75 1e                	jne    c002b6a7 <test_mlfqs_fair+0x35>
c002b689:	83 ec 0c             	sub    $0xc,%esp
c002b68c:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b691:	68 3f d2 02 c0       	push   $0xc002d23f
c002b696:	68 b0 d1 02 c0       	push   $0xc002d1b0
c002b69b:	6a 49                	push   $0x49
c002b69d:	68 6c 02 03 c0       	push   $0xc003026c
c002b6a2:	e8 26 c6 ff ff       	call   c0027ccd <debug_panic>
c002b6a7:	89 d6                	mov    %edx,%esi
c002b6a9:	89 cf                	mov    %ecx,%edi
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002b6ab:	83 7c 24 04 14       	cmpl   $0x14,0x4(%esp)
c002b6b0:	7e 1e                	jle    c002b6d0 <test_mlfqs_fair+0x5e>
c002b6b2:	83 ec 0c             	sub    $0xc,%esp
c002b6b5:	68 fa 01 03 c0       	push   $0xc00301fa
c002b6ba:	68 3f d2 02 c0       	push   $0xc002d23f
c002b6bf:	68 b0 d1 02 c0       	push   $0xc002d1b0
c002b6c4:	6a 4a                	push   $0x4a
c002b6c6:	68 6c 02 03 c0       	push   $0xc003026c
c002b6cb:	e8 fd c5 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (nice_min >= -10);
c002b6d0:	83 fa f6             	cmp    $0xfffffff6,%edx
c002b6d3:	7d 1e                	jge    c002b6f3 <test_mlfqs_fair+0x81>
c002b6d5:	83 ec 0c             	sub    $0xc,%esp
c002b6d8:	68 17 02 03 c0       	push   $0xc0030217
c002b6dd:	68 3f d2 02 c0       	push   $0xc002d23f
c002b6e2:	68 b0 d1 02 c0       	push   $0xc002d1b0
c002b6e7:	6a 4b                	push   $0x4b
c002b6e9:	68 6c 02 03 c0       	push   $0xc003026c
c002b6ee:	e8 da c5 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (nice_step >= 0);
c002b6f3:	85 c9                	test   %ecx,%ecx
c002b6f5:	79 1e                	jns    c002b715 <test_mlfqs_fair+0xa3>
c002b6f7:	83 ec 0c             	sub    $0xc,%esp
c002b6fa:	68 27 02 03 c0       	push   $0xc0030227
c002b6ff:	68 3f d2 02 c0       	push   $0xc002d23f
c002b704:	68 b0 d1 02 c0       	push   $0xc002d1b0
c002b709:	6a 4c                	push   $0x4c
c002b70b:	68 6c 02 03 c0       	push   $0xc003026c
c002b710:	e8 b8 c5 ff ff       	call   c0027ccd <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002b715:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b719:	83 e8 01             	sub    $0x1,%eax
c002b71c:	0f af c1             	imul   %ecx,%eax
c002b71f:	01 d0                	add    %edx,%eax
c002b721:	83 f8 14             	cmp    $0x14,%eax
c002b724:	7e 1e                	jle    c002b744 <test_mlfqs_fair+0xd2>
c002b726:	83 ec 0c             	sub    $0xc,%esp
c002b729:	68 90 02 03 c0       	push   $0xc0030290
c002b72e:	68 3f d2 02 c0       	push   $0xc002d23f
c002b733:	68 b0 d1 02 c0       	push   $0xc002d1b0
c002b738:	6a 4d                	push   $0x4d
c002b73a:	68 6c 02 03 c0       	push   $0xc003026c
c002b73f:	e8 89 c5 ff ff       	call   c0027ccd <debug_panic>

  thread_set_nice (-20);
c002b744:	83 ec 0c             	sub    $0xc,%esp
c002b747:	6a ec                	push   $0xffffffec
c002b749:	e8 e2 5b ff ff       	call   c0021330 <thread_set_nice>

  start_time = timer_ticks ();
c002b74e:	e8 ea 82 ff ff       	call   c0023a3d <timer_ticks>
c002b753:	89 44 24 18          	mov    %eax,0x18(%esp)
c002b757:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  msg ("Starting %d threads...", thread_cnt);
c002b75b:	83 c4 08             	add    $0x8,%esp
c002b75e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002b762:	53                   	push   %ebx
c002b763:	68 36 02 03 c0       	push   $0xc0030236
c002b768:	e8 29 e0 ff ff       	call   c0029796 <msg>
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002b76d:	83 c4 10             	add    $0x10,%esp
c002b770:	85 db                	test   %ebx,%ebx
c002b772:	0f 8e c5 00 00 00    	jle    c002b83d <test_mlfqs_fair+0x1cb>
c002b778:	8d 5c 24 20          	lea    0x20(%esp),%ebx
c002b77c:	bd 00 00 00 00       	mov    $0x0,%ebp
    {
      struct thread_info *ti = &info[i];
      char name[16];

      ti->start_time = start_time;
c002b781:	8b 44 24 08          	mov    0x8(%esp),%eax
c002b785:	8b 54 24 0c          	mov    0xc(%esp),%edx
c002b789:	89 03                	mov    %eax,(%ebx)
c002b78b:	89 53 04             	mov    %edx,0x4(%ebx)
      ti->tick_count = 0;
c002b78e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
      ti->nice = nice;
c002b795:	89 73 0c             	mov    %esi,0xc(%ebx)

      snprintf(name, sizeof name, "load %d", i);
c002b798:	55                   	push   %ebp
c002b799:	68 6e 00 03 c0       	push   $0xc003006e
c002b79e:	6a 10                	push   $0x10
c002b7a0:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002b7a4:	50                   	push   %eax
c002b7a5:	e8 b8 af ff ff       	call   c0026762 <snprintf>
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002b7aa:	53                   	push   %ebx
c002b7ab:	68 85 b8 02 c0       	push   $0xc002b885
c002b7b0:	6a 1f                	push   $0x1f
c002b7b2:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002b7b6:	50                   	push   %eax
c002b7b7:	e8 05 5a ff ff       	call   c00211c1 <thread_create>

      nice += nice_step;
c002b7bc:	01 fe                	add    %edi,%esi
  thread_set_nice (-20);

  start_time = timer_ticks ();
  msg ("Starting %d threads...", thread_cnt);
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002b7be:	83 c5 01             	add    $0x1,%ebp
c002b7c1:	83 c3 10             	add    $0x10,%ebx
c002b7c4:	83 c4 20             	add    $0x20,%esp
c002b7c7:	39 6c 24 04          	cmp    %ebp,0x4(%esp)
c002b7cb:	75 b4                	jne    c002b781 <test_mlfqs_fair+0x10f>
c002b7cd:	eb 22                	jmp    c002b7f1 <test_mlfqs_fair+0x17f>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
  timer_sleep (40 * TIMER_FREQ);
  
  for (i = 0; i < thread_cnt; i++)
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002b7cf:	83 ec 04             	sub    $0x4,%esp
c002b7d2:	ff 36                	pushl  (%esi)
c002b7d4:	53                   	push   %ebx
c002b7d5:	68 4d 02 03 c0       	push   $0xc003024d
c002b7da:	e8 b7 df ff ff       	call   c0029796 <msg>
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));

  msg ("Sleeping 40 seconds to let threads run, please wait...");
  timer_sleep (40 * TIMER_FREQ);
  
  for (i = 0; i < thread_cnt; i++)
c002b7df:	83 c3 01             	add    $0x1,%ebx
c002b7e2:	83 c6 10             	add    $0x10,%esi
c002b7e5:	83 c4 10             	add    $0x10,%esp
c002b7e8:	39 df                	cmp    %ebx,%edi
c002b7ea:	75 e3                	jne    c002b7cf <test_mlfqs_fair+0x15d>
c002b7ec:	e9 89 00 00 00       	jmp    c002b87a <test_mlfqs_fair+0x208>
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, ti);

      nice += nice_step;
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002b7f1:	83 ec 08             	sub    $0x8,%esp
c002b7f4:	ff 74 24 14          	pushl  0x14(%esp)
c002b7f8:	ff 74 24 14          	pushl  0x14(%esp)
c002b7fc:	e8 65 82 ff ff       	call   c0023a66 <timer_elapsed>
c002b801:	83 c4 0c             	add    $0xc,%esp
c002b804:	52                   	push   %edx
c002b805:	50                   	push   %eax
c002b806:	68 c0 02 03 c0       	push   $0xc00302c0
c002b80b:	e8 86 df ff ff       	call   c0029796 <msg>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002b810:	c7 04 24 e4 02 03 c0 	movl   $0xc00302e4,(%esp)
c002b817:	e8 7a df ff ff       	call   c0029796 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002b81c:	83 c4 08             	add    $0x8,%esp
c002b81f:	6a 00                	push   $0x0
c002b821:	68 a0 0f 00 00       	push   $0xfa0
c002b826:	e8 57 82 ff ff       	call   c0023a82 <timer_sleep>
c002b82b:	8d 74 24 38          	lea    0x38(%esp),%esi
c002b82f:	83 c4 10             	add    $0x10,%esp
c002b832:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b837:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002b83b:	eb 92                	jmp    c002b7cf <test_mlfqs_fair+0x15d>
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, ti);

      nice += nice_step;
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002b83d:	83 ec 08             	sub    $0x8,%esp
c002b840:	ff 74 24 14          	pushl  0x14(%esp)
c002b844:	ff 74 24 14          	pushl  0x14(%esp)
c002b848:	e8 19 82 ff ff       	call   c0023a66 <timer_elapsed>
c002b84d:	83 c4 0c             	add    $0xc,%esp
c002b850:	52                   	push   %edx
c002b851:	50                   	push   %eax
c002b852:	68 c0 02 03 c0       	push   $0xc00302c0
c002b857:	e8 3a df ff ff       	call   c0029796 <msg>

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002b85c:	c7 04 24 e4 02 03 c0 	movl   $0xc00302e4,(%esp)
c002b863:	e8 2e df ff ff       	call   c0029796 <msg>
  timer_sleep (40 * TIMER_FREQ);
c002b868:	83 c4 08             	add    $0x8,%esp
c002b86b:	6a 00                	push   $0x0
c002b86d:	68 a0 0f 00 00       	push   $0xfa0
c002b872:	e8 0b 82 ff ff       	call   c0023a82 <timer_sleep>
c002b877:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
}
c002b87a:	81 c4 6c 01 00 00    	add    $0x16c,%esp
c002b880:	5b                   	pop    %ebx
c002b881:	5e                   	pop    %esi
c002b882:	5f                   	pop    %edi
c002b883:	5d                   	pop    %ebp
c002b884:	c3                   	ret    

c002b885 <load_thread>:

static void
load_thread (void *ti_) 
{
c002b885:	57                   	push   %edi
c002b886:	56                   	push   %esi
c002b887:	53                   	push   %ebx
c002b888:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct thread_info *ti = ti_;
  int64_t sleep_time = 5 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
c002b88c:	83 ec 0c             	sub    $0xc,%esp
c002b88f:	ff 77 0c             	pushl  0xc(%edi)
c002b892:	e8 99 5a ff ff       	call   c0021330 <thread_set_nice>
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002b897:	83 c4 08             	add    $0x8,%esp
c002b89a:	ff 77 04             	pushl  0x4(%edi)
c002b89d:	ff 37                	pushl  (%edi)
c002b89f:	e8 c2 81 ff ff       	call   c0023a66 <timer_elapsed>
c002b8a4:	83 c4 08             	add    $0x8,%esp
c002b8a7:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
c002b8ac:	bb 00 00 00 00       	mov    $0x0,%ebx
c002b8b1:	29 c1                	sub    %eax,%ecx
c002b8b3:	19 d3                	sbb    %edx,%ebx
c002b8b5:	53                   	push   %ebx
c002b8b6:	51                   	push   %ecx
c002b8b7:	e8 c6 81 ff ff       	call   c0023a82 <timer_sleep>
  while (timer_elapsed (ti->start_time) < spin_time) 
c002b8bc:	83 c4 10             	add    $0x10,%esp
load_thread (void *ti_) 
{
  struct thread_info *ti = ti_;
  int64_t sleep_time = 5 * TIMER_FREQ;
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;
c002b8bf:	be 00 00 00 00       	mov    $0x0,%esi
c002b8c4:	bb 00 00 00 00       	mov    $0x0,%ebx

  thread_set_nice (ti->nice);
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
  while (timer_elapsed (ti->start_time) < spin_time) 
c002b8c9:	eb 15                	jmp    c002b8e0 <load_thread+0x5b>
    {
      int64_t cur_time = timer_ticks ();
c002b8cb:	e8 6d 81 ff ff       	call   c0023a3d <timer_ticks>
      if (cur_time != last_time)
c002b8d0:	31 d3                	xor    %edx,%ebx
c002b8d2:	31 c6                	xor    %eax,%esi
c002b8d4:	09 f3                	or     %esi,%ebx
c002b8d6:	74 04                	je     c002b8dc <load_thread+0x57>
        ti->tick_count++;
c002b8d8:	83 47 08 01          	addl   $0x1,0x8(%edi)
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
}

static void
load_thread (void *ti_) 
{
c002b8dc:	89 c6                	mov    %eax,%esi
c002b8de:	89 d3                	mov    %edx,%ebx
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
  while (timer_elapsed (ti->start_time) < spin_time) 
c002b8e0:	83 ec 08             	sub    $0x8,%esp
c002b8e3:	ff 77 04             	pushl  0x4(%edi)
c002b8e6:	ff 37                	pushl  (%edi)
c002b8e8:	e8 79 81 ff ff       	call   c0023a66 <timer_elapsed>
c002b8ed:	83 c4 10             	add    $0x10,%esp
c002b8f0:	85 d2                	test   %edx,%edx
c002b8f2:	78 d7                	js     c002b8cb <load_thread+0x46>
c002b8f4:	85 d2                	test   %edx,%edx
c002b8f6:	7f 07                	jg     c002b8ff <load_thread+0x7a>
c002b8f8:	3d ab 0d 00 00       	cmp    $0xdab,%eax
c002b8fd:	76 cc                	jbe    c002b8cb <load_thread+0x46>
      int64_t cur_time = timer_ticks ();
      if (cur_time != last_time)
        ti->tick_count++;
      last_time = cur_time;
    }
}
c002b8ff:	5b                   	pop    %ebx
c002b900:	5e                   	pop    %esi
c002b901:	5f                   	pop    %edi
c002b902:	c3                   	ret    

c002b903 <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002b903:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 0);
c002b906:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b90b:	ba 00 00 00 00       	mov    $0x0,%edx
c002b910:	b8 02 00 00 00       	mov    $0x2,%eax
c002b915:	e8 58 fd ff ff       	call   c002b672 <test_mlfqs_fair>
}
c002b91a:	83 c4 0c             	add    $0xc,%esp
c002b91d:	c3                   	ret    

c002b91e <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002b91e:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (20, 0, 0);
c002b921:	b9 00 00 00 00       	mov    $0x0,%ecx
c002b926:	ba 00 00 00 00       	mov    $0x0,%edx
c002b92b:	b8 14 00 00 00       	mov    $0x14,%eax
c002b930:	e8 3d fd ff ff       	call   c002b672 <test_mlfqs_fair>
}
c002b935:	83 c4 0c             	add    $0xc,%esp
c002b938:	c3                   	ret    

c002b939 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002b939:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (2, 0, 5);
c002b93c:	b9 05 00 00 00       	mov    $0x5,%ecx
c002b941:	ba 00 00 00 00       	mov    $0x0,%edx
c002b946:	b8 02 00 00 00       	mov    $0x2,%eax
c002b94b:	e8 22 fd ff ff       	call   c002b672 <test_mlfqs_fair>
}
c002b950:	83 c4 0c             	add    $0xc,%esp
c002b953:	c3                   	ret    

c002b954 <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002b954:	83 ec 0c             	sub    $0xc,%esp
  test_mlfqs_fair (10, 0, 1);
c002b957:	b9 01 00 00 00       	mov    $0x1,%ecx
c002b95c:	ba 00 00 00 00       	mov    $0x0,%edx
c002b961:	b8 0a 00 00 00       	mov    $0xa,%eax
c002b966:	e8 07 fd ff ff       	call   c002b672 <test_mlfqs_fair>
}
c002b96b:	83 c4 0c             	add    $0xc,%esp
c002b96e:	c3                   	ret    

c002b96f <block_thread>:
  msg ("Block thread should have already acquired lock.");
}

static void
block_thread (void *lock_) 
{
c002b96f:	57                   	push   %edi
c002b970:	56                   	push   %esi
c002b971:	83 ec 10             	sub    $0x10,%esp
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002b974:	68 1c 03 03 c0       	push   $0xc003031c
c002b979:	e8 18 de ff ff       	call   c0029796 <msg>
  start_time = timer_ticks ();
c002b97e:	e8 ba 80 ff ff       	call   c0023a3d <timer_ticks>
c002b983:	89 c6                	mov    %eax,%esi
c002b985:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002b987:	83 c4 10             	add    $0x10,%esp
c002b98a:	83 ec 08             	sub    $0x8,%esp
c002b98d:	57                   	push   %edi
c002b98e:	56                   	push   %esi
c002b98f:	e8 d2 80 ff ff       	call   c0023a66 <timer_elapsed>
c002b994:	83 c4 10             	add    $0x10,%esp
c002b997:	85 d2                	test   %edx,%edx
c002b999:	78 ef                	js     c002b98a <block_thread+0x1b>
c002b99b:	85 d2                	test   %edx,%edx
c002b99d:	7f 07                	jg     c002b9a6 <block_thread+0x37>
c002b99f:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002b9a4:	76 e4                	jbe    c002b98a <block_thread+0x1b>
    continue;

  msg ("Block thread acquiring lock...");
c002b9a6:	83 ec 0c             	sub    $0xc,%esp
c002b9a9:	68 44 03 03 c0       	push   $0xc0030344
c002b9ae:	e8 e3 dd ff ff       	call   c0029796 <msg>
  lock_acquire (lock);
c002b9b3:	83 c4 04             	add    $0x4,%esp
c002b9b6:	ff 74 24 1c          	pushl  0x1c(%esp)
c002b9ba:	e8 00 70 ff ff       	call   c00229bf <lock_acquire>

  msg ("...got it.");
c002b9bf:	c7 04 24 1c 04 03 c0 	movl   $0xc003041c,(%esp)
c002b9c6:	e8 cb dd ff ff       	call   c0029796 <msg>
}
c002b9cb:	83 c4 14             	add    $0x14,%esp
c002b9ce:	5e                   	pop    %esi
c002b9cf:	5f                   	pop    %edi
c002b9d0:	c3                   	ret    

c002b9d1 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002b9d1:	57                   	push   %edi
c002b9d2:	56                   	push   %esi
c002b9d3:	53                   	push   %ebx
c002b9d4:	83 ec 20             	sub    $0x20,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002b9d7:	80 3d d4 96 03 c0 00 	cmpb   $0x0,0xc00396d4
c002b9de:	75 1e                	jne    c002b9fe <test_mlfqs_block+0x2d>
c002b9e0:	83 ec 0c             	sub    $0xc,%esp
c002b9e3:	68 b5 f1 02 c0       	push   $0xc002f1b5
c002b9e8:	68 3f d2 02 c0       	push   $0xc002d23f
c002b9ed:	68 c0 d1 02 c0       	push   $0xc002d1c0
c002b9f2:	6a 1c                	push   $0x1c
c002b9f4:	68 64 03 03 c0       	push   $0xc0030364
c002b9f9:	e8 cf c2 ff ff       	call   c0027ccd <debug_panic>

  msg ("Main thread acquiring lock.");
c002b9fe:	83 ec 0c             	sub    $0xc,%esp
c002ba01:	68 27 04 03 c0       	push   $0xc0030427
c002ba06:	e8 8b dd ff ff       	call   c0029796 <msg>
  lock_init (&lock);
c002ba0b:	83 c4 04             	add    $0x4,%esp
c002ba0e:	8d 5c 24 0c          	lea    0xc(%esp),%ebx
c002ba12:	53                   	push   %ebx
c002ba13:	e8 25 6f ff ff       	call   c002293d <lock_init>
  lock_acquire (&lock);
c002ba18:	89 1c 24             	mov    %ebx,(%esp)
c002ba1b:	e8 9f 6f ff ff       	call   c00229bf <lock_acquire>
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002ba20:	c7 04 24 88 03 03 c0 	movl   $0xc0030388,(%esp)
c002ba27:	e8 6a dd ff ff       	call   c0029796 <msg>
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002ba2c:	53                   	push   %ebx
c002ba2d:	68 6f b9 02 c0       	push   $0xc002b96f
c002ba32:	6a 1f                	push   $0x1f
c002ba34:	68 ae f1 02 c0       	push   $0xc002f1ae
c002ba39:	e8 83 57 ff ff       	call   c00211c1 <thread_create>
  timer_sleep (25 * TIMER_FREQ);
c002ba3e:	83 c4 18             	add    $0x18,%esp
c002ba41:	6a 00                	push   $0x0
c002ba43:	68 c4 09 00 00       	push   $0x9c4
c002ba48:	e8 35 80 ff ff       	call   c0023a82 <timer_sleep>

  msg ("Main thread spinning for 5 seconds...");
c002ba4d:	c7 04 24 c4 03 03 c0 	movl   $0xc00303c4,(%esp)
c002ba54:	e8 3d dd ff ff       	call   c0029796 <msg>
  start_time = timer_ticks ();
c002ba59:	e8 df 7f ff ff       	call   c0023a3d <timer_ticks>
c002ba5e:	89 c6                	mov    %eax,%esi
c002ba60:	89 d7                	mov    %edx,%edi
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002ba62:	83 c4 10             	add    $0x10,%esp
c002ba65:	83 ec 08             	sub    $0x8,%esp
c002ba68:	57                   	push   %edi
c002ba69:	56                   	push   %esi
c002ba6a:	e8 f7 7f ff ff       	call   c0023a66 <timer_elapsed>
c002ba6f:	83 c4 10             	add    $0x10,%esp
c002ba72:	85 d2                	test   %edx,%edx
c002ba74:	78 ef                	js     c002ba65 <test_mlfqs_block+0x94>
c002ba76:	85 d2                	test   %edx,%edx
c002ba78:	7f 07                	jg     c002ba81 <test_mlfqs_block+0xb0>
c002ba7a:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002ba7f:	76 e4                	jbe    c002ba65 <test_mlfqs_block+0x94>
    continue;

  msg ("Main thread releasing lock.");
c002ba81:	83 ec 0c             	sub    $0xc,%esp
c002ba84:	68 43 04 03 c0       	push   $0xc0030443
c002ba89:	e8 08 dd ff ff       	call   c0029796 <msg>
  lock_release (&lock);
c002ba8e:	83 c4 04             	add    $0x4,%esp
c002ba91:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002ba95:	50                   	push   %eax
c002ba96:	e8 b4 70 ff ff       	call   c0022b4f <lock_release>

  msg ("Block thread should have already acquired lock.");
c002ba9b:	c7 04 24 ec 03 03 c0 	movl   $0xc00303ec,(%esp)
c002baa2:	e8 ef dc ff ff       	call   c0029796 <msg>
}
c002baa7:	83 c4 30             	add    $0x30,%esp
c002baaa:	5b                   	pop    %ebx
c002baab:	5e                   	pop    %esi
c002baac:	5f                   	pop    %edi
c002baad:	c3                   	ret    
